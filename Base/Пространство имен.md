# Type aliases
Псевдоним типа означает синоним типа, т.е. мы создаем лишь новое имя для данного типа. Полезно, если у нас длинный тип который применяется во многих местах кода.

```cpp
using StopPtr = std::unordered_map<std::string, std::shared_ptr<Stop>>
// Далее вместо мапы будем писать StopPtr, что эквивалентно ей
using IntPtr = int*;
```

# typedefs
До C++11 пользовались typedefs.

```cpp
typedef std::unordered_map<std::string, std::shared_ptr<Stop>> StopPtr
```

Но предпочтительнее использовать type alias

#do/continue написать про typename

# Пространство имен
Допустим, мы разработали 2 библиотеки для парсинга данных. И в той, и в той есть функция Load. Если мы подключим 2 библиотеки к одному проекту и попытаемся вызвать функцию Load, то появится ошибка, т.к. компилятор не понимает какую именно вызывать. Чтобы решить эту проблему объявление и определение библиотеки нужно обернуть в пространство имен.

```cpp
namespace xml{
class Node {...}; 
class Document {...}; 
Document Load(istream& ...);
}

namespace json {
class Node {...}; 
class Document {...}; 
Document Load(istream& ...);
}
int main()
{
	xml::Load(..);
	json::Load(..);
	//теперь все хорошо
}
```

Теперь разберемся с синтаксисом

```cpp
namespace json {
class Node {...}; 
class Document {...}; 
Document Load(istream& ...);
// определяем функцию 2-мя способами
Document Load(isream& input) { ... }
}
Json::Document Json::Load(isream& input) { ... }
```

Если написать `using json::Load`, то не придется все время приписывать название пространства имен для данной функции

```cpp
using json::Load;
using json::Document;
namespace json {
class Node {...}; 
class Document {...}; 
Document Load(istream& ...);
}

Document Load(isream& input) { ... }
```

Если напишем `using namespace json`, то вообще не нужно будет приписывать название пространства

```cpp
namespace json {
class Node {...}; 
class Document {...}; 
Document Load(istream& ...);
}
using namespace json;
Document Load(isream& input) { ... }
```

Отсюда следует вывод, что такое можно писать только в cpp файлах, поскольку никогда не знаешь куда будет подключаться заголовочный файл и с чем в дальнейшем он будет конфликтовать.

Пространство имен расширяемо, т.е.

```cpp
namespace json {
class Node {...};
}
namespace json{
class Document {...}; 
Document Load(istream& ...);
// определяем функцию 2-мя способами
Document Load(isream& input) { ... }
}
```

В пространстве `json` находятся 2 класса и 1 функция.

Пространство имен используется не только для избегания конфликта имен, но и для структурирования программы. Допустим если у нас есть базовый класс Animal и от него наследуются еще несколько классов животных, например Tiger, Lion, Cat, Dog, их можно объединить в пространство имен, базовый класс включать в него не обязательно. 

Рекомендации по использованию пространств имён:
* Пространство имён имеет смысл применять только в больших проектах, потому что если у вас маленькая программа, которая состоит из одного, двух, максимум трех файлов, то конечно вряд ли у вас возникнет конфликт имён. Когда же у вас большой проект на десятки, сотни, а то и тысячи файлов, то вероятность возникновения конфликтов имён там довольно высока, и поэтому здесь уже возникает смысл использовать пространство имён.
* Пусть вы создали какую-то библиотеку, то есть какой-то обособленный набор функций и классов, который решает не одну какую-то конкретную специфическую задачу, а какой-то набор задач; пусть вы хотите поделиться ею с миром. Тогда обязательно оберните функции и классы в вашей библиотеке в пространство имён, для того, чтобы у других пользователей не возникало конфликтов имён.
* using-декларации и директивы using namespace позволяют уменьшить объем кода, но при этом повышают вероятность возникновения конфликтов имён, поэтому ими надо пользоваться с осторожностью и стараться минимизировать область их действия (область действия using-декларации и директивы using namespace — это тот блок кода, в котором они объявлены). Не надо использовать using namespace в заголовочных файлах. А в cppфайлах, при определенных условиях, это директива отлично работает и упрощает написание кода, поэтому ее можно использовать в cpp-файлах, но с осторожностью, чтобы не возникали неожиданные конфликты имён.
* можно пробовать объединять общие по смыслу функции и классы в специальное пространство имён, чтобы подчеркнуть логическую структуру вашей программы, сократить размер отдельных файлов, и в отдельных случаях упростить чтение и понимание вашего кода.