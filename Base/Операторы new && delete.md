# Операторы new && delete, new[] && delete[]
# Операторы new && delete
Для того, чтобы выделить память в куче нужно использовать оператор `new` и указатель `T*`, указатель должен быть чем-то проинициализирован либо быть `nullptr`.

```cpp
int* pInt = new int;//pInt указатель на значение типа int
//pInt как адрес, будет храниться на стеке и указаывать на область памяти в куче.

int** handle { nullptr };
handle = new int*;//handle - адресс находящийся на стеке, который указывает на переменную
*handle = new int;//*handle находящуюся в куче которая указывает на переменную int тоже находящуюся в куче
```

Оператор `new` возвращает указатель на объект который он создал(если тип double, то new вернет указатель типа double*), если их несколько, как в примере выше, то на первый объект.

Мы не можем присваивать указатели разных типов друг другу, т.к. они имеют разные типы $=>$  они занимают разный объем памяти.

Указатель – это адрес в памяти. Память в С++ представляется как линейный массив байтов. Указатель – это индекс в этом массиве.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
cout << ∗s << ' ' << s−>size () << endl; 
// Hello 5
```

Оператор `*`, примененный к указателю, возвращает ссылку на объект в куче.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
string& ref_to_s = ∗s; 
ref_to_s += ", world"; 
cout << ∗s << endl; 
// Hello, world
```


Если мы выделим память в куче, не удалим и указатель на эту область выйдет из области видимости, то произойдет утечка, мы никак не сможем удалить ее, т.к. доступа к ней нет, поэтому программа будет тратить лишнюю память. Если выделять память в куче в цикле `for` и не освобождать, то на какой-то итерации произойдет вылет из программы(в зависимости от объема вашей оперативной памяти).

```cpp
int* pInt = new int;
delete pInt;
pInt = nullptr; //рекомендуется занулять удаленный указать, чтобы случайно его не использовать, поскольку pInt еще указывает на область памяти в куче, обращение к ней UB, повторное удаление UB.

int** handle { new int* };
*handle = new int;
delete *handle;
delete handle;
handle = nullptr;
```

# Операторы new[ ] && delete[ ]
Оператор new[] позволяет выделить блок памяти для хранения необходимого количества объектов.

```cpp
double *p;
p = new double[4];//выделяем память для 4 чисел типа double
int* myArrayPtr { new int[] { 1, 2, 3, 4, 5 } };

double** twoarr { new double*[4]};
for (size_t i { 0 }; i < 4; i++) { twoarr[i] = new double; } //allocate
for (size_t i { 0 }; i < 4; i++) {//deallocate
	delete twoarr[i];
	twoarr[i] = nullptr;
}
delete [] twoarr;
twoarr = nullptr;
```

![](cpp_basic16.png)

Доступ к элементам массива мы можем получить с помощью оператора индексирования.

```cpp
double *pd = new double[3];
double x = *pd; //присваиваем x первое значение массива
pd[2] = 2.2;
pd[4] = 4.4;
pd[-3] = -3.3;
delete pd;
pd = nullptr;
```
Т.к. указатель не знает на какой диапазон элементов он указывает, то мы можем выходить за его рамки и компилятор не посчитает это за ошибку. Мы просто изменить значения другого объекта, о котором мы ничего не знаем.

![](cpp_basic18.png)

pd - динамически выделяемый массив, не динамический массив, мы можем указать размер во время выполнения программы, но не можем расширять его

# new и delete для объектов классового типа
При выделении памяти в куче для объекта классового типа вызывается конструктор, при удалении с помощью `delete` вызывается деструктор.

# Разница между new/delete и malloc/free
1. new в отличии от malloc, вызывает констурктор у объекта
```cpp
Foo* myFoo { (Foo*)malloc(sizeof(Foo)) };//выделилась память нужного размера
Foo* myOtherFoo { new Foo{} };//выделилась память и создался объект
```
1. При вызове `free()` у класса не вызовется деструктор в  отличии от `delete`
2. new - оператор который можно переопределить

# Исключения и new
new может выбросить исключение, если ей не удается выделить нужное количество памяти из-за нехватки ресурсов
```cpp
int* ptr { new(nothrow) int };//вместо исключения возратит nullptr, но рекомендуется использовать стандартный new
```

# Многомерные массивы
Многомерные массивы можно представить как шахматную доску.

## Стек

```cpp
char board[12][12]{};
```

Память в компьютере последовательна, двумерный массив в нем представлен как последовательность board[0][0], board[0][1] и т.д., наш массив состоит из 15 мини массивов, когда мы обращаемся по индексу к массиву, мы сначала ищем мини массив, а потом по этому мини массиву нужный элемент.

## Куча
Двумерный массив можно представить как указатель на указатель, а N-мерный, как N указателей.

```cpp
char** board { new char*[xPos] };
for (size_t i { 0 }; i < xPos; i++) {
	board[i] = new char[yPos]; // Allocate ith subarray
}
...
for (size_t i { 0 }; i < xPos; i++) {
	delete [] board[i]; // Delete its subarray
	board[i] = nullptr;
}
delete [] board; // Delete first dimension
board = nullptr;
```

Но это не совсем эффективно, лучше выделить сразу нужный блок памяти $=xPos * yPos * sizeof(char)$ и обращаться к элементам как $x * yPos + y$, поскольку программа будет работать быстрее если ее данные расположены последовательно.

# Работа с указателями
Мы можем изменить адрес указателя так:

```cpp
char* scaryPointer { (char*)7 };
// указатель имеет адрес 0x0000000000000007, т.е. мы можем вот так вот указывать на чужие данные, что не есть хорошо это UB
```

## C style Касты указателей
```cpp
Document* documentPtr { getDocument() };
char* myCharPtr { (char*)documentPtr };
```

Указатели слабо типизированы, используя c style касты мы можем легко привести их к любому типу, в C++ есть [[casting#static_cast|static_cast]] которые являются более безопасными





#do/review
1. перенести сюда из всех остальных файлах инфу по указателям и все этому
2. убрать не нужное
3. по порядку расположить а не как сейчас