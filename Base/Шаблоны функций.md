# Шаблоны функций
Чтобы обобщить функцию, т.е. заставить ее работаться с разными типами данных, можно использовать шаблон функции.

```cpp
template<typename T>
T Sqr(T a)
{
	return a * a;
}

int main(){
	int a = 5;
	double d = 6.0;
	auto i = Sqr(a);
	auto g = Sqr(d);
}
```

# Указание шаблонного параметра
```cpp
template<typename T>
T max(T a, T b) { 
	if (b < a) 
		return a; 
	return b; 
int main () { 
	cout << ::max(2, 3.5) << endl;//error 
	return 0; 
}
```

В данном случае компилятор не может сам вывести тип T, поскольку не может выбрать между int и double. В таком случае мы можем сделать либо 2 шаблонных параметра, либо указать желаемый тип.

```cpp
int main () { 
	cout << ::max<int>(2, 3.5) << endl; //3, используем глобальный скоуп :: поскольку в стандартной библиотеке уже есть функция max
	cout << ::max<double>(2, 3.5) << endl; //3.5
	return 0; 
}
```

Создание типа из шаблона класса называется инстанцированием, результатом является экземпляр шаблона.

# Возвращаемый тип
Принимая 2 и более шаблонных параметра не ясно каким делать возвращаемый тип:

```cpp
template<typename T, typename I, typename D>
T max(I a, D b) { 
	if (b < a) 
		return a; 
	return b;
}

template<typename I, typename D>
auto max(I a, D b) {//либо позволить компилятору самому вывести тип из return выражения  
	return ...;
}

template<typename I, typename D>
auto max(I a, D b) -> decltype(b<a?a:b) //либо самим указать
{  
	return ...;
}

template<typename I, typename D>
typename common_type<I, D>::type maax(I a, D b)//С C++14 можно писать common_type_t<I, D>
{
	return ...;
}

template<typename I, typename D, typename ReturnType = common_type_t<I, D>>//можно указать значение по умолчанию
ReturnType maax(I a, D b)
{
	return a;
}

int main () { 
	cout << ::max<double>(2, 3.5) << endl;//либо явно указывать тип, что не очень удобно 
	return 0; 
}
```


# Двухэтапная компиляция шаблона
1. Во время определения -  проверяется корректность без инстанцирования
	1. Выявление синтаксических ошибок
	2. Разрешаются независимые имена, т.е. те которые не зависят от параметров шаблона `T::collapse`, `collapse` зависит от T, если это встроенный тип, то на 2 этапе будет ошибка
	3. Проверка статических утверждений не зависящих от параметров шаблонов
2. Во время инстанцирования - код снова проверяется на корректность, но только уже проверяются зависимые имена и стат. утверждения зависящие от параметра шаблона.

```cpp
template<typename T>
void foo(T t)
{
    undeclared(); // first-phase compile-time error if undeclared() unknown
    undeclared(t); // second-phase compile-time error if undeclared(T) unknown
    static_assert(sizeof(int) > 10, // always fails if sizeof(int)<=10
    "int too small");
    static_assert(sizeof(T) > 10, // fails if instantiated for T with size <=10
    "T too small");
}

template <typename T> struct Base {  
    void exit();  
};  
template <typename T> struct Derived : Base<T> {  
    void foo() {  
        exit(); // можно подумать, что это Base::exit(), но это что-то из стандартной библиотеки 
        //решение ниже
        this->exit(); //либо так, 
        Base::exit(); // читается как Base<T>::exit();
        //теперь exit() стал зависимым именем.
    }  
};
```

Одна из немногих рациональных причин использования [[Указатель this]]

# Перегрузка шаблонов функций
```cpp
// maximum of two int values:
int max(int a, int b)
{
	return b < a ? a : b;
}
// maximum of two values of any type:
template<typename T>
T max(T a, T b)
{
	return b < a ? a : b;
}
int main()
{
	::max(7, 42);			// calls the nontemplate for two ints
	::max(7.0, 42.0);		// calls max<double> (by argument deduction)
	::max('a', 'b');		// calls max<char> (by argument deduction)
	::max<>(7, 42);			// calls max<int> (by argument deduction)
	::max<double>(7, 42);	// calls max<double> (no argument deduction)
	::max('a', 42.7);		// calls the nontemplate for two ints
}
```

Разрешения перегрузок:
1.  Сначала идут нешаблонные функции
2. Если шаблон генерирует функцию с лучшим соответствием(т.е. без всяких преобразований и кастов), то дальше идет он

# По значению или по ссылке
Передавая по ссылке пользовательские типы мы избавляемся от ненужного копирования, то у передаче по значению есть свои преимущества:
1. Лучшая оптимизация кода компилятором
2. Использование семантики перемещения
3. Нет возможно передачи строковых литераторов, только по const ref


# constexpr
```cpp
template<typename T1, typename T2>
constexpr auto max (T1 a, T2 b)
{
	return b < a ? a : b;
}

std::array<std::string, ::max(sizeof(char), 1OOOu)> arr;
```

# Параметры шаблонов функций, не являющиеся типами
```cpp
template<auto value, typename T = decltype(value)>  
void multval(T& x)  
{  
    x *= value;  
}  
  
template<typename Container, typename Op>  
void multcont(Container& cont, Op operataion)  
{  
    for(auto& x : cont)  
    {  
        operataion(x);  
    }  
}  
  
int main()  
{  
    std::vector<int> v{1,2,3,4,5,6};  
    multcont(v, multval<5, int>);  
}
```

# Ограничения на параметры шаблонов не являющиеся типами
В общем случае такие параметры должны быть целочисленные константы(включая перечисления), указатели на объекты/функции/члены, lvalue ссылки на объекты или функции, либо std::nullptr_t. Использование чисел с плавающей точкой и объектов с типом класса не разрешено.

При передаче указателей или ссылок объекты не должны быть строковыми литералами, временными значениями, данными или иными подобъектами.

# Разрешения перегрузки
1. Три правила для шаблонов 
	1. Точно подходящая функция выигрывает у шаблона
	```cpp
int foo(int a); // 1
<typename T> T foo(T a); // 2
foo(1); // → 1

foo<>(1); // → 2, можно явно указать, что мы хотим шаблон
foo<int>(1); // → 2, можно явно указать, что мы хотим шаблон

foo(1.0); // → 2, стандартные преобразования проигрывают шаблону
``` 
	2. Более специальный шаблон выигрывает у менее специального
	```cpp
template <typename T> void f(T); // 1
template <typename T> void f(T*); // 2
template <typename T> void f(T**); // 3
template <typename T> void f(T***); // 4
template <typename T> void f(T****); // 5
int*** a;
f(a); // → 4
f<int**>(a); // → 2
``` 
	3. Меньшее количество аргументов выигрывает против большего
 ```cpp
template <typename T1, typename T2> void f(T1, T2); // 1
template <typename T> void f(T, T*); // 2
double t, s;
f(t, &s); // → 2

template <typename T> void g(T, T); // 1
template <typename T1 typename T2> void g(T1, T2*); // 2
template <typename T1 typename T2> void g(T1*, T2*); // 3
g(&t, &s); // → FAIL, конфликт со 2 правилом
```

Специализация не участвует в перегрузке. Cначала разрешается перегрузка, потом ищется наименее общая специализация:

```cpp
template <typename T> void foo(T); // 1  
template <> void foo (int*); // 2  
template <typename T> void foo(T*); // 3  
int x;  

foo(&x); // вызовет [3], хотя [2] подходит лучше
```