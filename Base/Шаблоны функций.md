# Шаблоны функций
Чтобы обобщить функцию, т.е. заставить ее работаться с разными типами данных, можно использовать шаблон функции.

```cpp
template<typename T>
T Sqr(T a)
{
	return a * a;
}

int main(){
	int a = 5;
	double d = 6.0;
	auto i = Sqr(a);
	auto g = Sqr(d);
}
```

# Указание шаблонного параметра
```cpp
template<typename T>
T max(T a, T b) { 
	if (b < a) 
		return a; 
	return b; 
int main () { 
	cout << ::max(2, 3.5) << endl;//error 
	return 0; 
}
```

В данном случае компилятор не может сам вывести тип T, поскольку не может выбрать между int и double. В таком случае мы можем сделать либо 2 шаблонных параметра, либо указать желаемый тип.

```cpp
int main () { 
	cout << ::max<int>(2, 3.5) << endl; //3, используем глобальный скоуп :: поскольку в стандартной библиотеке уже есть функция max
	cout << ::max<double>(2, 3.5) << endl; //3.5
	return 0; 
}
```

Создание типа из шаблона класса называется инстанцированием, результатом является экземпляр шаблона.

# Возвращаемый тип
Принимая 2 и более шаблонных параметра не ясно каким делать возвращаемый тип:

```cpp
template<typename T, typename I, typename D>
T max(I a, D b) { 
	if (b < a) 
		return a; 
	return b;
}

template<typename I, typename D>
auto max(I a, D b) {//либо позволить компилятору самому вывести тип из return выражения  
	return ...;
}

template<typename I, typename D>
auto max(I a, D b) -> decltype(b<a?a:b) //либо самим указать
{  
	return ...;
}

template<typename I, typename D>
typename common_type<I, D>::type maax(I a, D b)//С C++14 можно писать common_type_t<I, D>
{
	return ...;
}

template<typename I, typename D, typename ReturnType = common_type_t<I, D>>//можно указать значение по умолчанию
ReturnType maax(I a, D b)
{
	return a;
}

int main () { 
	cout << ::max<double>(2, 3.5) << endl;//либо явно указывать тип, что не очень удобно 
	return 0; 
}
```


# Двухэтапная компиляция шаблона
1. Во время определения -  проверяется корректность без инстанцирования
	1. Выявление синтаксических ошибок
	2. Применение неизвестных имен
	3. Проверка статических утверждений не зависящих от параметров шаблонов
2. Во время инстанцирования - код снова проверяется на корректность, но только уже те конструкции которые зависят от параметров шаблона

```cpp
template<typename T>
void foo(T t)
{
    undeclared(); // first-phase compile-time error if undeclared() unknown
    undeclared(t); // second-phase compile-time error if undeclared(T) unknown
    static_assert(sizeof(int) > 10, // always fails if sizeof(int)<=10
    "int too small");
    static_assert(sizeof(T) > 10, // fails if instantiated for T with size <=10
    "T too small");
}
```

Проверка имен выполняемая дважды называется двухэтапным поиском.

# Перегрузка шаблонов функций
```cpp
// maximum of two int values:
int max(int a, int b)
{
	return b < a ? a : b;
}
// maximum of two values of any type:
template<typename T>
T max(T a, T b)
{
	return b < a ? a : b;
}
int main()
{
	::max(7, 42);			// calls the nontemplate for two ints
	::max(7.0, 42.0);		// calls max<double> (by argument deduction)
	::max('a', 'b');		// calls max<char> (by argument deduction)
	::max<>(7, 42);			// calls max<int> (by argument deduction)
	::max<double>(7, 42);	// calls max<double> (no argument deduction)
	::max('a', 42.7);		// calls the nontemplate for two ints
}
```

Разрешения перегрузок:
1.  Сначала идут нешаблонные функции
2. Если шаблон генерирует функцию с лучшим соответствием(т.е. без всяких преобразований и кастов), то дальше идет он

# По значению или по ссылке
Передавая по ссылке пользовательские типы мы избавляемся от ненужного копирования, то у передаче по значению есть свои преимущества:
1. Лучшая оптимизация кода компилятором
2. Использование семантики перемещения
3. Нет возможно передачи строковых литераторов, только по const ref


# constexpr
```cpp
template<typename T1, typename T2>
constexpr auto max (T1 a, T2 b)
{
	return b < a ? a : b;
}

std::array<std::string, ::max(sizeof(char), 1OOOu)> arr;
```

# Параметры шаблонов функций, не являющиеся типами
```cpp
template<auto value, typename T = decltype(value)>  
void multval(T& x)  
{  
    x *= value;  
}  
  
template<typename Container, typename Op>  
void multcont(Container& cont, Op operataion)  
{  
    for(auto& x : cont)  
    {  
        operataion(x);  
    }  
}  
  
int main()  
{  
    std::vector<int> v{1,2,3,4,5,6};  
    multcont(v, multval<5, int>);  
}
```

# Ограничения на параметры шаблонов не являющиеся типами
В общем случае такие параметры должны быть целочисленные константы(включая перечисления), указатели на объекты/функции/члены, lvalue ссылки на объекты или функции, либо std::nullptr_t. Использование чисел с плавающей точкой и объектов с типом класса не разрешено.

При передаче указателей или ссылок объекты не должны быть строковыми литералами, временными значениями, данными или иными подобъектами.




