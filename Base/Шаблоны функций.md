# Шаблоны функций
Чтобы обобщить функцию, т.е. заставить ее работаться с разными типами данных, можно использовать шаблон функции.

```cpp
template<typename T>
T Sqr(T a)
{
	return a * a;
}

int main(){
	int a = 5;
	double d = 6.0;
	auto i = Sqr(a);
	auto g = Sqr(d);
}
```

# Указание шаблонного параметра
```cpp
template<typename T>
T max(T a, T b) { 
	if (b < a) 
		return a; 
	return b; 
int main () { 
	cout << ::max(2, 3.5) << endl;//error 
	return 0; 
}
```

В данном случае компилятор не может сам вывести тип T, поскольку не может выбрать между int и double. В таком случае мы можем сделать либо 2 шаблонных параметра, либо указать желаемый тип.

```cpp
int main () { 
	cout << ::max<int>(2, 3.5) << endl; //3, используем глобальный скоуп :: поскольку в стандартной библиотеке уже есть функция max
	cout << ::max<double>(2, 3.5) << endl; //3.5
	return 0; 
}
```

Создание типа из шаблона класса называется инстанцированием, результатом является экземпляр шаблона.

# По значению или по ссылке
Передавая по ссылке пользовательские типы мы избавляемся от ненужного копирования, то у передаче по значению есть свои преимущества:
1. Лучшая оптимизация кода компилятором
2. Использование семантики перемещения
3. Нет возможно передачи строковых литераторов, только по const ref


# constexpr
```cpp
template<typename T1, typename T2>
constexpr auto max (T1 a, T2 b)
{
	return b < a ? a : b;
}

std::array<std::string, ::max(sizeof(char), 1OOOu)> arr;
```



