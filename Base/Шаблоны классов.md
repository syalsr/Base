# Шаблоны классов
Допустим мы хотим создать собственную пару как в стандартной библиотеке, чтобы она была универсальна, можем, как и в случае с функциями использовать шаблон класса

```cpp
template<class F, class S>
class Pair
{
public:
	Pair() : first({}), second({}) {}
	Pair(F first_, S second_) : first(first_), second(second_) {}
	Pair(Pair<F, S>& other);
	F first;
	S second;
};

template<class F, class S>
Pair<F, S>::Pair(Pair<F, S>& other)
{
	first = other.first;
	second = other.second;
}

int main()
{
	Pair p(2, 3.9);
	p.first = 4;
	Pair ps(2, "fd");
	ps.second = "sd";
}
//Pair - шаблон класса, Pair<int, double> - это уже класс, самостоятельный тип
```

Создание типа из шаблона класса(порождение специализации) называется инстанцированием, инстанцирование методов происходит только при их вызове.



# Вывод типов в шаблонах классов
Первый способ - написать порождающую функцию

```cpp
vector<int> makevector(...){ return { };}
vector<int> v {..};
auto myvector = makevector(v.begin(), next(v.begin(), 5));
```

Начиная с C++17 можно выводить тип с помощью конструктора

```cpp
template<class T>
struct Widget{
	Widget(T value);
};

Widget wint(5); //компилятор ищет нужны конструктор T value = 5; и понимает, что 5 это int, получается Widget<int> wint(5);
```

Если нужно инстанцировать шаблон разными контейнерами

```cpp
template<class Container>
IteratorRange<Container::iterator> Head(Container v, size_t top) {
	return IteratorRange { v.begin (), next(v.begin (), min(top , v.size ())) };
}
```

Может случиться так, что нам передадут const Container, который соответственно будет иметь const_iterator т данный код не будет подходить, поскольку функция короткая, можем изменить тип функции на auto и компилятор будет выводить тип из return.

```cpp
template<class Container>
auto Head(Container v, size_t top) {
	return IteratorRange { v.begin (), next(v.begin (), min(top , v.size ())) 
	};
}
```

Использовать auto в качестве результата функции стоит если:
1. тип результата громоздкий
2. тело функции короткое

При выводе как и с auto срезаются const и ref

```cpp
template <typename T>  
T max(T x, T y) { return x > y ? x : y; }  
const int &b = 1, &c = 2;  
a = max(b, c); // → template<> int max<int>(int, int)  
//Это сделано чтобы уменьшить число неоднозначностей  
int e = 2; int &d = e; // вроде разные типы, но вывод работает  
a = max(d, e); // → template<> int max<int>(int, int)

//поэтому нужно уточнять типы левой ссылкой или указателем
template void foo(T& x);
const int x = 42; 
foo(x); // → template<> void foo(const int& x)
template void bar(const T x);
bar(x); // → template<> void bar(int x)
```

# Шаблоны классов и друзья

```cpp
template<class F, class S>
class Pair;

template<class F, class S>
std::ostream& operator<<(std::ostream& os, const Pair<F, S>& rhs);

template<class F, class S>
class Pair
{
public:
	Pair() : first_{}, second_{} {}
	Pair(F first, S second) : first_(first), second_(second) {}

	template<typename F1, typename S1>  
	Pair<F, S>& operator=(Pair<F1, S1> const& f);  
  
	template<typename F1, typename S1>  
	friend class Pair;

	friend std::ostream& operator<< <F, S> (std::ostream& os, const Pair<F, S>& rhs);//обязательно нужно указать типы в угловых скобках иначе это получится не дружественная функцияб новый член класса

private:
	F first_;
	S second_;
};

template<class F, class S>//сначала для класса
template<typename F1, typename S1>  //потом для метода
Pair<F, S>& operator=(Pair<F1, S1> const& f);  
	{  
	    first_ = f.first_;  
	    second_ = f.second_;  
	}

template<class F, class S>
std::ostream& operator<<(std::ostream& os, const Pair<F, S>& rhs)
{
	os << rhs.first_ << " " << rhs.second_;
	return os;
}

int main()
{
	Pair<int, int> p;
	cout << p;//0 0

	Pair<int, int> pp{3,2};  
	Pair<int, int> ppp;  
	Pair<double, double> pp1;  
	pp1 = pp;//если бы мы не сделали другой тип класса отличный от Pair<F, S> дружественным, 
	//то нам мы не были доступны привтные члены, была бы ошибка  
	ppp = pp;//одинаковые типы, все хорошо даже без friend
}
```

# Упрощение имен
```cpp
template<typename T> class A { 
	A* a1; // A здесь означает A<T> 
};

template<typename T> class A<T*> { 
	A* a2; // A здесь означает A<T*>, то есть у нас указатель на указатель 
};
```
Это работает только внутри классов, для понятности кода так не стоит писать, особенно с частичной специализацией.
# Аргументы шаблона класса по умолчанию
```cpp
template<typename T, typename Container = std::vector<T>>  
class Pair{  
private:  
    Container first, second;  
public:  
    void test();  
};  
  
template<typename T, typename Container>  
void Pair<T, Container>::test()  
{}  
  
int main()  
{  
    Pair<double> pd;  
    Pair<int, std::array<int, 10>> pa{};  
}
```

# Aliases
```cpp
typedef Pair<double> Double_Pair;
void foo(Double_Pair& dp);

using Double_Pair = Pair<double>;
void foo(Double_Pair& pd);
```

## aliase template
```cpp
template<typename T>
using Pair_Vector_T = Pair<T, std::vector<T>>;

template<typename T>  
void foo(Pair_Vector_T<T>& pv);
```

## Суффиксы `_t, _v`
Стандартная библиотека использует using декларацию для определения всех свойств типов

```cpp
typename std::add_const<T>::type // since C++11
std::is_same<decltype(size1), decltype(size2)>::value;
std::is_const<T>::value // since C++11
namespace std {
	template<typename T> 
	using add_const_t = typename add_const<T>::type;//since C++14
	
	std::is_same_v<decltype(size1), decltype(size2)>//since C++17

	template<typename T> 
	constexpr bool is_const_v = is_const<T>::value; // since C++17
}
```

# Вывод аргументов шаблона класса
До C++17 нужны было указывать все типы шаблона, кроме типов по умолчанию.
```cpp
vector<int> v{1,2,3};//before C++17
vector v{1,2,3};//since C++17
```

## Вывод аргументов шаблона класса с использованием строковых литералов
При передаче строкового литерала по значению, он преобразуется в const char*, при передаче по ссылке, он преобразуется в cont char[size], т.е. тип T будет иметь фиксированный размер и мы никак не сможем его изменить.

## Определение правила вывода
Можно сделать правила, при котором при передаче строки в стиле C, создает класса std::string

```cpp
MyClass(const char*) -> MyClass<std::string>;//обычно его пишут сразу после определения класса
```
Либо такой пример

```cpp
template<typename T> struct container {  
    template<typename Iter> container(Iter beg, Iter end);  
// и так далее  
};  
// пользовательский хинт для вывода  
template<typename Iter> container(Iter b, Iter e) ->  
	container<typename iterator_traits<Iter>::value_type>;  
std::vector<double> v;  
auto d = container(v.begin(), v.end()); // → container<double>
```



# Частичная специализация методов
```cpp
class BoolString {  
private:  
    std::string value;  
public:  
    BoolString (std::string const& s)  
            : value(s)  
    {}  
  
    template<typename T = std::string>  
    T get() const { // get value (converted to T)  
        return value;  
    }  
};  
  
template<>  
inline bool BoolString::get<bool>() const {  
    return value == "true" || value == "1" || value == "on";  
}  
  
int main()  
{  
    std::cout << std::boolalpha;  
    BoolString s1("hello");  
    std::cout << s1.get() << '\n'; // prints hello  
    std::cout << s1.get<bool>() << '\n'; // prints false  
    BoolString s2("on");  
    std::cout << s2.get<bool>() << '\n'; // prints true  
}
```

```cpp
template <typename T> struct Foo {  
    template <typename U> void foo() { .... }  
};  
template <>  
template <>  
void Foo<int>::foo<int>() { .... }
```

# Шаблонные параметры шаблонов
Было бы полезно иметь возможность использовать шаблон класса в качестве параметра шаблона.

```cpp
{
	template<typename T, typename Cont = std::deque<T>>  
	class Stack;

	Stack<int, std::vector<int>> vStack;//вынуждены писать 2 раза один и тот же тип
}
{
	template<typename T, template<typename Elem> typename Cont = std::deque>
	class Stack;

	Stack<int, std::vector> vStack;
}
```

Отличие заключается в том, что второй параметр шаблона объявляется как шаблон класса

```cpp
template<typename Elem> class Cont
```



# Шаблонные методы и инкапсуляция
Публичные шаблонные методы убирают инкапсуляцию, т.к. мы можем сделать специализацию класса и получить доступ к приватным данным

```cpp
class Foo {  
    int donottouch_ = 42;  
  
public:  
    template <typename T> 
    void foo() {  
        std::cout << donottouch_ << std::endl;  
    }  
};  
  
struct MyTag {};  
  
template <>  
void Foo::foo<MyTag>() {  
    donottouch_ = 14;  
}  
  
int main() {  
    Foo f;  
    f.foo<MyTag>(); // change private data  
    f.foo<int>();  
}
```