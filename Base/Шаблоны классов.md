# Шаблоны классов
Допустим мы хотим создать собственную пару как в стандартной библиотеке, чтобы она была универсальна, можем, как и в случае с функциями использовать шаблон класса

```cpp
template<class F, class S>
class Pair
{
public:
	Pair() : first({}), second({}) {}
	Pair(F first_, S second_) : first(first_), second(second_) {}
	Pair(Pair<F, S>& other);
	F first;
	S second;
};

template<class F, class S>
Pair<F, S>::Pair(Pair<F, S>& other)
{
	first = other.first;
	second = other.second;
}

int main()
{
	Pair p(2, 3.9);
	p.first = 4;
	Pair ps(2, "fd");
	ps.second = "sd";
}
//Pair - шаблон класса, Pair<int, double> - это уже класс, самостоятельный тип
```

Создание типа из шаблона класса(порождение специализации) называется инстанцированием, инстанцирование методов происходит только при их вызове.

# Явное инстанцирование всех методов
```cpp
template <int N> struct Danger {  
    typedef char block[N];  
};  
  
template <typename T, int N> struct Tricky {  
    void test_lazyness() {  
        Danger<N> no_boom_yet;  
    }  
};  
  
template struct Tricky<int, -2>;//явно инстанцируем шаблон и все его методы без их вызова  
  
int main() {  
    Tricky<int, -5> v;//ошибки нет  
    v.test_lazyness();//ошибка есть  
}
```

Также можно компилятору сказать, что класс уже где-то инстанцирован, не делай этого здесь. Почему полезно? Чтобы в каждом классе не инстанцировалась одна и та же функция, код не раздувается.

```cpp
test1.cpp
#include "maxx.h"  
  
int foo(int x, int y)  
{  
    return maxx(x,y);  
}
```
```cpp
test2.cpp
#include "maxx.h"  
  
int bar(int x, int y)  
{  
    return maxx(x,y);  
}
```
```cpp
maxx.h
#pragma once  
  
template<typename T>  
T maxx(T x, T y)  
{  
    return x + y;  
}  
  
//везде блокируем инстанцирование для int шаблона функции maxx, где включаем этот файл
extern template int maxx<int>(int, int);
```
```cpp
maxx.cpp
#include "maxx.h"  
  
//указываем без extern, говорим компилятору, чтобы он инстанцировал его здесь  
template int maxx<int>(int, int);
```

Без использования функция будет инстацироваться дважыд
```asm
  
test1.o:     file format elf64-x86-64  
  
  
Disassembly of section .text:  
  
0000000000000000 <_Z3fooii>:  
   0:  f3 0f 1e fa            endbr64   
   4:  55                     push   %rbp  
   5:  48 89 e5               mov    %rsp,%rbp  
   8:  48 83 ec 10            sub    $0x10,%rsp  
   c:  89 7d fc               mov    %edi,-0x4(%rbp)  
   f:  89 75 f8               mov    %esi,-0x8(%rbp)  
  12:  8b 55 f8               mov    -0x8(%rbp),%edx  
  15:  8b 45 fc               mov    -0x4(%rbp),%eax  
  18:  89 d6                  mov    %edx,%esi  
  1a:  89 c7                  mov    %eax,%edi  
  1c:  e8 00 00 00 00         callq  21 <_Z3fooii+0x21>  
  21:  c9                     leaveq   
  22:  c3                     retq     
  
Disassembly of section .text._Z4maxxIiET_S0_S0_:  
  
0000000000000000 <_Z4maxxIiET_S0_S0_>:  
   0:  f3 0f 1e fa            endbr64   
   4:  55                     push   %rbp  
   5:  48 89 e5               mov    %rsp,%rbp  
   8:  89 7d fc               mov    %edi,-0x4(%rbp)  
   b:  89 75 f8               mov    %esi,-0x8(%rbp)  
   e:  8b 55 fc               mov    -0x4(%rbp),%edx  
  11:  8b 45 f8               mov    -0x8(%rbp),%eax  
  14:  01 d0                  add    %edx,%eax  
  16:  5d                     pop    %rbp  
  17:  c3                     retq

  
test2.o:     file format elf64-x86-64  
  
  
Disassembly of section .text:  
  
0000000000000000 <_Z3barii>:  
   0:  f3 0f 1e fa            endbr64   
   4:  55                     push   %rbp  
   5:  48 89 e5               mov    %rsp,%rbp  
   8:  48 83 ec 10            sub    $0x10,%rsp  
   c:  89 7d fc               mov    %edi,-0x4(%rbp)  
   f:  89 75 f8               mov    %esi,-0x8(%rbp)  
  12:  8b 55 f8               mov    -0x8(%rbp),%edx  
  15:  8b 45 fc               mov    -0x4(%rbp),%eax  
  18:  89 d6                  mov    %edx,%esi  
  1a:  89 c7                  mov    %eax,%edi  
  1c:  e8 00 00 00 00         callq  21 <_Z3barii+0x21>  
  21:  c9                     leaveq   
  22:  c3                     retq     
  
Disassembly of section .text._Z4maxxIiET_S0_S0_:  
  
0000000000000000 <_Z4maxxIiET_S0_S0_>:  
   0:  f3 0f 1e fa            endbr64   
   4:  55                     push   %rbp  
   5:  48 89 e5               mov    %rsp,%rbp  
   8:  89 7d fc               mov    %edi,-0x4(%rbp)  
   b:  89 75 f8               mov    %esi,-0x8(%rbp)  
   e:  8b 55 fc               mov    -0x4(%rbp),%edx  
  11:  8b 45 f8               mov    -0x8(%rbp),%eax  
  14:  01 d0                  add    %edx,%eax  
  16:  5d                     pop    %rbp  
  17:  c3                     retq
```

С использованием
```nasm
test1.o:     file format elf64-x86-64  
  
  
Disassembly of section .text:  
  
0000000000000000 <_Z3fooii>:  
   0:  f3 0f 1e fa            endbr64   
   4:  55                     push   %rbp  
   5:  48 89 e5               mov    %rsp,%rbp  
   8:  48 83 ec 10            sub    $0x10,%rsp  
   c:  89 7d fc               mov    %edi,-0x4(%rbp)  
   f:  89 75 f8               mov    %esi,-0x8(%rbp)  
  12:  8b 55 f8               mov    -0x8(%rbp),%edx  
  15:  8b 45 fc               mov    -0x4(%rbp),%eax  
  18:  89 d6                  mov    %edx,%esi  
  1a:  89 c7                  mov    %eax,%edi  
  1c:  e8 00 00 00 00         callq  21 <_Z3fooii+0x21>  
  21:  c9                     leaveq   
  22:  c3                     retq


test2.o:     file format elf64-x86-64  
  
  
Disassembly of section .text:  
  
0000000000000000 <_Z3barii>:  
   0:  f3 0f 1e fa            endbr64   
   4:  55                     push   %rbp  
   5:  48 89 e5               mov    %rsp,%rbp  
   8:  48 83 ec 10            sub    $0x10,%rsp  
   c:  89 7d fc               mov    %edi,-0x4(%rbp)  
   f:  89 75 f8               mov    %esi,-0x8(%rbp)  
  12:  8b 55 f8               mov    -0x8(%rbp),%edx  
  15:  8b 45 fc               mov    -0x4(%rbp),%eax  
  18:  89 d6                  mov    %edx,%esi  
  1a:  89 c7                  mov    %eax,%edi  
  1c:  e8 00 00 00 00         callq  21 <_Z3barii+0x21>  
  21:  c9                     leaveq   
  22:  c3                     retq

  
maxx.o:     file format elf64-x86-64  
  
  
Disassembly of section .text._Z4maxxIiET_S0_S0_:  
  
0000000000000000 <_Z4maxxIiET_S0_S0_>:  
   0:  f3 0f 1e fa            endbr64   
   4:  55                     push   %rbp  
   5:  48 89 e5               mov    %rsp,%rbp  
   8:  89 7d fc               mov    %edi,-0x4(%rbp)  
   b:  89 75 f8               mov    %esi,-0x8(%rbp)  
   e:  8b 55 fc               mov    -0x4(%rbp),%edx  
  11:  8b 45 f8               mov    -0x8(%rbp),%eax  
  14:  01 d0                  add    %edx,%eax  
  16:  5d                     pop    %rbp  
  17:  c3                     retq
```

Но этого обычно не стоит делать

# Вывод типов в шаблонах классов
Первый способ - написать порождающую функцию

```cpp
vector<int> makevector(...){ return { };}
vector<int> v {..};
auto myvector = makevector(v.begin(), next(v.begin(), 5));
```

Начиная с C++17 можно выводить тип с помощью конструктора

```cpp
template<class T>
struct Widget{
	Widget(T value);
};

Widget wint(5); //компилятор ищет нужны конструктор T value = 5; и понимает, что 5 это int, получается Widget<int> wint(5);
```

Если нужно инстанцировать шаблон разными контейнерами

```cpp
template<class Container>
IteratorRange<Container::iterator> Head(Container v, size_t top) {
	return IteratorRange { v.begin (), next(v.begin (), min(top , v.size ())) };
}
```

Может случиться так, что нам передадут const Container, который соответственно будет иметь const_iterator т данный код не будет подходить, поскольку функция короткая, можем изменить тип функции на auto и компилятор будет выводить тип из return.

```cpp
template<class Container>
auto Head(Container v, size_t top) {
	return IteratorRange { v.begin (), next(v.begin (), min(top , v.size ())) 
	};
}
```

Использовать auto в качестве результата функции стоит если:
1. тип результата громоздкий
2. тело функции короткое

При выводе как и с auto срезаются const и ref

```cpp
template <typename T>  
T max(T x, T y) { return x > y ? x : y; }  
const int &b = 1, &c = 2;  
a = max(b, c); // → template<> int max<int>(int, int)  
//Это сделано чтобы уменьшить число неоднозначностей  
int e = 2; int &d = e; // вроде разные типы, но вывод работает  
a = max(d, e); // → template<> int max<int>(int, int)

//поэтому нужно уточнять типы левой ссылкой или указателем
template void foo(T& x);
const int x = 42; 
foo(x); // → template<> void foo(const int& x)
template void bar(const T x);
bar(x); // → template<> void bar(int x)
```

# Шаблоны классов и друзья

```cpp
template<class F, class S>
class Pair;

template<class F, class S>
std::ostream& operator<<(std::ostream& os, const Pair<F, S>& rhs);

template<class F, class S>
class Pair
{
public:
	Pair() : first_{}, second_{} {}
	Pair(F first, S second) : first_(first), second_(second) {}

	template<typename F1, typename S1>  
	Pair<F, S>& operator=(Pair<F1, S1> const& f);  
  
	template<typename F1, typename S1>  
	friend class Pair;

	friend std::ostream& operator<< <F, S> (std::ostream& os, const Pair<F, S>& rhs);//обязательно нужно указать типы в угловых скобках иначе это получится не дружественная функцияб новый член класса

private:
	F first_;
	S second_;
};

template<class F, class S>//сначала для класса
template<typename F1, typename S1>  //потом для метода
Pair<F, S>& operator=(Pair<F1, S1> const& f);  
	{  
	    first_ = f.first_;  
	    second_ = f.second_;  
	}

template<class F, class S>
std::ostream& operator<<(std::ostream& os, const Pair<F, S>& rhs)
{
	os << rhs.first_ << " " << rhs.second_;
	return os;
}

int main()
{
	Pair<int, int> p;
	cout << p;//0 0

	Pair<int, int> pp{3,2};  
	Pair<int, int> ppp;  
	Pair<double, double> pp1;  
	pp1 = pp;//если бы мы не сделали другой тип класса отличный от Pair<F, S> дружественным, 
	//то нам мы не были доступны привтные члены, была бы ошибка  
	ppp = pp;//одинаковые типы, все хорошо даже без friend
}
```

# Специализация шаблонов класса
Шаблон класса можно специализировать для конкретных аргументов шаблона, при специализации шаблона класса, нужно специализировать все его методы, данные могут отличаться.

```cpp
temaplte<class T>
class templ
{
	public:
		void Test();
};

void temp<T>::Test(){}

template<>
class templ<string>//специализация c параметром string
{
	public:
		void Test();
};
void templ<string>::Test(){}
```

```cpp
template<typename T>  
struct MyClass; // primary template  
template<typename T, std::size_t SZ>  
struct MyClass<T[SZ]> // partial specialization for arrays of known bounds  
{  
    static void print() { std::cout << "print() for T[" << SZ << "]\n"; }  
};  
template<typename T, std::size_t SZ>  
struct MyClass<T(&)[SZ]> // partial spec. for references to arrays of known bounds  
{  
    static void print() { std::cout << "print() for T(&)[" << SZ << "]\n"; }  
};  
template<typename T>  
struct MyClass<T[]> // partial specialization for arrays of unknown bounds  
{  
    static void print() { std::cout << "print() for T[]\n"; }  
};  
template<typename T>  
struct MyClass<T(&)[]> // partial spec. for references to arrays of unknown bounds  
{  
    static void print() { std::cout << "print() for T(&)[]\n"; }  
};  
template<typename T>  
struct MyClass<T*> // partial specialization for pointers  
{  
    static void print() { std::cout << "print() for T*\n"; }  
};  
template<typename T1, typename T2, typename T3>  
void foo(int a1[7], int a2[], // pointers by language rules  
         int (&a3)[42], // reference to array of known bound  
         int (&x0)[], // reference to array of unknown bound  
         T1 x1, // passing by value decays  
         T2& x2, T3&& x3) // passing by reference  
{  
    MyClass<decltype(a1)>::print(); // uses MyClass<T*>  
    MyClass<decltype(a2)>::print(); // uses MyClass<T*>  
    MyClass<decltype(a3)>::print(); // uses MyClass<T(&)[SZ]>  
    MyClass<decltype(x0)>::print(); // uses MyClass<T(&)[]>  
    MyClass<decltype(x1)>::print(); // uses MyClass<T*>  
    MyClass<decltype(x2)>::print(); // uses MyClass<T(&)[]>  
    MyClass<decltype(x3)>::print(); // uses MyClass<T(&)[]>  
}  
int main()  
{  
    int a[42];  
    MyClass<decltype(a)>::print(); // uses MyClass<T[SZ]>  
    extern int x[]; // forward declare array  
    MyClass<decltype(x)>::print(); // uses MyClass<T[]>  
    foo(a, a, a, x, x, x, x);  
}  
int x[] = {0, 8, 15}; // define forward-declared array
/*
print() for T[42]
print() for T[]
print() for T*
print() for T*
print() for T(&)[42]
print() for T(&)[]
print() for T*
print() for T(&)[]
print() for T(&)[]
*/
```

Полезно оставлять шаблон класса пустым и делать к нему специализацию, чтобы нельзя было использовать его с нежелательным типом.

```cpp
template<typename T> struct RequestHandler{};

template<> struct RequestHandler<MyTYpe>{ smth method };
template<> struct RequestHandler<OtherType>{smth method};
```

Если использовать специализацию до ее объявления, то компилятор ее не увидит, инстанцирует на основе вашего шаблона и произодйет двойное определение, то что породил компилятор,  и то что сделали вы.

```cpp
template<typename T> T max(T x, T y)
{}

template<> double max<double>(double x, double y)
{}
void test()
{
	max<int> f(3,2);
}
template<> int max<int>(int x, int y)
{}
```

Можно также запрещать специализацию

```cpp
template<typename T> T max(T x, T y)
{}

template<> double max<double>(double x, double y)=delete;
```

Специализация не является разновидностью наследования, т.к. при помощи нее мы можем полностью изменить интерфейс, принцип [[10 Design#L SP – Liskov substitution principle|Лискова]] не выполняется.
# Частичная специализация шаблонов класса
```cpp
temaplte<class T>
class templ
{
	public:
		void Test();
};

void temp<T>::Test(){}

template<typename T>
class templ<T*>//специализация для указателей
{
	public:
		void Test();
};
temaplte<typename T>
void templ<T*>::Test(){}
```

## Частичная специализация с несколькими параметрами
```cpp
template<class T1, class T2>
class MyClass
{

};

template<class T>
class MyClass<T, T>{}

template<class T>
class MyClass<T, int>{}

template<class T1, class T2>
class MyClass<T1*, T2*>{}

MyClass<int,float> mif;   // MyClass<T1,T2>
MyClass<float,float> mff; // MyClass<T,T>
MyClass<float,int> mfi;   // MyClass<T,int>
MyClass<int*,float*> mp;  // MyClass<T1*,T2*>

MyClass<int,int> m; // ERROR: matches MyClass<T,T> and MyClass<T,int>
MyClass<int*,int*> m; // ERROR: matches MyClass<T,T> and MyClass<T1*,T2*>, нужно создавать специализацию с указателями MyClass<T*, T*>
```

# Упрощение имен
```cpp
template class A { 
	A* a1; // A здесь означает A<T> 
};

template class A { 
	A* a2; // A здесь означает A<T*>, то есть у нас указатель на указатель 
};
```
Это работает только внутри классов, для понятности кода так не стоит писать, особенно с частичной специализацией.
# Аргументы шаблона класса по умолчанию
```cpp
template<typename T, typename Container = std::vector<T>>  
class Pair{  
private:  
    Container first, second;  
public:  
    void test();  
};  
  
template<typename T, typename Container>  
void Pair<T, Container>::test()  
{}  
  
int main()  
{  
    Pair<double> pd;  
    Pair<int, std::array<int, 10>> pa{};  
}
```

# Aliases
```cpp
typedef Pair<double> Double_Pair;
void foo(Double_Pair& dp);

using Double_Pair = Pair<double>;
void foo(Double_Pair& pd);
```

## aliase template
```cpp
template<typename T>
using Pair_Vector_T = Pair<T, std::vector<T>>;

template<typename T>  
void foo(Pair_Vector_T<T>& pv);
```

## Суффиксы `_t, _v`
Стандартная библиотека использует using декларацию для определения всех свойств типов

```cpp
typename std::add_const<T>::type // since C++11
std::is_same<decltype(size1), decltype(size2)>::value;
std::is_const<T>::value // since C++11
namespace std {
	template<typename T> 
	using add_const_t = typename add_const<T>::type;//since C++14
	
	std::is_same_v<decltype(size1), decltype(size2)>//since C++17

	template<typename T> 
	constexpr bool is_const_v = is_const<T>::value; // since C++17
}
```

# Вывод аргументов шаблона класса
До C++17 нужны было указывать все типы шаблона, кроме типов по умолчанию.
```cpp
vector<int> v{1,2,3};//before C++17
vector v{1,2,3};//since C++17
```

## Вывод аргументов шаблона класса с использованием строковых литералов
При передаче строкового литерала по значению, он преобразуется в const char*, при передаче по ссылке, он преобразуется в cont char[size], т.е. тип T будет иметь фиксированный размер и мы никак не сможем его изменить.

## Определение правила вывода
Можно сделать правила, при котором при передаче строки в стиле C, создает класса std::string

```cpp
MyClass(const char*) -> MyClass<std::string>;//обычно его пишут сразу после определения класса
```
Либо такой пример

```cpp
template<typename T> struct container {  
    template<typename Iter> container(Iter beg, Iter end);  
// и так далее  
};  
// пользовательский хинт для вывода  
template<typename Iter> container(Iter b, Iter e) ->  
	container<typename iterator_traits<Iter>::value_type>;  
std::vector<double> v;  
auto d = container(v.begin(), v.end()); // → container<double>
```

# Параметры шаблонов классов, не являющиеся типами
```cpp
namespace my {  
    template<typename T, std::size_t size>  
    class array {  
    public:  
        array()=default;  
        T& operator[](T i)  
        {  
            return data[i];  
        }  
    private:  
        T data[size];  
    };  
}  
  
int main()  
{  
    my::array<int, 10> arr;  
    arr[5]=2;  
    arr[9]=1;
    my::array<int, 100> arr1;
    //arr и arr1 два разных типа явное/неявное преобразование одного в другое не определеено 
}
```

# Частичная специализация методов
```cpp
class BoolString {  
private:  
    std::string value;  
public:  
    BoolString (std::string const& s)  
            : value(s)  
    {}  
  
    template<typename T = std::string>  
    T get() const { // get value (converted to T)  
        return value;  
    }  
};  
  
template<>  
inline bool BoolString::get<bool>() const {  
    return value == "true" || value == "1" || value == "on";  
}  
  
int main()  
{  
    std::cout << std::boolalpha;  
    BoolString s1("hello");  
    std::cout << s1.get() << '\n'; // prints hello  
    std::cout << s1.get<bool>() << '\n'; // prints false  
    BoolString s2("on");  
    std::cout << s2.get<bool>() << '\n'; // prints true  
}
```

```cpp
template <typename T> struct Foo {  
    template <typename U> void foo() { .... }  
};  
template <>  
template <>  
void Foo<int>::foo<int>() { .... }
```

# Шаблонные параметры шаблонов
Было бы полезно иметь возможность использовать шаблон класса в качестве параметра шаблона.

```cpp
{
	template<typename T, typename Cont = std::deque<T>>  
	class Stack;

	Stack<int, std::vector<int>> vStack;//вынуждены писать 2 раза один и тот же тип
}
{
	template<typename T, template<typename Elem> typename Cont = std::deque>
	class Stack;

	Stack<int, std::vector> vStack;
}
```

Отличие заключается в том, что второй параметр шаблона объявляется как шаблон класса

```cpp
template<typename Elem> class Cont
```

# Разрешения имен
## Зачем нужен typename
```cpp
struct S {  
    struct subtype {};  
};  
template <typename T> int foo(const T& x) {  
    T::subtype *y;  //здесь умножение
    typename T::subtype *y;//теперь тип
// и так далее  
}  
foo<S>(S{}); // казалось бы всё хорошо?
```

## Конструкция .template
Эта конструкция нужна, чтобы указать компилятору, что $<$ - это не оператор меньше, а начала параметров шаблона.
```cpp
template<unsigned long N>
void printBitset (std::bitset<N> const& bs) {
	std::cout << bs.template to_string<char, std::char_traits<char>, std::allocator<char>>();
}
```

Эта конструкция имеет смысл только если метод после точки зависит от параметра шаблона

```cpp
template<typename T> struct S {  
    template<typename U> void foo(){}  
};  
template<typename T> void bar() {  
    S<T> s; 
    s.foo<T>();//опять знак меньше
    s.template Foo<T>();  
}
```

# Шаблонные методы и инкапсуляция
Публичные шаблонные методы убирают инкапсуляцию, т.к. мы можем сделать специализацию класса и получить доступ к приватным данным

```cpp
class Foo {  
    int donottouch_ = 42;  
  
public:  
    template <typename T> 
    void foo() {  
        std::cout << donottouch_ << std::endl;  
    }  
};  
  
struct MyTag {};  
  
template <>  
void Foo::foo<MyTag>() {  
    donottouch_ = 14;  
}  
  
int main() {  
    Foo f;  
    f.foo<MyTag>(); // change private data  
    f.foo<int>();  
}
```