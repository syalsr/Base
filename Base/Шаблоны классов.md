---
aliases:
tags: C++11, C++17
---

# Шаблоны классов
Допустим мы хотим создать собственную пару как в стандартной библиотеке, чтобы она была универсальна, можем, как и в случае с функциями использовать шаблон класса

```cpp
template<class F, class S>
class Pair
{
public:
	Pair() : first({}), second({}) {}
	Pair(F first_, S second_) : first(first_), second(second_) {}
	F first;
	S second
}
int main()
{
	Pair p(2, 3.9);
	p.first = 4;
	Pair ps(2, "fd");
	ps.second = "sd";
}
//Pair - шаблон класса, Pair<int, double> - это уже класс, самостоятельный тип
```

Создание типа из шаблона класса называется инстанцированием.

# Вывод типов в шаблонах классов
Первый способ - написать порождающую функцию

```cpp
vector<int> makevector(...){ return { };}
vector<int> v {..};
auto myvector = makevector(v.begin(), next(v.begin(), 5));
```

Начиная с C++17 можно выводить тип с помощью конструктора

```cpp
template<class T>
struct Widget{
	Widget(T value);
};

Widget wint(5); //компилятор ищет нужны конструктор T value = 5; и понимает, что 5 это int, получается Widget<int> wint(5);
```

Если нужно инстанцировать шаблон разными контейнерами

```cpp
template<class Container>
IteratorRange<Container::iterator> Head(Container v, size_t top) {
	return IteratorRange { v.begin (), next(v.begin (), min(top , v.size ())) 
	};
}
```

Может случиться так, что нам передадут const Conatainer, который соответственно будет иметь const_iterator т данный код не будет подходить, поскольку функция короткая, можем изменить тип функции на auto и компилятор будет выводить тип из return.

```cpp
template<class Container>
auto Head(Container v, size_t top) {
	return IteratorRange { v.begin (), next(v.begin (), min(top , v.size ())) 
	};
}
```

Использовать auto в качестве результата функции стоит если:
1. тип результата громоздкий
2. тело функции короткое