# Шаблоны классов
Допустим мы хотим создать собственную пару как в стандартной библиотеке, чтобы она была универсальна, можем, как и в случае с функциями использовать шаблон класса

```cpp
template<class F, class S>
class Pair
{
public:
	Pair() : first({}), second({}) {}
	Pair(F first_, S second_) : first(first_), second(second_) {}
	Pair(Pair<F, S>& other);
	F first;
	S second;
};

template<class F, class S>
Pair<F, S>::Pair(Pair<F, S>& other)
{
	first = other.first;
	second = other.second;
}

int main()
{
	Pair p(2, 3.9);
	p.first = 4;
	Pair ps(2, "fd");
	ps.second = "sd";
}
//Pair - шаблон класса, Pair<int, double> - это уже класс, самостоятельный тип
```

Создание типа из шаблона класса называется инстанцированием, инстанцирование методов происходит только при их вызове.

# Вывод типов в шаблонах классов
Первый способ - написать порождающую функцию

```cpp
vector<int> makevector(...){ return { };}
vector<int> v {..};
auto myvector = makevector(v.begin(), next(v.begin(), 5));
```

Начиная с C++17 можно выводить тип с помощью конструктора

```cpp
template<class T>
struct Widget{
	Widget(T value);
};

Widget wint(5); //компилятор ищет нужны конструктор T value = 5; и понимает, что 5 это int, получается Widget<int> wint(5);
```

Если нужно инстанцировать шаблон разными контейнерами

```cpp
template<class Container>
IteratorRange<Container::iterator> Head(Container v, size_t top) {
	return IteratorRange { v.begin (), next(v.begin (), min(top , v.size ())) };
}
```

Может случиться так, что нам передадут const Conatainer, который соответственно будет иметь const_iterator т данный код не будет подходить, поскольку функция короткая, можем изменить тип функции на auto и компилятор будет выводить тип из return.

```cpp
template<class Container>
auto Head(Container v, size_t top) {
	return IteratorRange { v.begin (), next(v.begin (), min(top , v.size ())) 
	};
}
```

Использовать auto в качестве результата функции стоит если:
1. тип результата громоздкий
2. тело функции короткое

# Шаблоны классов и друзья

```cpp
template<class F, class S>
class Pair;

template<class F, class S>
std::ostream& operator<<(std::ostream& os, const Pair<F, S>& rhs);

template<class F, class S>
class Pair
{
public:
	Pair() : first_{}, second_{} {}
	Pair(F first, S second) : first_(first), second_(second) {}

	template<typename F1, typename S1>  
	Pair<F, S>& operator=(Pair<F1, S1> const& f)  
	{  
    first_ = f.first_;  
    second_ = f.second_;  
	}  
  
	template<typename F1, typename S1>  
	friend class Pair;

	friend std::ostream& operator<< <F, S> (std::ostream& os, const Pair<F, S>& rhs);//обязательно нужно указать типы в угловых скобках иначе это получится не дружественная функцияб новый член класса

private:
	F first_;
	S second_;
};
template<class F, class S>
std::ostream& operator<<(std::ostream& os, const Pair<F, S>& rhs)
{
	os << rhs.first_ << " " << rhs.second_;
	return os;
}

int main()
{
	Pair<int, int> p;
	cout << p;//0 0

	Pair<int, int> pp{3,2};  
	Pair<int, int> ppp;  
	Pair<double, double> pp1;  
	pp1 = pp;//если бы мы не сделали другой тип класса отличный от Pair<F, S> дружественным, 
	//то нам мы не были доступны привтные члены, была бы ошибка  
	ppp = pp;//одинаковые типы, все хорошо даже без friend
}
```

# Специализация шаблонов класса
Шаблон класса можно специализировать для конкретных аргументов шаблона, при специализации шаблона класса, нужно специализировать все его методы, данные могут отличаться.

```cpp
temaplte<class T>
class templ
{
	public:
		void Test();
};

void temp<T>::Test(){}

template<>
class templ<string>//специализация c параметром string
{
	public:
		void Test();
};
void templ<string>::Test(){}
```

```cpp
template<typename T>  
struct MyClass; // primary template  
template<typename T, std::size_t SZ>  
struct MyClass<T[SZ]> // partial specialization for arrays of known bounds  
{  
    static void print() { std::cout << "print() for T[" << SZ << "]\n"; }  
};  
template<typename T, std::size_t SZ>  
struct MyClass<T(&)[SZ]> // partial spec. for references to arrays of known bounds  
{  
    static void print() { std::cout << "print() for T(&)[" << SZ << "]\n"; }  
};  
template<typename T>  
struct MyClass<T[]> // partial specialization for arrays of unknown bounds  
{  
    static void print() { std::cout << "print() for T[]\n"; }  
};  
template<typename T>  
struct MyClass<T(&)[]> // partial spec. for references to arrays of unknown bounds  
{  
    static void print() { std::cout << "print() for T(&)[]\n"; }  
};  
template<typename T>  
struct MyClass<T*> // partial specialization for pointers  
{  
    static void print() { std::cout << "print() for T*\n"; }  
};  
template<typename T1, typename T2, typename T3>  
void foo(int a1[7], int a2[], // pointers by language rules  
         int (&a3)[42], // reference to array of known bound  
         int (&x0)[], // reference to array of unknown bound  
         T1 x1, // passing by value decays  
         T2& x2, T3&& x3) // passing by reference  
{  
    MyClass<decltype(a1)>::print(); // uses MyClass<T*>  
    MyClass<decltype(a2)>::print(); // uses MyClass<T*>  
    MyClass<decltype(a3)>::print(); // uses MyClass<T(&)[SZ]>  
    MyClass<decltype(x0)>::print(); // uses MyClass<T(&)[]>  
    MyClass<decltype(x1)>::print(); // uses MyClass<T*>  
    MyClass<decltype(x2)>::print(); // uses MyClass<T(&)[]>  
    MyClass<decltype(x3)>::print(); // uses MyClass<T(&)[]>  
}  
int main()  
{  
    int a[42];  
    MyClass<decltype(a)>::print(); // uses MyClass<T[SZ]>  
    extern int x[]; // forward declare array  
    MyClass<decltype(x)>::print(); // uses MyClass<T[]>  
    foo(a, a, a, x, x, x, x);  
}  
int x[] = {0, 8, 15}; // define forward-declared array
/*
print() for T[42]
print() for T[]
print() for T*
print() for T*
print() for T(&)[42]
print() for T(&)[]
print() for T*
print() for T(&)[]
print() for T(&)[]
*/
```
# Частичная специализация шаблонов класса
```cpp
temaplte<class T>
class templ
{
	public:
		void Test();
};

void temp<T>::Test(){}

template<typename T>
class templ<T*>//специализация для указателей
{
	public:
		void Test();
};
temaplte<typename T>
void templ<T*>::Test(){}
```

## Частичная специализация с несколькими параметрами
```cpp
template<class T1, class T2>
class MyClass
{

};

template<class T>
class MyClass<T, T>{}

template<class T>
class MyClass<T, int>{}

template<class T1, class T2>
class MyClass<T1*, T2*>{}

MyClass<int,float> mif;   // MyClass<T1,T2>
MyClass<float,float> mff; // MyClass<T,T>
MyClass<float,int> mfi;   // MyClass<T,int>
MyClass<int*,float*> mp;  // MyClass<T1*,T2*>

MyClass<int,int> m; // ERROR: matches MyClass<T,T> and MyClass<T,int>
MyClass<int*,int*> m; // ERROR: matches MyClass<T,T> and MyClass<T1*,T2*>, нужно создавать специализацию с указателями MyClass<T*, T*>
```

# Аргументы шаблона класса по умолчанию
```cpp
template<typename T, typename Container = std::vector<T>>  
class Pair{  
private:  
    Container first, second;  
public:  
    void test();  
};  
  
template<typename T, typename Container>  
void Pair<T, Container>::test()  
{}  
  
int main()  
{  
    Pair<double> pd;  
    Pair<int, std::array<int, 10>> pa{};  
}
```

# Aliases
```cpp
typedef Pair<double> Double_Pair;
void foo(Double_Pair& dp);

using Double_Pair = Pair<double>;
void foo(Double_Pair& pd);
```

## aliase template
```cpp
template<typename T>
using Pair_Vector_T = Pair<T, std::vector<T>>;

template<typename T>  
void foo(Pair_Vector_T<T>& pv);
```

## Суффиксы `_t, _v`
Стандартная библиотека использует using декларацию для определения всех свойств типов

```cpp
typename std::add_const<T>::type // since C++11
std::is_same<decltype(size1), decltype(size2)>::value;
std::is_const<T>::value // since C++11
namespace std {
	template<typename T> 
	using add_const_t = typename add_const<T>::type;//since C++14
	
	std::is_same_v<decltype(size1), decltype(size2)>//since C++17

	template<typename T> 
	constexpr bool is_const_v = is_const<T>::value; // since C++17
}
```

# Вывод аргументов шаблона класса
До C++17 нужны было указывать все типы шаблона, кроме типов по умолчанию.
```cpp
vector<int> v{1,2,3};//before C++17
vector v{1,2,3};//since C++17
```

## Вывод аргументов шаблона класса с использованием строковых литералов
При передаче строкового литерала по значению, он преобразуется в const char*, при передаче по ссылке, он преобразуется в cont char[size], т.е. тип T будет иметь фиксированный размер и мы никак не сможем его изменить.

## Определение правила вывода
Можно сделать правила, при котором при передаче строки в стиле C, создает класса std::string

```cpp
MyClass(const char*) -> MyClass<std::string>;//обычно его пишут сразу после определения класса
```

# Параметры шаблонов классов, не являющиеся типами
```cpp
namespace my {  
    template<typename T, std::size_t size>  
    class array {  
    public:  
        array()=default;  
        T& operator[](T i)  
        {  
            return data[i];  
        }  
    private:  
        T data[size];  
    };  
}  
  
int main()  
{  
    my::array<int, 10> arr;  
    arr[5]=2;  
    arr[9]=1;
    my::array<int, 100> arr1;
    //arr и arr1 два разных типа явное/неявное преобразование одного в другое не определеено 
}
```

# Частичная специализация методов
```cpp
class BoolString {  
private:  
    std::string value;  
public:  
    BoolString (std::string const& s)  
            : value(s)  
    {}  
  
    template<typename T = std::string>  
    T get() const { // get value (converted to T)  
        return value;  
    }  
};  
  
template<>  
inline bool BoolString::get<bool>() const {  
    return value == "true" || value == "1" || value == "on";  
}  
  
int main()  
{  
    std::cout << std::boolalpha;  
    BoolString s1("hello");  
    std::cout << s1.get() << '\n'; // prints hello  
    std::cout << s1.get<bool>() << '\n'; // prints false  
    BoolString s2("on");  
    std::cout << s2.get<bool>() << '\n'; // prints true  
}
```

# Шаблонные параметры шаблонов
Было бы полезно иметь возможность использовать шаблон класса в качестве параметра шаблона.

```cpp
{
	template<typename T, typename Cont = std::deque<T>>  
	class Stack;

	Stack<int, std::vector<int>> vStack;//вынуждены писать 2 раза один и тот же тип
}
{
	template<typename T, template<typename Elem> typename Cont = std::deque>
	class Stack;

	Stack<int, std::vector> vStack;
}
```

Отличие заключается в том, что второй параметр шаблона объявляется как шаблон класса

```cpp
template<typename Elem> class Cont
```

