# Протокол HTTP
Hypertext Transfer Protocol (HTTP) – протокол передачи язык гипертекстовой разметки страниц HTML, работает на [[Протокол TCP]]

Uniform Resource Locator (URL) – уникальное положение ресурса. Формат URL: 
1. http://www.asozykin.ru/courses/networks
2. https://www.youtube.com/
3. ftp://example.com

# Структура пакета HTTP
1. Запрос/статус ответа
	1. GET /courses/networks
2. 200 ОК Заголовки (не обязательно)
	1. Host: www.asozykin.ru (обязательно в HTTP 1.1)
	2. Content-Type: text/html; charset=UTF-8
	3. Content-Length: 5161 
3. Тело сообщения (не обязательно) 
	1. Страница HTML 
	2. Параметры, введенные пользователем

# Методы hTTP
1. GET – запрос Web-страницы 
2. POST – передача данных на Web-сервер 
3. HEAD – запрос заголовка страницы 
4. PUT – помещение страницы на Web-сервер 
5. DELETE – удаление страницы с Web-сервера 
6. TRACE – трассировка страницы 
7. OPTIONS – запрос поддерживаемых методов HTTP для ресурса 
8. CONNECT – подключение к Web-серверу через прокси

# Статусы HTTP
1. 1XX – информация 
2. 2XX – успешное выполнение (200 ОК) 
3. 3ХХ – перенаправление (301 – постоянное перемещение, 307 – временное перенаправление) 
4. 4ХХ – Ошибка на стороне клиента (403 – доступ запрещен, 404 – страница не найдена) 
5. 5ХХ – Ошибка сервера (500 – внутренняя ошибка сервера)

# Пример запроса и ответа HTTP
Подключение по TCP к серверу www.asozykin.ru, порт 80 

```
Запрос
GET /courses/networks HTTP/1.1 
Host: www.asozykin.ru

Ответ
HTTP/1.1 200 OK 
Server: nginx 
Content-Type: text/html; 
charset=UTF-8 
Content-Length: 5161

<html lang="ru-RU">
<head>
...
</html>
```

Как это происходит? При использовании постоянного соединения один раз устанавливается TCP соединение, а дальше получаем html, css и другие ресурсы. Для этого нужно указать тип соединения: Connection: keep-alive. Иначе после каждого ответа сервера, соединение будет разрываться и придется каждый раз его устанавливать. В HTTP 1.1 соединения по умолчанию постоянное.

```
GET /courses/networks HTTP/1.0 
Host: www.asozykin.ru 
Connection: keep-alive

HTTP/1.0 200 OK 
Server: nginx 
Content-Type: text/html; 
charset=UTF-8 
Content-Length: 5161 
Connection: keep-alive
```

Если клиент открыл соединение и не использует его, то эти ресурсы недоступны другим клиентам, поэтому серверы автоматически закрывают соединение, если оно не используется 5-15 секунд

# Кэширование
Современные Web-браузеры поддерживают кэширование редко меняющихся ресурсов. Кэширование сокращает время загрузки страницы, но требует место на локальном диске компьютера для кэша. Протокол HTTP поддерживает работу кэша.

Как определить, что страница не изменилась и ее можно брать из кэша? Для этого существует заголовок Expires, который указывает, до какого времени можно хранить ресурс в кэш
```
Expires: Sun, 12 Jun 2016 10:35:18 GMT
```

Либо если Web-сервер не установил заголовок, можно посмотреть последнее ее изменение, если страница долго не менялась, то скорее всего можно загрузить ее из кэша
```
Last-Modified: Wed, 25 May 2016 06:13:24 GMT
```

Также можно отправить веб серверу запрос GET с условием, изменилась ли страница начиная с такой то даты, если да, высылает обновленную.
```
Запрос
If-Modified-Since: Wed, 25 May 2016 06:13:24 GMT

Ответ
Не изменился
Короткое сообщение
Статус ответа: 304 Not Modified
Дополнительные заголовки: Expires, Last-Modified, Cache-Control

Изменился
Полная передача обновленной версии ресурса
Статус ответа: 200 ОК
```

В HTTP 1.1 появился ETag(entity tag) - код, который генерируется на основе содержимого ресурса. Заголовок ETag добавляется к HTTP ответу/ При изменении содержимого ресурса меняется его ETag/
```
ETag: "57454284-3d8f"

Запрос GET
If-None-Match: 57454284-3d8f
```

Также начиная с HTTP 1.1 можно управлять кэшированием
```
Cache-Control: private, max-age=10

no-store • no-cache • public • private • max-age=86400
```

Также данные могут быть закэшированы в [[Прокси сервер]]