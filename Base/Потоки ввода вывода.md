# Ввод и вывод
Большинство современных операционных систем поручают управление устройствами ввода-вывода специализированным драйверам, а затем программы обращаются к ним с помощью средств библиотеки ввода-вывода.
![](cpp_basic10.png)

При использовании такой модели вся входная и выходная информация может рассматриваться как потоки байтов (символов), обрабатываемые средствами библиотеки ввода-вывода.

Наша работа как программистов, создающих приложения, сводится к следующему.

1. Настроить потоки ввода-вывода для получения данных из устройств ввода и вывода данных на устройства вывода.
2. Читать и записывать потоки.

# Модель потока ввода-вывода
Стандартная библиотека языка С++ содержит определение типа `istream` для потоков ввода и типа `ostream` - для потоков вывода.

Поток `ostream` делает следующее:

* Превращает значения разных типов в последовательности символов.
* Посылает эти символы "куда-то" (например. на консоль, в файл, основную память или на другой компьютер) .

![](cpp_basic11.png)

Буфер - это структура данных, которую поток `ostream` использует внутренне для хранения в ходе взаимодействия с операционной системой информации, полученной от вас. Задержка между записью в поток `ostream` и появлением символов в пункте назначения обычно объясняется тем, что эти символы находятся в буфере, сделано это для повышения производительности.

Поток `istream` делает следующее:

* Превращает последовательности символов в значения разных типов.
* Получает эти символы "откуда-то" (например. с консоли, из файла, из основной памяти или от другого компьютера).

![](cpp_basic12.png)

`istream` как и  `ostream` для взаимодействия с операционной системой поток использует буфер. При этом буферизация может оказаться визуально заметной для пользователя. Когда вы используете поток `istream`, связанный с клавиатурой, все, что вы введете, останется в буфере. пока вы не нажмете клавишу `Enter` (возврат каретки/переход на новую строку).

Поток `iostream` делает то же что и `ostream` и `istream`

Потоки имеют текущую позицию - это позиция в которой будет выполняться следующая операция чтения или записи.

Стандартная библиотеки определяет несколько собственных типов потоков:

| stream                 | Описание                                                                                                  |
| ---------------------- | --------------------------------------------------------------------------------------------------------- |
| cin - character in     | Входной поток, читает данные из консоли ввода                                                             |
| cout - character out   | Буферизированный выходной поток, выводит данные в выходную консоль                                        |
| cerr - character error | Небуферизированный выходной поток, выводит данные в консоль ошибок, что обычно является выходной консолью |
| clog - character log   | Буферизированная версия cerr                                                                              |

Разница между буферизированными и небуферизированными в том, что буферизированные не сразу выводят данные, а сохраняют их в своем буфере, как только буфер переполняется, происходит сброс буфера, данные выводятся. 

## Повышение производительности при работе с потоками
Если для перевода строки использовать [[Escape sequence|\n]], вместо `endl` сброс буфера происходить не будет.

```cpp
int main () { 
	{ 
		LOG_DURATION ("endl"); 
		ofstream out("output.txt"); 
		for (int i = 0; i < 15000; ++i) { 
			out << "London is the capital of Great Britain. " << "I am travelling down the river" << endl; 
		} 
	} 
	{ 
		LOG_DURATION ("'\n'"); 
		ofstream out("output2.txt");
		for (int i = 0; i < 15000; ++i) { 
			out << "London is the capital of Great Britain. " << "I am travelling down the river" << '\n'; 
		} 
	} 
} 
// endl: 137 ms 
// '\n': 16 ms
```

В каких случаях происходит сброс буфера?
1. endl
2. Поток выходит из области видимости
3. Буфер переполнен
4. Явный вызов сброса буфера flush()
5. Использование cin после cout, это происходит из-за связи потоков, чтобы ее разорвать в начале программы нужно написать:

```cpp
cin.tie(nullptr);
```

В каких случая использовать endl?
В тех случаях когда нам нужно оперативно получить вывод, иначе может произойти ситуация, когда программа крашится не дойдя до строки, где буфер сбросится и произойдет вывод.

Эта команда позволит ускорить ввод/вывод, ее также нужно написать вначале программы:

```cpp
ios_base::sync_with_stdio(false);
```

Если мы разрабатываем библиотеку, мы не должны использовать `cin,cout,cerr,clog`, т.к. их устройство ввода/вывода - это консоль. Ваша библиотеки может использоваться для разработки GUI приложения в котором не предусмотрено использование консоли.

# Устройства ввода/вывода потоков
1. Консоль - считывает/записывает данные с/на консоль
2. Файл - считывает/записывает данные с/в файл - удобно для сохранения данных после окончания работы программы
3. Строка - работа со строковыми потоками гораздо более удобна,  чем с обычным классов string

# Выходные потоки
С помощью оператора `<<` мы можем выводить в поток все встроенные типы данных, для собственных нужно самим переопределять вывод/ввод в/из поток.

```cpp
int i { 7 };
cout << i << endl;//7

char ch { 'a' };
cout << ch << endl;//a

string myString { "Hello World." };
cout << myString << endl;//Hello World.
```

Поскольку `<<` возвращает ссылку на поток, мы можем использовать использовать их для передачи нескольких строк в поток.

```cpp
int j { 11 };
cout << "The value of j is " << j << "!" << endl;//The value of j is 11!
```

## Методы выходных потоков
1. put() - принимает 1 символ
```cpp
cout.put('a');
```
2. write() - принимает массив символов
```cpp
const char* test { "hello there\n" };
cout.write(test, strlen(test));
```
3. flush() - сбрасывает буфер
```cpp
cout << "abc";
cout.flush(); // abc is written to the console.
cout << "def";
cout << endl; // def is written to the console.
```

## Обработки ошибок вывода
Метод good()/bad()проверяет все ли хорошо/плохо с потоком

```cpp
if (cout.good()) {
	cout << "All good" << endl;
}
```

Метод fail() возвращает true, если последняя операция завершилась неудачей

```cpp
cout.flush();
if (cout.fail()) {
	cerr << "Unable to flush to standard out" << endl;
}
```

Потоки имеют оператор преобразования в тип bool, поэтому можно переписать код выше без метода fail()

```cpp
cout.flush();
if (!cout) {
	cerr << "Unable to flush to standard out" << endl;
}
```

good() и fail() возвращают false, если достигнут конец файла. 
```cpp
good() == (!fail() && !eof())
```

## Выходные манипуляторы
Манипуляторы изменяют поведение потока

1. boolalpha и noboolalpha - говорит компиляторы выводит значения bool, как true/false - boolalphs и 0/1 - noboolalpha. По умолчанию стоит noboolalpha 
```cpp
bool myBool{ true };
cout << myBool << endl;
cout << boolalpha << myBool << endl;
cout << noboolalpha << myBool << endl;
/*
1
true
1
*/
```
2. hex, oct, dec - выводит числа в шестнадцатеричном, восьмеричном, десятичном формате.
3. setprecision - устанавливает количество знаков после запятой
```cpp
cout << setprecision(5) << 1.23456789 << endl;
//1.2346
//Либо можно вызвать метод cout.precision(5);
```
4. setw - устанавливает ширину поля для выходных данных, смотри пример с setfill
5. setfill - устанавливает символ, как новый символ заполнения потока, заполняется в соответствии с шириной
```cpp
double dbl{ 1.452 };
cout << setw(7) << setfill('@') << dbl << endl;

int i{ 123 };
printf("%6d\n", i);
cout << setw(6) << i << endl;

printf("%06d\n", i);
cout << setfill('0') << setw(6) << i << endl;

// Заполняем *
cout << setfill('*') << setw(6) << i << endl;
/*
@@1.452
   123
@@@123
000123
000123
***123
*/
```
6. showpoint и noshowpoint - заставляет поток всегда или никогда не показывать десятичную часть для чисел с плавающей точкой без дробной части.
```cpp
double dbl{ 1.452 };
double dbl2{ 5 };
cout << setw(2) << setfill('0') << dbl2 << " " << showpoint << dbl2 << endl;
cout << setw(7) << setfill('@') << dbl << endl;
cout << showpoint << setw(7) << setfill('@') << dbl << endl;
/*
05 5.00000
1.45200
1.45200
*/
```
7. put_money - записывает форматированное денежное значение
```cpp
cout.imbue(locale{ "en_US.UTF-8" });
cout << 1234567 << endl;
//Центы в доллары
cout << put_money("120000") << endl;
/*
1,234,567
1,200.00
*/
```
8. put_time - записывает форматированное временное значение
9. quoted - заключает заданную строку в кавычки и экранирует встроенные кавычки
```cpp
cout << "This should be: \"Quoted string with \\\"embedded quotes\\\".\": "
	 << quoted("Quoted string with \"embedded quotes\".")
	 << endl;
//This should be: "Quoted string with \"embedded quotes\".": "Quoted string with \"embedded quotes\"."
```

# Ввод с помощью потоков
С помощью оператора `>>` мы можем считывать данные из потока до пробела.

```cpp
string userInput;
cin >> userInput;
cout << "User input was " << userInput << endl;
```

## Обработка ошибок вывода
Большинство ошибок возникают когда нет данных для чтения(конец потока, файла)
```cpp
while (cin) { ... }
while (cin >> ch) { ... }
```

Методы good(), bad(), fail() работают как и на выходных потоках

```cpp
int main()
{
	cout << "Enter numbers on separate lines to add.\n"
		<< "Use Control+D followed by Enter to finish (Control+Z in Windows).\n";
	int sum{ 0 };
	if (!cin.good()) {
		cerr << "Standard input is in a bad state!" << endl;
		return 1;
	}
	while (!cin.bad()) {
		int number;
		cin >> number;
		if (cin.good()) {
			sum += number;
		}
		else if (cin.eof()) {
			break; // Reached end of file
		}
		else if (cin.fail()) {
			// Failure!
			cin.clear(); // Clear the failure state.
			string badToken;
			cin >> badToken; // Consume the bad input.
			cerr << "WARNING: Bad input encountered: " << badToken << endl;
		}
	}
	cout << "The sum is " << sum << endl;
}
```

## Методы входных потоков
1. get() - позволяет вводить данные из потока, упрощенная версия возвращает следующий символ потока
```cpp
string readName(istream& stream)//Можем передать в поток имя с пробелами
{
	string name;
	while (stream) { // Or: while (!stream.fail()) {
		int next{ stream.get() };
		if (!stream || next == std::char_traits<char>::eof())
			break;
		name += static_cast<char>(next);// Append character.
	}
	return name;
}
```

Передаем поток по non-const ссылки, его позиции меняется, к тому же мы не можем использовать const ссылку. Для сохранения результата метода get() используем int поскольку он может вернуть конец потока, что не является символьный представлением `std::char_traits<char>::eof()`

Более упрощенный вариант:

```cpp
string readName(istream& stream)
{
	string name;
	char next;
	while (stream.get(next)) {
		name += next;
	}
	return name;
}
```
2. unget() - предыдущий символ возвращается в поток, если текущая позиция находится в начале, метод завершится неудачно.
```cpp
void getReservationData()//Бронируем на такое то имя такой-то номер отеля
{
	string guestName;
	int partySize{ 0 };
	// Read characters until we find a digit
	char ch;
	cin >> noskipws;
	while (cin >> ch) {
		if (isdigit(ch)) {
			cin.unget();
			if (cin.fail())
				cout << "unget() failed" << endl;
			break;
		}
		guestName += ch;
	}
	// Read partySize, if the stream is not in error state
	if (cin)
		cin >> partySize;
	if (!cin) {
		cerr << "Error getting party size." << endl;
		return;
	}
	cout << "Thank you " <<guestName << " party of " << partySize << endl;
	if (partySize > 10) {
		cout << "An extra gratuity will apply." << endl;
	}
}
```
3. putback() - помещает нужный символ  символ в поток
```cpp
int main()
{
	char c;
	cin >> c;
	cout << "Retrieved " << c << " before putback('c')." << endl;
	cin.putback('c'); // 'e' will be the next character read off the stream.
	cin >> c;
	cout << "Retrieved " << c << " after putback('c')." << endl;
	cin >> c;
	cout << c << endl;
	cin >> c;
	cout << c;
}
/*
abcdefghji
Retrieved a before putback('c').
Retrieved c after putback('c').
b
c
*/
```
4. peek() - позволяет предварительно посмотреть на значение следующего символа без смещения текущей позиции
```cpp
void getReservationData()
{
	string guestName;
	int partySize{ 0 };
	// Read characters until we find a digit
	cin >> noskipws;
	while (true) {
		// 'peek' at next character
		char ch{ static_cast<char>(cin.peek()) };
		if (!cin)
			break;
		if (isdigit(ch)) {
			// next character will be a digit, so stop the loop
			break;
		}
		// next character will be a non-digit, so read it
		cin >> ch;
		if (!cin)
			break;
		guestName += ch;
	}
	// Read partySize, if the stream is not in error state
	if (cin)
		cin >> partySize;
	if (!cin) {
		cerr << "Error getting party size." << endl;
		return;
	}
	cout << format("Thank you '{}', party of {}",
		guestName, partySize) << endl;
	if (partySize > 10) {
		cout << "An extra gratuity will apply." << endl;
	}
}
```
5. getline() - считывает последовательность до конца строки, т.е. по умолчанию до \n, перевода строки $=>$ можно класть строки содержащие пробелы, можно задать свой разделитель
```cpp
char buffer[BufferSize] { 0 };
cin.getline(buffer, BufferSize);

string myString;
getline(cin, myString);

cout << "Enter multiple lines of text. Use an @ character to signal the end of the text.\n> ";
string myString;
getline(cin, myString, '@');
cout << "Read text: \"" << myString << "\"" << endl;
/*
> first line
second line
third line @
Read text: "first line
second line
third line "
*/
```

## Входные манипуляторы
1. boolalpha и noboolalpha
2. dec, hex, and oct
3. skipws и noskipws - говорим потоку пропускать или нет пробел, по умолчанию пропускать
4. ws
5. get_money
6. get_time
7. quoted - считывает строку заключенную в кавычки в которой есть внутренние экранированные кавычки

# stringstreams
`istringstream` и `ostringstream` наследуются от `istream` и `ostream` $=>$ имеют схожее поведение.

```cpp
int main()
{
	cout << "Enter tokens. Control+D (Unix) or Control+Z (Windows) followed by Enter to end." << endl;
	ostringstream outStream;
	string nextToken;
	cout << "Next token: ";
	while (cin >> nextToken) {
		cout << "Next token: ";
		if (nextToken == "done")
			break;
		outStream << nextToken << "\t";
	}
	cout << "The end result is: " << outStream.str();
}
/*
Enter tokens. Control+D (Unix) or Control+Z (Windows) followed by Enter to end.
Next token: yellow
Next token: blue
Next token: white
Next token: brown
Next token: done
Next token: The end result is: yellow   blue    white   brown
*/
```

```cpp
Muffin createMuffin(istringstream& stream)
{
	Muffin muffin;
	// Предполагается, что данные верно отформатированы
	string description;
	int size;
	bool hasChips;
	stream >> description >> size >> boolalpha >> hasChips;
	if (stream) { // запись из потока успешно прошла
		muffin.setSize(size);
		muffin.setDescription(description);
		muffin.setHasChocolateChips(hasChips);
	}
	return muffin;
}
```

Преимущество перед обычной строкой в том, что:
1. У `stringstream` есть текущая позиция
2. Есть манипуляторы и локали
3. Построение большой строки из нескольких маленьких будет производительнее, чем конкатенация обычных строк

# Файловые потоки

![](cpp_basic13.png)

При работе с файлами поток `ostream` преобразует объекты, хранящиеся в основной памяти, в потоки байтов и записывает их на диск. Поток `istream` действует наоборот, он считывает поток байтов с диска и составляет из них объект.

![](cpp_basic14.png)

1. `fstream` - автоматически включает в себя `ios_base::in`
2. `ofstream` - автоматически включает в себя `ios_base::out`

Разница между потоками в том, что у конструктор файлов может принимать аргумент имени и режим открытия файла, по умолчанию `ios_base::out`, который начнет записывать данные в файл в начале и перезапишет любые существующие при повторном открытии.

| Constant         | Описание                                                                                   |
| ---------------- | ------------------------------------------------------------------------------------------ |
| ios_base::app    | Открывает и идет до конца файла перед каждой операцией записи                              |
| ios_base::ate    | Открывает и идет до конца файла один раз сразу после открытия                              |
| ios_base::binary | Выполняет ввод/вывод в двоичном режиме, а не в текстовом                                   |
| ios_base::in     | Открывает файл для того чтобы забрать данные, начиная сначала                              |
| ios_base::out    | Открывает файл, чтобы записать данные, начиная сначала и перезаписывая существующие данные |
| ios_base::trunc  | Открывает файл, чтобы записать данные и удаляет все существующие данные                    |

Режимы открытия файлов можно комбинировать:

```cpp
ios_base::out | ios_base::binary | ios_base::trunc
//Хотим открыть файл для вывода в бинарном виде, удаляя существующие данные
```

```cpp
int main(int argc, char* argv[])
{
	ofstream outFile{ "test.txt", ios_base::trunc };
	if (!outFile.good()) {
		cerr << "Error while opening output file!" << endl;
		return -1;
	}
	outFile << "There were " << argc << " arguments to this program." << endl;
	outFile << "They are: " << endl;
	for (int i{ 0 }; i < argc; i++) {
		outFile << argv[i] << endl;
	}
}
```

## Чтение из потока
Создадим файл `.txt` и напишем программу, которая выводит консоль содержание файла:

```
hello world!
second line
```

```cpp
ifstream input("hello.txt");
string line;
getline(input, line);
cout << line << endl;
getline(input, line);
cout << line << endl;
getline(input, line);
cout << line << endl;//в третий раз выведется второе значение тк достигнут конец файла. 
//Тк getline возвращает ссылку на поток, из которого берет данные. Поток можно привести
//к типу bool, причем false будет в случае, когда с потоком уже можно
//дальше не работать

//.............
//если файла hello.txt нет, то код будет работать, ошибок никаких не будет
//желательно чтобы программа должна говорить, что такого файла не существует
//метод is_open() возвращает true если файловый поток открыт и готов работать
if (input.is_open()){
	while (getline(input, line)) {
		cout << line << endl;
	}
	cout << "done!" << endl;
} else {
	cout << "error!" << endl;
}

//....................
//Поток можно приводить к типу bool причем значение true соответствует тому, 
//что с потоком можно работать в данный момент
//Поэтому код можно переписать
ifstream input("helol.txt");
string line;
if (input){
	while (getline(input, line)) {
		cout << line << endl;
	}
	cout << "done!" << endl;
} else {
	cout << "error!" << endl;
}
```

## Разница между текстовым и двоичным режимом
1. В текстовом режиме происходит скрытое преобразование, когда мы что-то туда записывает или считываем оттуда, конец строки заканчивается \n, но у каждой операционной системы свои конечные символы. Windows - \r\n, т.е. при записи в файл в Windows, \n автоматически преобразовывается в \r\n, при чтении из файла \r\n преобразуется в \n
2. В бинарном режиме мы записывает именно те байты, которые просим записать, при чтении байты возвращаются в том же виде, в котором находились в файле.


## Методы входных/выходных потоков
1. `seekx()` - позволяет переместиться в произвольную позицию внутри входного или выходного потока, для входного потока `seekg()`, для выходного `seekp()`, почему их два? Потому что файловый поток и входной и выходной, он хранит данные и текущей позиции для чтения и записи
2. `seekg()` и `seekp()` имеют по 2 перегрузки которые принимают
	1. Один параметр - принимает позицию(тип `std::streampos`) и выполняет поиск по ней
	2. Два параметр - перемещает на относительную позицию в потоке, принимает смещение(тип `std::streamoff`) и позицию(тип `std::streampos`) и выполняет поиск по ней

| Позиция       | Описание                 |
| ------------- | ------------------------ |
| ios_base::beg | Начало потока            |
| ios_base::end | Конец потока             |
| ios_base::cur | Текущая позиция в потоке |

```cpp
outStream.seekp(ios_base::beg);
inStream.seekg(ios_base::beg);

outStream.seekp(2, ios_base::beg);//перемещает на 2 байта вперед относительно начала
inStream.seekg(-3, ios_base::end);//перемещает на 3 байта назад относительно конца
```
3. `tellx()` - узнать текущее местоположение потока, который возвращает `std::streampos`
	1. `teelg()` - входные потока
	2.` tellp()` - выходные потоки

```cpp
streampos curPos { inStream.tellg() };
if (ios_base::beg == curPos) {
	cout << "We're at the beginning." << endl;
}
```

Следующая программа записывает данные в фай и выполняет следующие тесты:

```cpp
int main()
{
	ofstream fout{ "test.out" };
	if (!fout) {
		cerr << "Error opening test.out for writing" << endl;
		return 1;
	}
	// 1. Записываем строку "54321".
	fout << "54321";
	// 2. Проверяем, что находимся в 5 позиции
	streampos curPos{ fout.tellp() };
	if (curPos == 5) {
		cout << "Test passed: Currently at position 5" << endl;
	}
	else {
		cout << "Test failed: Not at position 5" << endl;
	}
	// 3. Сдвигает позицию на 2 относительно начала
	fout.seekp(2, ios_base::beg);
	// 4. Записывает 0 в позицию 2 и закрывает выходной поток
	fout << 0;
	fout.close();
	// 5. Открывает входной поток
	ifstream fin{ "test.out" };
	if (!fin) {
		cerr << "Error opening test.out for reading" << endl;
		return 1;
	}
	// 6. Читает первый токен как int
	int testVal;
	fin >> testVal;
	if (!fin) {
		cerr << "Error reading from file" << endl;
		return 1;
	}
	// 7. Проверяем, что значение 54021.
	const int expected{ 54021 };
	if (testVal == expected) {
		cout << "Test passed: Value is " << expected << endl;
	}
	else {
		cout << "Test failed: Value is not " << expected << "it was" << testVal << endl;
	}
}
```

## Объединение потоков
Между любыми входными и выходными потоками можно создать связь, чтобы обеспечить им одинаковое поведение при доступе. Когда данные запрашиваются из выходного потока, данные из входного автоматически очищаются.

```cpp
ifstream inFile { "input.txt" };
ofstream outFile { "output.txt" };
inFile.tie(&outFile);

outFile << "Hello there!";//мы не использовали endl, поэтому очистки не будет

string nextToken;
inFile >> nextToken;//тут мы уже меняем поток на входной, выходной поток очищается
```

Может соединить выходной поток, с другим выходным потоком 

```cpp
outFile.tie(&anotherOutputFile);
```

## Двунаправленный ввод/вывод
Двунаправленный поток - обеспечивает выполнения ввода, вывода. Для чего нужны? Допустим находить в файле ошибке и сразу их исправлять.

```cpp
bool changeNumberForID(string_view filename, int id, string_view newNumber)
{
	fstream ioData{ filename.data() };
	if (!ioData) {
		cerr << "Error while opening file " << filename << endl;
		return false;
	}
	//Пока не достигнем конца файла
	while (ioData) {
		int idRead;
		ioData >> idRead;
		if (!ioData)
			break;
		if (idRead == id) {
			// Перемещаем позицию записи в текущую позицию чтения
			ioData.seekp(ioData.tellg());
			ioData << " " << newNumber;
			break;
		}
		// Считываем текущий номер для продвижения текущей позиции
		string number;
		ioData >> number;
	}
	return true;
}
int main(int argc, char* argv[])
{
	string namefile = "output.txt";
	string newnumber = "999-999-9999";
	ofstream outFile{ namefile };

	outFile << "123 408-555-0394\n";
	outFile << "124 415-555-3422\n";
	outFile << "263 585-555-3490\n";
	outFile << "100 650-555-3434";

	outFile.close();//если мы не закрое поток, то на момент вызова функции файл output.txt будет пуст
	changeNumberForID(namefile, 124, newnumber);
}
```

## Библиотека поддержки файловой системы std::filesystem
### Путь
Путь может быть абсолютный и относительный

```cpp
path p1 { R"(D:\Foo\Bar)" };
path p2 { "D:/Foo/Bar" };
path p3 { "D:/Foo/Bar/MyFile.txt" };
path p4 { R"(..\SomeFolder)" };
path p5 { "/usr/lib/X11" };

path p { "D:\\Foo" };
p.append("Bar");
p /= "Bar";
cout << p << endl;//D:\\Foo\\Bar\\Bar

path p { "D:\\Foo" };
p.concat("Bar");
p += "Bar";
cout << p << endl;//D:\\FooBarBar

path p { R"(C:\Foo\Bar)" };
for (const auto& component : p) {
	cout << component << endl;
}
/*
	C:
	\\
	Foo
	Bar
*/

path p{ R"(D:\Work\Cpp\Brown\Crach course\output.txt)" };
cout << p.root_name() << endl;
cout << p.filename() << endl;
cout << p.stem() << endl;
cout << p.extension() << endl;
/*
	D:
	output.txt
	output
	.txt
*/
```

Путь представляет собой директорию или файл, который может существовать, а может не существовать. Если мы хотим использовать существующий путь, мы должны построить `directory_entry`

```cpp
path myPath{ R"(D:\Work\Cpp\Brown\Crach course\output.txt)"};
directory_entry dirEntry{ myPath };
if (dirEntry.exists() && dirEntry.is_regular_file()) {
	cout << "File size: " << dirEntry.file_size() << endl;
}
//File size: 70
```

### Итераторы
Имея путь мы можем сделать итерацию по содержимому папки
```cpp
std::filesystem::directory_iterator start{path}, fin;//итератор для конца сингулярный
std::vector entries(start, fin); // → vector<directory_entry>
//Далее у каждого из entries[i] можно в свою очередь получить path и т. д
```

```cpp
std::vector<directory_entry> contents(directory_entry d);  

auto files_in_subdirs() {  
    std::filesystem::directory_iterator start{"."};  
    std::vector<std::filesystem::directory_entry> res;  
    for (auto &&item : start)  
        if (item.is_directory()) {  
            auto ents = contents(item);  
            res.insert(res.end(),  
                       std::make_move_iterator(ents.begin()),  
                       std::make_move_iterator(ents.end())); // move  
        }  
    return res;  
}
```

Вывести все файлы и их каталоги

```cpp
void printDirectoryStructure(const path& p)
{
	if (!exists(p)) {
		return;
	}
	recursive_directory_iterator begin{ p };
	recursive_directory_iterator end{ };
	for (auto iter{ begin }; iter != end; ++iter) {
		const string spacer(iter.depth() * 2, ' ');
		auto& entry{ *iter }; // Dereference iter to access directory_entry.
		if (is_regular_file(entry)) {
			cout << format("{}File: {} ({} bytes)",
				spacer, entry.path().string(), file_size(entry)) << endl;
		}
		else if (is_directory(entry)) {
			cout << format("{}Dir: {}", spacer, entry.path().string()) << endl;
		}
	}
}

int main(int argc, char* argv[])
{
	path p{ R"(C:)" };
	printDirectoryStructure(p);
}
```
