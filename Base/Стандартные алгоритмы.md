# Использование итераторов в алгоритмах
## Vector

**remove_if**
```cpp
vector<string> langs = {"Python", "C++", "C", "Java", "C#"}; 
remove_if (begin(langs), end(langs), [](const string& lang)) { // лямбда-функция, по которой удаляем 
return lang [0] == 'C'; 
// хотим удалить все языки, начинающиеся на C 
});
PrintRange (begin(langs), end(langs));// Java Python C C#
```
С помощью данной функции мы не удаляем все языки начинающиеся с C. Мы удаляем первое вхождение, а остальные переносим в конец.
```cpp
langs.erase(it, end(langs));
PrintRange (begin(langs), end(langs)); // Java Python
```

**unique**
Удаление подряд идущих дубликатов

```cpp
vector<string> langs = {"Python", "C++", "C++", "Java", "C++"}; // оставляем из подряд идущих повторов только один элемент 
auto it = unique(begin(langs), end(langs)); 
langs.erase(it , end(langs)); // удаляем повторяющиеся, которые выкинуты в конец 
PrintRange(begin(langs), end(langs)); // Python C++ Java C++
```

Можно сначала отсортировать вектор, а потом применить unique, чтобы удалить все повторы.

**min_elemnt && max_element**
Нахождение минимума и максимума
```cpp
vector<string> langs = {"Python", "C++", "C", "Java", "C#"};
auto it = min_element(begin(langs), end(langs)); // кладём в итератор мин. элемент 
cout << ∗it << endl; // min_element может вернуть end(langs), только если langs пуст // C
auto it = max_element (begin(langs), end(langs)); // максимальный элемент 
cout << ∗it << endl; // Python
auto p = minmax_element (begin(langs), end(langs)); // пара - min и max в контейнере 
cout << ∗p.first << ' ' << ∗p.second << endl; // C Python
```

Для множества(set) нет смысла вызывать функция для нахождения минимального и максимального элемента, т.к. min - begin, max - перед end.

**Partition**
Позволяет отложить в конец нужные элементы

```cpp
vector<string> langs = {"Python", "C++", "C", "Java", "C#"}; 
auto it = partition (begin(langs), end(langs), [](const string& lang) { return lang [0] == 'C'; // делим по принципу "начинается или не начинается на C" 
																	   }); 
PrintRange (begin(langs), end(langs)); 
// C# C++ C Java Python
```

**Copy_if**
Если хотим переложить элементы

```cpp
// исправим PrintRange, чтобы выводил через запятую ... 
vector<string> langs = {"Python", "C++", "C", "Java", "C#"}; 
vector c_langs(langs.size ()); // вектор, куда мы копируем, должен быть объявлен и иметь подходящий размер 
auto it = copy_if(begin(langs), end(langs), begin(c_langs), [](const string& lang) { return lang [0] == 'C'; 																				}); 
PrintRange (begin(c_langs), end(c_langs)); 
// C++, C, C#, , ,
```

**count**
Подсчета кол-ва вхождений

```cpp
count(begin(v), end(v), x);
v.count(x);
```

**find**
```cpp
find(begin(v), end(v), x); 
v.find(x);
```

В отсортированном векторе поиск быстрее работает, если применить бинарный поиск.

Проверка на существование: 
```cpp
binary_search (begin(v), end(v), x)
```

Первый больший или равный данному:
```cpp
lower_bound (begin(v), end(v), x)
```

Первый элемент, больший данного: 
```cpp
upper_bound (begin(v), end(v), x)
```

Диапазон элементов, равных данному (аналог minmax): 
```cpp
equal_range (begin(v), end(v), x) == make_pair ( lower_bound (...) , upper_bound (...))
```

1. Если элемент есть, то `equal_range = [lower_bound, upper_bound)` – диапазон всех вхождений; 
2. Если же элемента нет, то `lower_bound == upper_bound` – позиция, куда можно вставить элемент без нарушения порядка сортировки;  
3. Количество вхождений `== upper_bound - lower_bound`;  
4. А перебрать все элементы, равные данному, можно просто проитерировавшись от `lower_bound` до `upper_bound`.

![[../Files/Pasted image 20220214173604.png]]

## Set
Для множества мы не можем вызывать алгоритм remove, т.к. не можем изменять порядок элементов.
**all_of**
```cpp
set<string> langs = {"Python", "C++", "C", "Java", "C#"}; 
cout << all_of(begin(langs), end(langs), [](const string& lang) { return lang [0] >= 'A' && lang [0] <= 'Z'; // все названия с большой буквы 
}) << endl; // 1
```

Т.к. у нас все элементы начинаются с заглавной, то алгоритм выводит true. Если хотя бы одна строка будет начинаться с маленькой, то false.

**set_intersection**

```cpp
// исправим PrintRange, чтобы выводил через запятую 
set a = {1, 8 ,3}; set b = {3, 6 ,8};
vector v(a.size ()); // вектор для хранения результата размера как set a 
auto it = set_intersection (begin(a), end(a), begin(b), end(b), begin(v)); // intersection принимает два полуинтервала и итератор, куда сохранять результат 
PrintRange (begin(v), end(v)); 
// 3, 8, 0,
PrintRange (begin(v), it);
// 3, 8,
```

Поиск для множества:
```cpp
s.count(x);
s.find(x);
s.lower_bound(x);
s.upper_bound(x);
s.equal_range(x)
```