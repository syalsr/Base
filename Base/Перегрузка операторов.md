# Перегрузка операторов
# Для чего это нужно
1. Обращаться с собственными типами как со встроенными.
2. Простота использования, если мы переопределим оператор вывода проще писать елочку, чем каждый раз дублировать код вывода, который мог бы быть только в функции вывода.
3. Из 2 пункта вытекает, то что таким образом мы не дублируем код $=>$ код становится меньше и понятнее.

# Ограничения для переопределения операторов
1. Мы не можем добавить новый символьный оператор, мы можем только перегрузить имеющиеся в C++
2. Некоторые операторы нельзя перегружать - `.` `.*` `::` `?:`
3. Мы не может переопределить приоритет и ассоциативность операций
4. Мы не можем переопределить операторы для встроенных типов

# Варианты перегрузки операторов
1. Метод или глобальная функция(либо дружественная к классу функция).
	1. Если мы используем метод, то lhs, должен быть объектом этого класса. При перегрузки ввода/вывода левый операнд - это поток, в таком случае мы используем глобальную функцию.
	2. Из 2 вытекает то что если левый операнд объект какого-то класса, то стоит сделать его методом и поместить в класс.
2. Типы аргументов - by non-const ref, by const ref, by value - все как и при передачи в обычные функции/методы
3. Тип возвращаемого объекта
	1. Обычно, чтобы обеспечить конвейерный вызов(`object1 = object2 = object3` либо `cout << 1 << 2 << 3`) нужно, чтобы функция возвращала левый операнд.
	2. Если это метод, то возвращать объект этого класса `return *this`. Если разбирать пример выше, то сначала выполнится присваивание `object2=object3`,  результатом работы метода будет возвращение объекта object2, который присвоится object1. Мы могли бы ничего не возвращать(void), тогда пришлось бы писать такой код в 2 строчки.
	3. Если это функция, то lhs object, допустим мы переопределяем оператор вывода в поток, тогда возвращаем поток.
	4. Но если метод/функция сравнивают объекты, то нужно возвращать bool

# Операторы которые не следует переопределять, потому что зачем?
1. Взятие адреса `&`
2. Логические операторы  `|| &&`
3. Оператор запятая `,` который используется для разделения выражения `int x = 1; cout << (++x, 2 * x);//4`

# Общие принципе перегрузку операторов
| Оператор          | Категория                        | Метод или функция | Зачем перегружать                                            | Пример                                                                                 |     |
| ----------------- | -------------------------------- | ----------------- | ------------------------------------------------------------ | -------------------------------------------------------------------------------------- | --- |
| operator+         | Бинарный арифметический          | Функция           | Когда хочешь применять арифметические операции над классами  | `T operator+(const T&, const T&); T operator+(const T&, const E&);`                    |     |
| operator-         |                                  |                   |                                                              |                                                                                        |     |
| operator*         |                                  |                   |                                                              |                                                                                        |     |
| operator/         |                                  |                   |                                                              |                                                                                        |     |
| operator%         |                                  |                   |                                                              |                                                                                        |     |
| operator-         | Унарный арифметический           | Метод             | Когда это нужно                                              | `T operator-() const`                                                                  |     |
| operator+         |                                  |                   |                                                              |                                                                                        |     |
| operator~         |                                  |                   |                                                              |                                                                                        |     |
| operator++        | Prefix increment                 | Метод             | Когда хочешь переопределить `+=`                             | `T& operator++();`                                                                     |     |
| operator--        | Prefix decrement                 |                   | Когда хочешь переопределить  `-=`                            | `T& operator--()`                                                                      |     |
| operator++        | Post-fix increment               | Метод             | Когда хочешь переопределить `+=`                             | `T operator++(int)`                                                                    |     |
| operator--        | Post-fix   decrement             |                   | Когда хочешь переопределить  `-=`                            | `T operator--(int)`                                                                    |     |
| operator=         | Оператор присваивания            | Метод             |                                                              | `T& operator=(const T&);`                                                              |     |
| operator+=        | Короткий бинарный арифметический | Метод             |                                                              | `T& operator+=(const T&); T& operator+=(const E&)`                                     |     |
| operator-=        |                                  |                   |                                                              |                                                                                        |     |
| operator*=        |                                  |                   |                                                              |                                                                                        |     |
| operator/=        |                                  |                   |                                                              |                                                                                        |     |
| operator%=        |                                  |                   |                                                              |                                                                                        |     |
| operator<<        | Бинарный побитовый               | Функция           |                                                              | `T operator<<(const T&, const T&); T operator<<(const T&, const E&)`                   |     |
| operator>>        |                                  |                   |                                                              |                                                                                        |     |
| operator&         |                                  |                   |                                                              |                                                                                        |     |
| operator          |                                  |                   |                                                              |                                                                                        |     |
| operator^         |                                  |                   |                                                              |                                                                                        |     |
| operator<<=       | Короткий бинарный побитовый      | Метод             |                                                              | `T& operator<<=(const T&); T& operator<<=(const E&)`                                   |     |
| operator>>=       |                                  |                   |                                                              |                                                                                        |     |
| operator&=        |                                  |                   |                                                              |                                                                                        |     |
| operator=         |                                  |                   |                                                              |                                                                                        |     |
| operator^=        |                                  |                   |                                                              |                                                                                        |     |
| operator==        | Бинарный логический              | Функция           |                                                              | `bool operator==(const T&, const T&) const; bool operator==(const T&, const E&) const` |     |
| operator!=        |                                  |                   |                                                              |                                                                                        |     |
| operator<         |                                  |                   |                                                              |                                                                                        |     |
| operator>         |                                  |                   |                                                              |                                                                                        |     |
| operator<=        |                                  |                   |                                                              |                                                                                        |     |
| operator>=        |                                  |                   |                                                              |                                                                                        |     |
| operator<<        | Оператор вывода                  | Функция           |                                                              | `ostream& operator<<(ostream&, const T&);`                                             |     |
| operator>>        | Оператор ввода                   |                   |                                                              | `istream& operator>>(istream&, const T&);`                                             |     |
| operator!         | Логическое отрицание             | Метод             |                                                              | `bool operator!() const;`                                                              |     |
| operator[]        | Индекс массива                   |                   |                                                              | `E& operator[](size_t); const E& operator[](size_t) const`                             |     |
| operator()        | Вызов функции                    |                   |                                                              |                                                                                        |     |
| operator type()   | Преобразовние или приведение     |                   | Когда хотим предоставлять приведение из одного типа в другой | `operator double() const;`                                                             |     |
| `operator ""__X`  | Литерал                          | Функция           |                                                              | `T operator""_i(long double d);`                                                       |     |
| operator new      | Алокация памяти                  | Метод             |                                                              | `void* operator new(size_t size);`                                                     |     |
| operator new[]    |                                  |                   |                                                              |                                                                                        |     |
| operator delete   | Деалокация памяти                |                   |                                                              | `void* operator delete(size_t size);`                                                  |     |
| operator delete[] |                                  |                   |                                                              |                                                                                        |     |
| operator*         | Разыменование                    |                   | Для умных указателей                                         | `E& operator*() const`                                                                 |     |
| operator->        |                                  |                   |                                                              |                                                                                        |     |

# Приоритет и ассоциативность операторов
| PRECEDENCE | OPERATOR                                                                | ASSOCIATIVITY |
| ---------- | ----------------------------------------------------------------------- | ------------- |
| 1          | ::                                                                      | Left-to-right |
| 2          | x++ x-- x() x[] T() T{} . ->                                            | Left-to-right |
| 3          | `++x --x +x -x ! ~ *x &x (T) sizeof co_await new delete new[] delete[]` | Right-to-left |
| 4          | .* ->*                                                                  | Left-to-right |
| 5          | `x*y x/y x%y`                                                           | Left-to-right |
| 6          | x+y x-y                                                                 | Left-to-right |
| 7          | << >>                                                                   | Left-to-right |
| 8          | <=>                                                                     | Left-to-right |
| 9          | < <= > >=                                                               | Left-to-right |
| 10         | == !=                                                                   | Left-to-right |
| 11         | &                                                                       | Left-to-right |
| 12         | ^                                                                       | Left-to-right |
| 13         | `|`                                                                     | Left-to-right |
| 14         | &&                                                                      | Left-to-right |
| 15         | `|| `                                                                   | Left-to-right |
| 16         | `x?y:z throw co_yield = += -= *= /= %= <<= >>= &= ^= |=`                | Right-to-left |
| 17         | ,                                                                       | Left-to-right |

# Примеры переопределения некоторых операторов
```cpp
SpreadsheetCell& SpreadsheetCell::operator++()// Prefix
{
	set(getValue() + 1);
	return *this;
}
SpreadsheetCell SpreadsheetCell::operator++(int)// Postfix
{
	auto oldCell{ *this }; // Save current value
	++(*this); // Increment using prefix ++
	return oldCell; // Return the old value
}
```

```cpp
ostream& operator<<(ostream& ostr, const SpreadsheetCell& cell)
{
	ostr << cell.getValue();
	return ostr;
}
istream& operator>>(istream& istr, SpreadsheetCell& cell)
{
	double value;
	istr >> value;
	cell.set(value);
	return istr;
}
```

```cpp
template <typename T> 
T& Array<T>::operator[](size_t x)
{
	if (x >= m_size) {
		throw std::out_of_range { "Array subscript out of range" };
	}
	return m_elements[x];
}
```

Класс который перегружает оператор вызова функции называется функцианальным или функтором

```cpp
class FunctionObject
{
public:
	int operator() (int param); // Function call operator
	int doSquare(int param); // Normal method
};
// Implementation of overloaded function call operator
int FunctionObject::operator() (int param)
{
	return doSquare(param);
}

// Implementation of normal method
int FunctionObject::doSquare(int param)
{
	return param * param;
}
int main()
{
	int x{ 3 }, xSquared, xSquaredAgain;
	FunctionObject square;
	xSquared = square(x); // Call the function call operator.
	xSquaredAgain = square.doSquare(x); // Call the normal method.
}
```

```cpp
template <typename T> 
class Pointer
{
public:
	// Omitted for brevity
	T& operator*() { return *m_ptr; }
	const T& operator*() const { return *m_ptr; }
	// Omitted for brevity
	// Omitted for brevity
	T* operator->() { return m_ptr; }
	const T* operator->() const { return m_ptr; }
	// Omitted for brevity
private:
	T* m_ptr { nullptr };
};
```

```cpp
SpreadsheetCell::operator double() const
{
	return getValue();
}

SpreadsheetCell cell { 1.23 };
double d1 { cell };
```

```cpp
SpreadsheetCell::operator void*() const { return m_ptr; }
SpreadsheetCell::operator bool() const { return m_ptr != nullptr; }
//либо так, либо так

void process(Pointer<SpreadsheetCell>& p)
{
	if (p != nullptr) { cout << "not nullptr" << endl; }
	if (p != NULL) { cout << "not NULL" << endl; }
	if (p) { cout << "not nullptr" << endl; }
	if (!p) { cout << "nullptr" << endl; }
}

int main()
{
	Pointer<SpreadsheetCell> smartCell { nullptr };
	process(smartCell);
	cout << endl;
	Pointer<SpreadsheetCell> anotherSmartCell { new SpreadsheetCell { 5.0 } };
	process(anotherSmartCell);
}
/*
	nullptr
	not nullptr
	not NULL
	not nullptr
*/
```

# Перегрузка new && delete
Что делает new?
1. Выделяет память
2. Вызывает конструктор объекта
3. Возвращает указатель
```cpp
void* operator new(size_t size);
void* operator new[](size_t size);
void* operator new(size_t size, const std::nothrow_t&) noexcept;
void* operator new[](size_t size, const std::nothrow_t&) noexcept;
```

Есть также функции которые на уже выделенной памяти вызывают конструктор объекта, чтобы занять ее - это функции называются placement new операторы, но C++ запрещает перегружать их

```cpp
void* operator new(size_t size, void* p) noexcept;
void* operator new[](size_t size, void* p) noexcept;

void* ptr { allocateMemorySomehow() };
SpreadsheetCell* cell { new (ptr) SpreadsheetCell{} };
```

Почему это полезно? Мы не тратим время на алоцирование памяти.

Что делает delete?
1. Вызывает деструктор для объекта
2. Очищает память
```cpp
void operator delete(void* ptr) noexcept;
void operator delete[](void* ptr) noexcept;
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* ptr, void*) noexcept;
void operator delete[](void* ptr, void*) noexcept;
```

Перегрузки nothrow и placement delete используется в том случае, если конструктор выбрасывает исключение. В таком случае выбираем тот delete который соответствует new. Если мы удаляем объект как обычно `delete delete[]`, то вызовется обычная перегрузка(не nothrow и placement). Placement delete не особо полезен, поскольку placement new не выделяет память, соответственно placement delete не удаляет ее.


Стоит переопределять new и delete только для специфичных классов, при создании объекта этого класса будут вызываться переопределенные операторы. Если мы переопределяем new, то должны переопределить соответствующую форму оператора delete, иначе вызовется встроенный delete, который может неправильно очистить память.

Пример переопределения:

```cpp
class MemoryDemo
{
public:
	virtual ~MemoryDemo() = default;
	void* operator new(size_t size);
	void operator delete(void* ptr) noexcept;
	void* operator new[](size_t size);
	void operator delete[](void* ptr) noexcept;
	void* operator new(size_t size, const std::nothrow_t&) noexcept;
	void operator delete(void* ptr, const std::nothrow_t&) noexcept;
	void* operator new[](size_t size, const std::nothrow_t&) noexcept;
	void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
};

void* MemoryDemo::operator new(size_t size)
{
	cout << "operator new" << endl;
	return ::operator new(size);
}
void MemoryDemo::operator delete(void* ptr) noexcept
{
	cout << "operator delete" << endl;
	::operator delete(ptr);
}
void* MemoryDemo::operator new[](size_t size)
{
	cout << "operator new[]" << endl;
	return ::operator new[](size);
}
void MemoryDemo::operator delete[](void* ptr) noexcept
{
	cout << "operator delete[]" << endl;
	::operator delete[](ptr);
}
void* MemoryDemo::operator new(size_t size, const nothrow_t&) noexcept
{
	cout << "operator new nothrow" << endl;
	return ::operator new(size, nothrow);
}
void MemoryDemo::operator delete(void* ptr, const nothrow_t&) noexcept
{
	cout << "operator delete nothrow" << endl;
	::operator delete(ptr, nothrow);
}
void* MemoryDemo::operator new[](size_t size, const nothrow_t&) noexcept
{
	cout << "operator new[] nothrow" << endl;
	return ::operator new[](size, nothrow);
}
void MemoryDemo::operator delete[](void* ptr, const nothrow_t&) noexcept
{
	cout << "operator delete[] nothrow" << endl;
	::operator delete[](ptr, nothrow);
}

int main()
{
	MemoryDemo* mem{ new MemoryDemo{} };
	delete mem;
	mem = new MemoryDemo[10];
	delete[] mem;
	mem = new (nothrow) MemoryDemo{};
	delete mem;
	mem = new (nothrow) MemoryDemo[10];
	delete[] mem;
}
/*
	operator new
	operator delete
	operator new[]
	operator delete[]
	operator new nothrow
	operator delete
	operator new[] nothrow
	operator delete[]
*/
```

Мы можем явно сделать delete/default операторы new и delete

```cpp
class MyClass
{
public:
	void* operator new(size_t size) = delete;
	void* operator new[](size_t size) = delete;
};

int main()
{
	MyClass* p1 { new MyClass };//error
	MyClass* p2 { new MyClass[2] };//error
	//явно удалили операторы, теперь мы не сможем динамически создавать этот класс
}
```

## Перегрузка операторов new и delete с extra параметрами
Можем передать в оператор специальный флаг или счетчик

```cpp
class MemoryDemo
{
public:
	void* operator new(size_t size, int extra)
	{
		cout << "operator new with extra int: " << extra << endl;
		return ::operator new(size);
	}
	void operator delete(void* ptr, int extra) noexcept
	{
		cout << "operator delete with extra int: " << extra << endl;
		return ::operator delete(ptr);
	}
};

int main()
{
	MemoryDemo* memp { new(5) MemoryDemo{} };
	delete memp;//вызовется обычный delete
}
/*
	operator new with extra int: 5
	operator delete
*/
```

## Перегрузка оператора delete с размером памяти как параметром
Если в вашем классе объявлены две версии delete - одна с параметром size, другая нет, то всегда будет вызываться версия без параметра. Чтобы этого избежать нужно объявить только версию с параметром

```cpp
void MemoryDemo::operator delete(void* ptr, size_t size) noexcept
{
	cout << "operator delete with size " << size << endl;
	::operator delete(ptr);//не существует глоабльного delete который принимал бы размер
}
```

## Перегрузка пользовательских литеральных операторов
Мы можем перегружать [[Литералы]], если они начинаются с подчеркиваний. Литеральный оператор может работать в двух режимах:
1. raw mode - ваш оператор принимает последовательность символов
	1. Передаем 123 - '1', '2', '3'
	2. Передаем 0x23 - '0', 'x', '2', '3'
	3. Передаем 3.14 - '3', '.', '1', '4'
2. cooked mode - ваш оператор принимает определенный интерпретируемый тип
	1. Передаем 123 - 123 число типа int
	2. Передаем 0x23 - 35 число типа int
	3. Передаем 3.14 - 3.14 число типа float

## Cooked mode literal operator
Этот оператор должен иметь один из следующих признаков:
1. Обработка число значений - 1 параметр типа `unsigned long long, long double, char, wchar_t, char8_t, char16_t, or char32_t`
2. Обработка строк - 2 параметра, первый - массив символом, второй - длина. `(const char* str, size_t len)`

```cpp
complex<long double> operator"" _i(long double d)
{
	return complex<long double> { 0, d };
}

string operator"" _s(const char* str, size_t len)
{
	return string(str, len);
}

int main()
{
	complex<long double> c1 { 9.634_i };
	auto c2 { 1.23_i }; // c2 has as type complex<long double>

	string str1 { "Hello World"_s };
	auto str2 { "Hello World"_s }; // str2 has as type string
}
```

## Raw-Mode Literal Operator
Этот оператор требует одного параметра `const char*`, он работает только с нестроковыми литералами
```cpp
complex<long double> operator"" _i(const char* p)
{
	return complex<long double>{stod(p) };
}
int main()
{
	complex<long double> c1{ 9.634_i };
	auto c2{ 1.23_i }; // c2 has as type complex<long double>
}
```

## Стандартные литералы
| Литерал               | Возвращаемый тип                                                     | Пример                          |
| --------------------- | -------------------------------------------------------------------- | ------------------------------- |
| s                     | string                                                               | auto myString {"Hello"s };      |
| sv                    | string                                                               | auto myStringView {"Hello"sv }; |
| h, min, s, ms, us, ns | chrono::duration                                                     | auto myDuration{ 42min };       |
| i, il, if             | `complex<T>` with T equal to double, long double, float respectively | auto myComplexNumber { 1.3i };  |
