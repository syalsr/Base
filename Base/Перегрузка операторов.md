# Перегрузка операторов
# Для чего это нужно
1. Обращаться с собственными типами как со встроенными.
2. Простота использования, если мы переопределим оператор вывода проще писать елочку, чем каждый раз дублировать код вывода, который мог бы быть только в функции вывода.
3. Из 2 пункта вытекает, то что таким образом мы не дублируем код $=>$ код становится меньше и понятнее.

# Ограничения для переопределения операторов
1. Мы не можем добавить новый символьный оператор, мы можем только перегрузить имеющиеся в C++
2. Некоторые операторы нельзя перегружать - `.` `.*` `::` `?:`
3. Мы не может переопределить приоритет и ассоциативность операций
4. Мы не можем переопределить операторы для встроенных типов

# Варианты перегрузки операторов
1. Метод или глобальная функция(либо дружественная к классу функция).
	1. Если мы используем метод, то lhs, должен быть объектом этого класса. При перегрузки ввода/вывода левый операнд - это поток, в таком случае мы используем глобальную функцию.
	2. Из 2 вытекает то что если левый операнд объект какого-то класса, то стоит сделать его методом и поместить в класс.
2. Типы параметров - by non-const ref, by const ref, by value - все как и при передачи в обычные функции/методы
3. Тип возвращаемого объекта
	1. Обычно, чтобы обеспечить конвейерный вызов(`object1 = object2 = object3` либо `cout << 1 << 2 << 3`) нужно, чтобы функция возвращала левый операнд.
	2. Если это метод, то возвращать объект этого класса `return *this`. Если разбирать пример выше, то сначала выполнится присваивание `object2=object3`,  результатом работы метода будет возвращение объекта object2, который присвоится object1. Мы могли бы ничего не возвращать(void), тогда пришлось бы писать такой код в 2 строчки.
	3. Если это функция, то lhs object, допустим мы переопределяем оператор вывода в поток, тогда возвращаем поток.
	4. Но если метод/функция сравнивают объекты, то нужно возвращать bool

# Операторы которые не следует переопределять, потому что зачем?
1. Взятие адреса `&`
2. Логические операторы  `|| &&`
3. Оператор запятая `,` который используется для разделения выражения `int x = 1; cout << (++x, 2 * x);//4` - означает выполнить все выражения, вернуть результат последнего `res = foo(), bar()//в res лежит результат bar()`, выполняется все по порядку.

# Общие принципе перегрузку операторов
| Оператор          | Категория                        | Метод или функция | Зачем перегружать                                            | Пример                                                                                 |     |
| ----------------- | -------------------------------- | ----------------- | ------------------------------------------------------------ | -------------------------------------------------------------------------------------- | --- |
| operator+         | Бинарный арифметический          | Функция           | Когда хочешь применять арифметические операции над классами  | `T operator+(const T&, const T&); T operator+(const T&, const E&);`                    |     |
| operator-         |                                  |                   |                                                              |                                                                                        |     |
| operator*         |                                  |                   |                                                              |                                                                                        |     |
| operator/         |                                  |                   |                                                              |                                                                                        |     |
| operator%         |                                  |                   |                                                              |                                                                                        |     |
| operator-         | Унарный арифметический           | Метод             | Когда это нужно                                              | `T operator-() const`                                                                  |     |
| operator+         |                                  |                   |                                                              |                                                                                        |     |
| operator~         |                                  |                   |                                                              |                                                                                        |     |
| operator++        | Prefix increment                 | Метод             | Когда хочешь переопределить `+=`                             | `T& operator++();`                                                                     |     |
| operator--        | Prefix decrement                 |                   | Когда хочешь переопределить  `-=`                            | `T& operator--()`                                                                      |     |
| operator++        | Post-fix increment               | Метод             | Когда хочешь переопределить `+=`                             | `T operator++(int)`                                                                    |     |
| operator--        | Post-fix   decrement             |                   | Когда хочешь переопределить  `-=`                            | `T operator--(int)`                                                                    |     |
| operator=         | Оператор присваивания            | Метод             |                                                              | `T& operator=(const T&);`                                                              |     |
| operator+=        | Короткий бинарный арифметический | Метод             |                                                              | `T& operator+=(const T&); T& operator+=(const E&)`                                     |     |
| operator-=        |                                  |                   |                                                              |                                                                                        |     |
| operator*=        |                                  |                   |                                                              |                                                                                        |     |
| operator/=        |                                  |                   |                                                              |                                                                                        |     |
| operator%=        |                                  |                   |                                                              |                                                                                        |     |
| operator<<        | Бинарный побитовый               | Функция           |                                                              | `T operator<<(const T&, const T&); T operator<<(const T&, const E&)`                   |     |
| operator>>        |                                  |                   |                                                              |                                                                                        |     |
| operator&         |                                  |                   |                                                              |                                                                                        |     |
| operator          |                                  |                   |                                                              |                                                                                        |     |
| operator^         |                                  |                   |                                                              |                                                                                        |     |
| operator<<=       | Короткий бинарный побитовый      | Метод             |                                                              | `T& operator<<=(const T&); T& operator<<=(const E&)`                                   |     |
| operator>>=       |                                  |                   |                                                              |                                                                                        |     |
| operator&=        |                                  |                   |                                                              |                                                                                        |     |
| operator=         |                                  |                   |                                                              |                                                                                        |     |
| operator^=        |                                  |                   |                                                              |                                                                                        |     |
| operator==        | Бинарный логический              | Функция           |                                                              | `bool operator==(const T&, const T&) const; bool operator==(const T&, const E&) const` |     |
| operator!=        |                                  |                   |                                                              |                                                                                        |     |
| operator<         |                                  |                   |                                                              |                                                                                        |     |
| operator>         |                                  |                   |                                                              |                                                                                        |     |
| operator<=        |                                  |                   |                                                              |                                                                                        |     |
| operator>=        |                                  |                   |                                                              |                                                                                        |     |
| operator<<        | Оператор вывода                  | Функция           |                                                              | `ostream& operator<<(ostream&, const T&);`                                             |     |
| operator>>        | Оператор ввода                   |                   |                                                              | `istream& operator>>(istream&, const T&);`                                             |     |
| operator!         | Логическое отрицание             | Метод             |                                                              | `bool operator!() const;`                                                              |     |
| operator[]        | Индекс массива                   |                   |                                                              | `E& operator[](size_t); const E& operator[](size_t) const`                             |     |
| operator()        | Вызов функции                    |                   |                                                              |                                                                                        |     |
| operator type()   | Преобразовние или приведение     |                   | Когда хотим предоставлять приведение из одного типа в другой | `operator double() const;`                                                             |     |
| `operator ""__X`  | Литерал                          | Функция           |                                                              | `T operator""_i(long double d);`                                                       |     |
| operator new      | Алокация памяти                  | Метод             |                                                              | `void* operator new(size_t size);`                                                     |     |
| operator new[]    |                                  |                   |                                                              |                                                                                        |     |
| operator delete   | Деалокация памяти                |                   |                                                              | `void* operator delete(size_t size);`                                                  |     |
| operator delete[] |                                  |                   |                                                              |                                                                                        |     |
| operator*         | Разыменование                    |                   | Для умных указателей                                         | `E& operator*() const`                                                                 |     |
| operator->        |                                  |                   |                                                              |                                                                                        |     |

# Приоритет и ассоциативность операторов
| PRECEDENCE | OPERATOR                                                                | ASSOCIATIVITY |
| ---------- | ----------------------------------------------------------------------- | ------------- |
| 1          | ::                                                                      | Left-to-right |
| 2          | x++ x-- x() x[] T() T{} . ->                                            | Left-to-right |
| 3          | `++x --x +x -x ! ~ *x &x (T) sizeof co_await new delete new[] delete[]` | Right-to-left |
| 4          | .* ->*                                                                  | Left-to-right |
| 5          | `x*y x/y x%y`                                                           | Left-to-right |
| 6          | x+y x-y                                                                 | Left-to-right |
| 7          | << >>                                                                   | Left-to-right |
| 8          | <=>                                                                     | Left-to-right |
| 9          | < <= > >=                                                               | Left-to-right |
| 10         | == !=                                                                   | Left-to-right |
| 11         | &                                                                       | Left-to-right |
| 12         | ^                                                                       | Left-to-right |
| 13         | `|`                                                                     | Left-to-right |
| 14         | &&                                                                      | Left-to-right |
| 15         | `|| `                                                                   | Left-to-right |
| 16         | `x?y:z throw co_yield = += -= *= /= %= <<= >>= &= ^= |=`                | Right-to-left |
| 17         | ,                                                                       | Left-to-right |

# Унарный плюс - positive hack
```cpp
2 == +2//true

struct Foo { operator long() { return 42; }};  
void foo(int x);  
void foo(Foo x);  
Foo f;  
foo(f); // вызовет foo(Foo)  
foo(+f); // вызовет foo(int) унарный + созданный компилятором приводит тип Foo к типу long, если мы сами захотим переопределить унарный + этого не будет, поэтому обычно егоне переопределяют 
```

# Примеры переопределения некоторых операторов
```cpp
template <typename T> T& operator->*(pair<T,T> &l, bool r) {  
    return r ? l.second : l.first;  
}  
pair<int, int> y {5, 6};  
y ->* false = 7;
```

```cpp
template<typename T> struct Quat {  
    T x_, y_, z_, w_;  
    Quat<T>& operator++() { x_ += 1; return *this; }  
    Quat<T> operator++(int) {  
        Quat<T> tmp {*this};  
        ++(*this);  
        return tmp;  
    }  
};
```

```cpp
ostream& operator<<(ostream& ostr, const SpreadsheetCell& cell)
{
	ostr << cell.getValue();
	return ostr;
}
istream& operator>>(istream& istr, SpreadsheetCell& cell)
{
	double value;
	istr >> value;
	cell.set(value);
	return istr;
}
```

```cpp
template <typename T> 
T& Array<T>::operator[](size_t x)
{
	if (x >= m_size) {
		throw std::out_of_range { "Array subscript out of range" };
	}
	return m_elements[x];
}
```

Класс который перегружает оператор вызова функции называется функцианальным или функтором

```cpp
class FunctionObject
{
public:
	int operator() (int param); // Function call operator
	int doSquare(int param); // Normal method
};
// Implementation of overloaded function call operator
int FunctionObject::operator() (int param)
{
	return doSquare(param);
}

// Implementation of normal method
int FunctionObject::doSquare(int param)
{
	return param * param;
}
int main()
{
	int x{ 3 }, xSquared, xSquaredAgain;
	FunctionObject square;
	xSquared = square(x); // Call the function call operator.
	xSquaredAgain = square.doSquare(x); // Call the normal method.
}
```

```cpp
template <typename T> 
class Pointer
{
public:
	// Omitted for brevity
	T& operator*() { return *m_ptr; }
	const T& operator*() const { return *m_ptr; }
	// Omitted for brevity
	// Omitted for brevity
	T* operator->() { return m_ptr; }
	const T* operator->() const { return m_ptr; }
	// Omitted for brevity
private:
	T* m_ptr { nullptr };
};
```

```cpp
SpreadsheetCell::operator double() const
{
	return getValue();
}

SpreadsheetCell cell { 1.23 };
double d1 { cell };
```

```cpp
SpreadsheetCell::operator void*() const { return m_ptr; }
SpreadsheetCell::operator bool() const { return m_ptr != nullptr; }
//либо так, либо так

void process(Pointer<SpreadsheetCell>& p)
{
	if (p != nullptr) { cout << "not nullptr" << endl; }
	if (p != NULL) { cout << "not NULL" << endl; }
	if (p) { cout << "not nullptr" << endl; }
	if (!p) { cout << "nullptr" << endl; }
}

int main()
{
	Pointer<SpreadsheetCell> smartCell { nullptr };
	process(smartCell);
	cout << endl;
	Pointer<SpreadsheetCell> anotherSmartCell { new SpreadsheetCell { 5.0 } };
	process(anotherSmartCell);
}
/*
	nullptr
	not nullptr
	not NULL
	not nullptr
*/
```

# Перегрузка пользовательских литеральных операторов
Мы можем перегружать [[Литералы]], если они начинаются с подчеркиваний. Литеральный оператор может работать в двух режимах:
1. raw mode - ваш оператор принимает последовательность символов
	1. Передаем 123 - '1', '2', '3'
	2. Передаем 0x23 - '0', 'x', '2', '3'
	3. Передаем 3.14 - '3', '.', '1', '4'
2. cooked mode - ваш оператор принимает определенный интерпретируемый тип
	1. Передаем 123 - 123 число типа int
	2. Передаем 0x23 - 35 число типа int
	3. Передаем 3.14 - 3.14 число типа float

## Cooked mode literal operator
Этот оператор должен иметь один из следующих признаков:
1. Обработка число значений - 1 параметр типа `unsigned long long, long double, char, wchar_t, char8_t, char16_t, or char32_t`
2. Обработка строк - 2 параметра, первый - массив символом, второй - длина. `(const char* str, size_t len)`

```cpp
complex<long double> operator"" _i(long double d)
{
	return complex<long double> { 0, d };
}

string operator"" _s(const char* str, size_t len)
{
	return string(str, len);
}

int main()
{
	complex<long double> c1 { 9.634_i };
	auto c2 { 1.23_i }; // c2 has as type complex<long double>

	string str1 { "Hello World"_s };
	auto str2 { "Hello World"_s }; // str2 has as type string
}
```

## Raw-Mode Literal Operator
Этот оператор требует одного параметра `const char*`, он работает только с нестроковыми литералами
```cpp
complex<long double> operator"" _i(const char* p)
{
	return complex<long double>{stod(p) };
}
int main()
{
	complex<long double> c1{ 9.634_i };
	auto c2{ 1.23_i }; // c2 has as type complex<long double>
}
```

## Стандартные литералы
| Литерал               | Возвращаемый тип                                                     | Пример                          |
| --------------------- | -------------------------------------------------------------------- | ------------------------------- |
| s                     | string                                                               | auto myString {"Hello"s };      |
| sv                    | string                                                               | auto myStringView {"Hello"sv }; |
| h, min, s, ms, us, ns | chrono::duration                                                     | auto myDuration{ 42min };       |
| i, il, if             | `complex<T>` with T equal to double, long double, float respectively | auto myComplexNumber { 1.3i };  |
