# Полиморфизм
## virtul && override
```cpp
class animal{
public:
// Каждое животное по своему издает голос, чтобы не писать большую цепочку if по мере добавления новых животных можно сделать метод виртуальным и определять его в классе-наследнике, также напишем override, если мы не определим этот класс программа не скомпилируется, т.е. мы избежим потенциальной ошибки, когда мы либо забыли его определить, либо изменили название функции
	vritual void Voice() const = 0 
}//=0 означат что метод Voice является чисто абстрактным, это означает определение в каждом классе потомка.
//Если вместо этого написать фигурные скобки и в классе потомке не будет переопределен этот метод, то при ообращение объекта потомка к данному методу, вызовет метод базового класса
class Cat : public animal
{
public:
	void Voice() const override{ cout << "Meow"; }
};
```

Почему это еще полезно? Позволяет вызывать метод производных классов через ссылку на базовый класс.

```cpp
void MakeSound(Animal& a)
{
	a.Voice();
}

int main()
{
	Cat c;
	MakeSound(c);
}
```

Если в функции MakeSound убрать ссылку, то программа не скомпилируется, поскольку компилятор подумает, что раз мы передаем не по ссылке, значит мы хотим создать объект базового класса, а мы не можем создавать объекты базового класса поскольку он абстрактный(один из методов чисто виртуальный).

Если функция MakeSound определить в базовом классе, то все будет хорошо. Но функция Voice будет вызываться у базового класса, а не у потомка потому что при передаче по значению мы теряем всю информацию о потомке, и у нас сохраняется информация только о базовом классе. Поэтому если мы будем передавать объекты по значению, то потеряем смысл виртуальных методов, поэтому всегда стоит передавать по ссылке.