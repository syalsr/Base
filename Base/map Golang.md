# map Golang
Отображение из ключа в значение - структура данных представляет из себя [[Hash tables]].
1. У всех ключей один тип
2. У всех значений один тип
3. Тип ключа может быть отличен от типа значения

```go
var users map[string]int //но так не стоит делать, т.к. мы инициализируем его нулем(nil), а мапа это ссылка на хеш таблицу, а наша ни на что не указывает, в результате при работе с ней мы получим ошибку
// string - ключ, int - значения

//Правильнее так
m1 := make(map[int]int)
m2 := map[int]int{ 
	// Пары ключ:значение указываются при необходимости 
	12: 2, 
	1: 5, 
}
```


```go
fmt.Println(m[12]) // 2
delete(m, 12) // Удаление элемента по ключу 12 
fmt.Println(m) // map[1:5]
```

Все эти операции безопасны, даже если элемент в отображении отсутствует: при использовании ключа, которого нет в отображении, поиск возвращает нулевое значение соответствующего типа:
```go
m := make(map[int]int) 
fmt.Println(m[12]) // 0 
delete(m, 12) 
fmt.Println(m) // map[]

m := map[int]int{ 
	1: 10, 
} 
if value, inMap := m[1]; inMap { 
	fmt.Println(value) // 10 
} 
if value, inMap := m[2]; inMap { 
	fmt.Println(value) // Условие не выполняется 
}
```

Оператор `[]` вторым значением возвращает логическое значение, показывающее, имеется ли данный элемент в отображении.

```go
m := map[int]int{ 1: 10, 2: 20, 3: 30, }
for key, value := range mapName { //перебираем всю мапу
	fmt.Println(key, value) 
}
1 10
2 20
3 30
```