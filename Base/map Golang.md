# map Golang
Отображение из ключа в значение - структура данных представляет из себя [[Hash tables]].
1. У всех ключей один тип
2. У значений могут быть разные типы, если сделаем так `make(map[int]interface{}`
3. Тип ключа может быть отличен от типа значения

```go
var users map[string]int //но так не стоит делать, т.к. мы инициализируем его нулем(nil), а мапа это ссылка на хеш таблицу, а наша ни на что не указывает, в результате при работе с ней мы получим ошибку
// string - ключ, int - значения

//Правильнее так
m1 := make(map[int]int)
m2 := map[int]int{ 
	// Пары ключ:значение указываются при необходимости 
	12: 2, 
	1: 5, 
}
m2[1] = 2//перезапись 
```


```go
fmt.Println(m[12]) // 2
delete(m, 12) // Удаление элемента по ключу 12 
fmt.Println(m) // map[1:5]
```

Все эти операции безопасны, даже если элемент в отображении отсутствует: при использовании ключа, которого нет в отображении, поиск возвращает нулевое значение соответствующего типа:
```go
m := make(map[int]int) 
fmt.Println(m[12]) // 0 
delete(m, 12) 
fmt.Println(m) // map[]

m := map[int]int{ 
	1: 10, 
} 
if value, inMap := m[1]; inMap { 
	fmt.Println(value) // 10 
} 
if value, inMap := m[2]; inMap { 
	fmt.Println(value) // Условие не выполняется 
}
```

Оператор `[]` вторым значением возвращает логическое значение, показывающее, имеется ли данный элемент в отображении.

```go
m := map[int]int{ 1: 10, 2: 20, 3: 30, }
for key, value := range mapName { //перебираем всю мапу
	fmt.Println(key, value) 
}
1 10
2 20
3 30
```

read,del,create,find O(n), но в среднем O(1)

```go
type hmap struct {
	//Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
	//Make sure this stays in sync with the compiler's definition.
	count int // # live cells == size of map. Must be first (used by len() builtin)
	flags uint8
	B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
	hash0 uint32 // hash seed
	buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
	nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated)
	extra *mapextra // optional fields
}
```

Мапа в Го представляет из себя классическую хеш-таблицу - ключ-значение. В нее можно писать, удалять или искать данные. Мапа тоже передается всегда **по значению.**

Это просто **указатель на** **структуру hmap**. Это и является ответом на вопрос, почему при том, что мапа передается в функцию по значению, сами значения, лежащие в ней меняются — все дело в указателе. Так же структура hmap содержит в себе следующее: **количество элементов, количество «ведер»** (представлено в виде логарифма для ускорения вычислений), **seed** для рандомизации хэшей, всякие **служебные поля** и главное **указатель на buckets, где хранятся значения**.

![[../Files/Pasted image 20220928220212.png]]

**Поле buckets — хранилище пар ключ-значение**, таких «ведер» несколько, **в каждом лежит 8 пар**. Сначала в «ведре» лежат слоты для **дополнительных битов хэшей** (e0..e7 названо e — потому что extra hash bits). Далее лежат **ключи и значения как** сначала **список всех ключей, потом список всех значений**. По **хэш функции** определяется **в какое «ведро»** мы кладем **значение**, **внутри каждого «ведра» может лежать до 8 коллизий**, в **конце каждого «ведра» есть указатель на дополнительное**, если вдруг предыдущее **переполнилось**.

Если в каждом **«ведре» в среднем более 6,5 элементов**, происходит **увеличение массива buckets**. При этом выделяется **массив в 2 раза больше**, а **старые данные копируются в него маленькими порциями каждые вставку или удаление**, чтобы **не** **создавать** очень крупные **задержки**. Поэтому все операции будут чуть медленнее в процессе эвакуации данных. **После успешной эвакуации** начинают использоваться **новые данные**.

**Нельзя брать ссылку на объект мапы** - представьте, что мы взяли адрес значения, а потом мапа выросла, выделилась новая память, данные эвакуировались, старые удалились, указатель стал неправильным, поэтому такие операции запрещены.