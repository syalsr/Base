# Чем хороша виртуальность
Ничем.

Хорошо если нам придется разыменовывать только один указатель, а если у нас будет множественное наследование, виртуальное наследование, он будет несколько раз разыменовывать их, ходить туда сюда по таблицам, производительность значительно снизится.

# pure virtual function call

```cpp
struct Base {  
    Base() { unsafe(); }//pure virtual method called     
    Base() { doIt(); }//варнинги call to pure virtual member function 'doIt' has undefined behavior; overrides of 'doIt' in subclasses are not available in the constructor of 'Base'     
    //pure virtual method called  
    Base() { safe(); }  //Base    
					    //Derived
	void basesafe() { safe(); }  
    virtual void safe() { std::cout << "Base\n"; } // ok invocation    
	void unsafe() { doIt(); }                      // PVC invocation    
	virtual void doIt() = 0;  
};  
  
struct Derived : public Base {  
    void safe() override { std::cout << "Derived" << std::endl; }  
    void doIt() override { std::cout << "Derived::doit" << std::endl; }  
};  
  
int main() {  
    Derived d;  
    d.basesafe();  
}
```

Исходя из этого, стоит избегать вызовов функций в конструкторах не final классах.

При вызове в конструкторе `safe()` или `unsafe()` программа компилируется, но в первом она как и ожидается, хорошо отработает, во втором случае, она только в ран тайме понимает, что произойдет вызов чисто виртуальной функции, из-за того что мы вложили функцию в функцию, добавили уровень вложенности. В случае же прямого вызова `doIt()` программа понимает неладное на этапе компиляции.

# Не стоит использовать аргументы по умолчанию в виртуальных функциях
```cpp
struct Base {  
    virtual int foo(int a = 14) { return a; }  
    virtual ~Base() {}  
};  
  
struct Derived : public Base {  
    int foo(int a = 42) override { return 2 * a; }  
};  
  
int main() {  
    Base *pb = new Derived{};  
    std::cout << pb->foo() << std::endl;//выводится 28, т.к. в виртуальной таблице нет места для аргументов по умолчанию, аргументы связываются статически, она вызывает производную функцию, но со значением аргумента базового класса. Можно сделать каст, чтобы использовать аргумент по умолчанию 42
    delete pb;  
}
```

Если нам все же нужны аргументы по умолчанию, можно использовать идиому NVI [[Особые случаи при переопределения методов#Метод базового класса является приватным]]