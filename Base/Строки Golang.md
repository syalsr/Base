# string
Строка — это неизменяемая последовательность байт, которая может быть пустой.
```go
type string struct {
	str *byte
	len int
}
```

Важно заметить, что длина строки ≠ количеству символов. Длина строки это всегда количество байт в самой строке. Но почему?

Для создания строк, используются символы, которые в свою очередь берутся из словарей. Эти словари представляют собой карту из данных ключ-значение, где ключ это кодировка в байтах, а значение и есть сам символ. Так же такие словари называют кодировками.

Таких кодировок существует достаточно большое множество, но наиболее популярным является UTF-8. В этой кодировке для кодирования символа используется от 1 до 4 байт.

```
w - 01110111            м - 11010000 10111100
o - 01101111            и - 11010000 10111000
r - 01110010            р - 11010001 10000000
l - 01101100
d - 01100100
```

Для латиницы - 1 байт
Для кириллицы - 2 байта
Для китайских символов - 3 байта

Стоит обратить внимание, что последовательность бит символов латиницы начинаются с 01xxxxxx, а кириллицы с 110xxxxxxx. Эти символы в начале, называются маркерами и используются для того, чтобы сказать интерпретатору, что следующий за этим байтом байт является продолжением.

Все байты, которые начинаются с маркера 10xxxxxx, являются продолжением какой-то последовательности.

Для хранения любого символа из строки используются байты, эти символы могут иметь разное количество байтов, поэтому длина строки это всегда длина количество байт самой этой строки. Если бы мы могли менять что-то в последовательности байт, то велик шанс получить не то, что мы ожидали. То есть можно случайно изменить “хвост” какого-то символа и получить сломанный символ или неправильно переделать первый байт в символе.

Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов `Hello World`. Различие между ними в том, что строки в двойных кавычках позволяют использовать [[Escape sequence]].
Go поддерживает два вида строк. Строка закрытая в двойные кавычки является интерпретируемой и может обрабатывать [[Escape sequence]]. Строка закрытая в одинарные обратные кавычки является не интерпретируемой и не обрабатывает различные символы.
```go
st := "Hello\n"
str := `Hello`

rw := "мир"

fmt.Println(len(rw))         // 6
fmt.Println(len([]rune(rw))) // 3
```

По строкам можно итерироваться с помощью for-range:
```go
rw := "мирabcмир"  
  
for i, v := range rw {  
   fmt.Printf("%d: %s, %d \n", i, string(v), v)  
}  
  
0: м, 1084  
2: и, 1080  
4: р, 1088  
6: a, 97  
7: b, 98  
8: c, 99  
9: м, 1084  
11: и, 1080  
13: р, 1088
```

Когда мы итерируемся по строке с помощью for-range, мы итерируемся по символам приведенными к типу rune.

Строки поддерживают проверку на равенство и неравенство, а вот проверки <> со строками уже не дадут нужного нам результата, т.к. сравнивать Go будет байты, а не символы, т.е. результат для нас может быть не тот, что мы ожидаем (сравнивается не длина строк):

```go
func ExampleEqualString() {
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")

	fmt.Printf("\"Строка1\" > \"Строка2\": %v", "Строка1" > "Строка2")

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false
}
```

#do/important_start https://habr.com/ru/post/307554/

# Reader && Writer
```go
func NewReader(b []byte) *Reader 
func NewReader(s string) *Reader
```

```go
var buf bytes.Buffer buf.WriteString("foo") 
http.Post("http://example.com/", "text/plain", &buf)
```

Такой подход требует лишних аллокаций памяти и может быть медленным. Гораздо эффективней будет использовать [strings.Reader](https://golang.org/pkg/strings/#Reader):
```go
r := strings.NewReader("foobar") 
http.Post("http://example.com", "text/plain", r)
```

Этот способ работает также когда у вас есть много строк или слайсов байт, которые можно объединить с помощью io.MultiReader:
```go
r := io.MultiReader(
        strings.NewReader("HEADER"),
        bytes.NewReader([]byte{0,1,2,3,4}),
        myFile,
        strings.NewReader("FOOTER"),
)
```

