# string
Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов `Hello World`. Различие между ними в том, что строки в двойных кавычках позволяют использовать [[Escape sequence]].

Строка представляет собой неизменяемую последовательность байтов. Из этого следует ряд выводов:
-   к строке применимы операции, применимые к массивам и срезам;
-   чтобы изменить строку, необходимо создать новую строку;
-   мы можем итерироваться по строке как и по всякой последовательности, но итерируясь по строке, мы будем итерироваться по байтам, составляющим строку, а не по символам;
-   мы можем определить в строке подстроку.

```go
func ExampleString() {  
   // Создадим строковый литерал s, значение которого "Это строка".  
   // Строка состоит из 10 символов.   var s string = "Это строка"  
  
   // Однако длина строки len(s) составит 19 байт, т.к. использованные кирилические символы  
   // занимают 2 байта, а пробел занимает 1 байт.   fmt.Printf("Длина строки: %d байт\n", len(s))  
   // Длина строки: 19 байт  
  
   // Посмотрим как взять подстроку   fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])  
   // Напечатаем только второе слово в кавычках: "строка"  
  
   /*      Попробуем изменить что-то встроке:      s[3] = 12      Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.   */  
   // "Изменим строку", создав новую   s = s + " Новая строка"  
   fmt.Printf("%v\n", s)  
   // Это строка Новая строка  
  
   // А теперь проитерируемся по этой строке   for _, b := range s {  
      fmt.Printf("%c ", b)  
   } //Э т о   с т р о к а   Н о в а я   с т р о к а  
   fmt.Println(" ")  
   for idx, b := range s {  
      fmt.Print(s[idx], b, " ")  
   }//208 1069 209 1090 208 1086 32 32 209 1089 209 1090 209 1088 208 1086 208 1082 208 1072 32 32 208 1053 208 1086 208 1074 208 1072 209 1103 32 32 209 1089 209 1090 209 1088 208 1086 208 1082 208 1072   
fmt.Print("\n")  
}
```

Строки поддерживают проверку на равенство и неравенство, а вот проверки <> со строками уже не дадут нужного нам результата, т.к. сравнивать Go будет байты, а не символы, т.е. результат для нас может быть не тот, что мы ожидаем (сравнивается не длина строк):

```go
func ExampleEqualString() {
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")

	fmt.Printf("\"Строка1\" > \"Строка2\": %v", "Строка1" > "Строка2")

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false
}
```

Go содержит большое количество функций для работы со строками в пакете `strings` , кратко рассмотрим основные: 

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(    
        // Содержится ли подстрока в строке    
        strings.Contains("test", "es"), 
        // результат: true

        // Кол-во подстрок в строке
        strings.Count("test", "t"),
        // результат: 2

        // Начинается ли строка с префикса       
        strings.HasPrefix("test", "te"), 
        // результат: true

        // Заканчивается ли строка суффиксом
        strings.HasSuffix("test", "st"), 
        // результат: true

        // Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
        strings.Index("test", "e"), 
        // результат: 1

        // объединяет массив строк через символ
        strings.Join([]string{"hello","world"}, "-"),
        // результат: "hello-world"

        // Повторяет строку n раз подряд
        strings.Repeat("a", 5), 
        // результат: "aaaaa"

        // Функция Replace заменяет любое вхождение old в вашей строке на new
        // Если значение n равно -1, то будут заменены все вхождения.
        // Общий вид: func Replace(s, old, new string, n int) string
        // Пример:
        strings.Replace("blanotblanot", "not", "***", 	-1),
        // результат: "bla***bla***"
 
        // Разбивает строку согласно разделителю
        strings.Split("a-b-c-d-e", "-"), 
        // результат: []string{"a","b","c","d","e"}

        // Возвращает строку c нижним регистром
        strings.ToLower("TEST"), 
        // результат: "test"

        // Возвращает строку c верхним регистром
        strings.ToUpper("test"), 
        // результат: "TEST"

        // Возвращает строку с вырезанным набором
        strings.Trim("tetstet", "te"),
        // результат: s
        var s string = strings.Trim("tetstetstet", "te")
		//результат stets
    )
}
```

#do/continue разобраться с []rune и []byte