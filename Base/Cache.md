# Cache
Как мы уже поняли, доступ к памяти занимает какое-то время, во время которого процессор простаивает, для лучше работоспособности придумали кэш, память которая находится рядом с процессором.

![[../Files/Pasted image 20220419041047.png]]

Какие есть варианты использования SRAM и DRAM
1. Разделить оперативную память на 2 части, операционная система должна сама решать в какую часть лучше класть данные, возникают вопросы доступа к памяти
2. Дать процессору управлять SRAM и поместить его рядом

И правильный вариант - 2. В данном варианте - мы создаем копии данных и помещаем наиболее часто используемые в кэш для работы процессора с ними. Кэш разделяется на кэш для данных и для команд.
1. В случае с данными есть вероятность, что рядом стоящие данные понадобятся в скором времени
2. В случае с командами, например, если у нас в программе в цикле вызывается какая-то функция, то ее вызов помещается в кэш, чтобы n раз не ходить далеко.

![[../Files/Pasted image 20220419044028.png]]

Чем выше уровень, тем больше памяти и ниже скорость.
1. L1d - кэш первого уровня для данных
2. L1i - кэш первого уровня для инструкций

## Как работает кэш-память высокого уровня 
По умолчанию, данные с которыми работает процессор находятся в кэше, за исключением тех, которые нельзя поместить туда, но об этом не стоит думать.

Если процессору требуется  какое-то слово, он сначала ищет его в кэш-памяти, если не находит, идет в основную память и копирует всю линию в L1d. После, изменяет данные, если такую строку обратно не записывают в память - она становится грязной, как только запись произошла, флаг, указывающий на то что она грязная, сбрасывается.

Для того, чтобы в кэш-память можно было загрузить новые данные, почти всегда сначала необходимо освободить место. При удалении из кэш памяти L1d кэш-строка перемещается вниз — в кэш-память L2 (в которой используется тот же самый размер кэш-строки). Конечно, это означает, что в кэш-памяти L2 должно быть место. А это, в свою очередь, может быть причиной перемещения содержимого в кэш-память L3 и, в конце концов, в основную память - эта модель памяти называется эксклюзивной или исключающей моделью. Каждое последующее выталкивание содержимого из кэш-памяти будет все более дорогостоящим.

Есть также инклюзивна или включающая модель при которой слово находящееся в L1d находится одновременно в L2, поэтому удаление из L1d происходит быстро. Преимущество эксклюзивной в том, что кэш-линия загружается только в 1 кэш.

В системах с симметричной многопроцессорной архитектурой(SMP) кэш-память процессоров не может работать независимо, в любой момент времени процессоры должны видеть одно и тоже содержимое памяти. Поддержка этого состояния называется **когерентностью кэша**. Если процессор видит свою собственную кэш-память и основную память, он не должен видеть содержимое грязных кэш-строк в других процессорах. Реализация прямого доступа к кэш-памяти одного процессора из другого процессора является чрезвычайно дорогой и чрезвычайно узкой по производительности. Вместо этого, процессоры просто узнают, когда другой процессор хочет прочитать или записать определенную кэш-строку.

Если обнаружен доступ на запись и у процессора в его кэш-памяти есть просто копия кэш-строки, то эта кэш-строка помечается как неверная. Будущие обращения к ней потребуют ее перезагрузки. Обратите внимание, что доступ на чтение из другого процессора не потребует помечать ее как неверную, так что вполне может быть сразу несколько чистых копий кэш-строки.

## Запись данных
Есть два варианта записи изменений кэша:
1. Прямая запись - если изменяется кэш линия, то процессора сразу изменяет и данные в основной памяти, не очень эффективно, т.к. при каждом изменении придется изменять данные в памяти.
2. Обратная запись - если изменяется кэш линия, данные не сразу изменяются в основной памяти, линия помечается как измененная, если она удаляется из кэша с флагом измененности, то процессора записывает обновленные данные в основную память. Проблема в том, что если у нас есть несколько процессоров или ядер, нужно обеспечить доступ в обновленным кэш данным всем процессам.

Для реализации обратной записи разработали протокол MESI - протокол назван в честь 4 состояний кэш линии:
1. Modified - Модифицированный - локальный процессора изменил кэш линию, подразумевается, что в кэше находится только одна копия кэш линии
2. Exclusive - Эксклюзивный - кэш-линия не изменена, но известно, что она не загружена ни в какую-либо кэш-память другого процессора
3. Shared - Разделяемый - кэш-линия не изменена,  но она может быть в кэш-памяти какого-нибудь другого процессора
4. Invalid - Недействительный - кэш-линия недействительная, т.е. не используется.

![[../Files/Pasted image 20220419125929.png]]

Изменение состояний происходит без особых затрат за счет прослушивания или перехвата сигналов, что выполняется другими процессорами. Некоторые операции, которые выполняет процессор, анонсируются на внешних контактах и, следовательно, за пределами процессора становится известно о том, как происходит обработка кэш-памяти процессора.

1. Первоначально все кэш-строки пусты, а, следовательно, и недействительны (состояние Invalid). 
2. Если данные будут загружены для записи, то кэш-строка станет модифицированной. 
3. Если данные загружаются для чтения, то новое состояние зависит от того, будет ли та же кэш-строка также загружена другим процессором. 
	1. Если будет, то процессор отправляет другому процессору кэш-линию, новое состояние будет разделяемым
	2. В противном случае - эксклюзивным.
4. Если второй процессор хочет изменить кэш-линию, то первый процессор посылается кэш-линию и локально помечает кэш-линию как недействительную - эта операция называется  Request For Ownership(RFO) - выполнение этой операции в кэше последнего уровня является дорогим.
5. Если кэш-линия находится в разделяемом состоянии и локальный процессор выполняет чтение, то нет необходимости изменять состояние.
	1. Если в кэш-линии происходит локальная запись, то кэш-линия может использоваться, но ее состояние изменится на модифицированное, при этом все копии кэш-линии в других процессорах помечаются как недействительные. Таким образом, операция записи с помощью сообщения RFO должна оповестить другие процессоры об инвалидации кэш-линии
6. Эксклюзивное состояние идентично разделяемому состоянию с одним отличием - сообщения о локальных операциях записи не должны передаваться по шине

Есть две ситуации, когда необходимы сообщения RFO:
1. Поток мигрирует с одного процессора на другой, и все кэш-строки должны быть сразу перенесены на новый процессор.
2. Кэш-строка действительно необходима в двух разных процессорах. В меньшей степени то же самое верно для двух ядер на одном процессоре. Затраты только немного меньше. Вероятно, что сообщение RFO будет отправляться много раз.


#do/start https://www.youtube.com/c/АПСПопов/videos
https://github.com/MPSU/APS-info