# Введение в арифметику указателей
С помощью арифметики можно обращаться к различным ячейкам нашей памяти. Если мы к указателю `T*` прибавим `N`, то перейдем на $N*sizeof(T)$ вперед. Если мы выделили память с помощью `new`, то таким образом обратимся к чужой памяти, что породит UB, если с помощью `new[]`, то сможем удобно перемещаться по массиву

![[../Files/Pasted image 20220216120737.png]]

![[../Files/Pasted image 20220216122555.png]]

```cpp
T& operator[] (size_t index) { 
	return ∗( data + index); //data + index * sizeof(T)
	// либо
	return data[index];
}

int main () { 
	SimpleVector sv(5); 
	for (int i = 0; i < 5; ++i) { 
		sv[i] = 5 − i; 
	} 
	for (int i = 0; i < 5; ++i) { 
		cout << sv[i] << ' '; 
	} 
} 
// 5 4 3 2 1
```

Также можем попытаться обратиться к элементу за границей массива.

```cpp
SimpleVector sv (5); 
cout << sv [12] << endl; 
// 7827296
```

Язык С++ не контролирует доступ к данным, которые мы осуществляем через указатель.

Локальные переменные хранятся на стеке. Стек – это область оперативной памяти, поэтому у его элементов тоже есть адрес. Его можно получить с помощью оператора &:

```cpp
int main () { 
	int x = 5; 
	int∗ y = &x; //y хранит адресс переменной x
	*y = 7; // x = 7
}
```

![[../Files/Pasted image 20220216122858.png]]

```cpp
int main () { 
	int a = 43; 
	int b = 71; 
	int c = 89; 
	cout << ∗(&b − 1) << ' ' << ∗(&b + 1);// 43 89
}
```

Мы можем вместо передачи целого массива в функцию, передавать указатель на первый элемент и его размер для эффективности

```cpp
void doubleInts(int* theArray, size_t size)
{
	for (size_t i { 0 }; i < size; i++) { theArray[i] *= 2; }
}
// т.к. мы работаем с указателем на массив, то мы изменяем его самого, а не копию
size_t arrSize { 4 };
int* freeStoreArray { new int[arrSize]{ 1, 5, 3, 4 } };
doubleInts(freeStoreArray, arrSize);
delete [] freeStoreArray;
freeStoreArray = nullptr;

int stackArray[] { 5, 7, 9, 11 };
arrSize = std::size(stackArray); // Since C++17, requires <array>
//arrSize = sizeof(stackArray) / sizeof(stackArray[0]); // Pre-C++17, see Ch1
doubleInts(stackArray, arrSize);//имя массива является указателем на его первый элемент
doubleInts(&stackArray[0], arrSize);
```

```cpp
void doubleInts(int theArray[], size_t size)
{
	for (size_t i { 0 }; i < size; i++) { theArray[i] *= 2; }
}
//хоть здесь уже не указатель, но изменять мы будем оригинал
//передавая массив, все равно передается указатель - это сделано для эффективности
```

Число у массива в квадратных скобках в функциях игнорируется, следующие объявления идентичны:

```cpp
void doubleInts(int* theArray, size_t size);
void doubleInts(int theArray[], size_t size);
void doubleInts(int theArray[2], size_t size);
```

Можно также передавать ссылку на массив, но работает только с массивом на стеке

```cpp
void doubleIntsStack(int (&theArray)[4]);
template<size_t N>
void doubleIntsStack(int (&theArray)[N])//компилятор сам выведет размер массива
{
	for (size_t i { 0 }; i < N; i++) { theArray[i] *= 2; }
}
```

Допустим, у нас есть функция которая работает со строками в стиле C(`const char*`) и делает все буквы заглавными, мы можем передать туда указать на любой элемент вот так:

```cpp
const char* str = "Hello, world\0";
toUppercase(str);//HELLO, WORLD
toUppercase(str+7);//Hello, WORLD
```

# Как обнаруживать утечки памяти в visual studio
```cpp
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>

#ifdef _DEBUG
#ifndef DBG_NEW
#define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
#define new DBG_NEW
#endif
#endif // _DEBUG

int main()
{
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	...
}
```