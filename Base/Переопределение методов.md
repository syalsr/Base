# Переопределение методов
Основная причина в наследование это добавление или замена базовой функциональности

## virtual
Помечаю методы как virtual, мы можем переопределить их в производном классе
```cpp
class Base
{
public:
	virtual void virt() { cout << "Base over" << endl; }
	virtual void not_virt() { cout << "Base not virt" << endl; }
protected:
	int m_protectedInt{ 0 };
private:
	int m_privateInt{ 0 };
};

class Derived : public Base
{
public:
	virtual void virt() { cout << "Derived virt" << endl; }
	virtual void someOtherMethod() {}//производные также могут создавать свои вирутальные методы, а не только переопределять
	//делаем их virtual чтобы переопределить в производном от этого класса.
};
int main()
{
	Derived derived;
	derived.not_virt();
	derived.virt();
	//output
	//Base not virt
	//Derived virt	
}
```

Если мы не нашли подходящего метода в производном классе, то мы используем метод из базового.

```cpp
class Base
{
public:
	void go() { cout << "go() called on Base" << endl; }
};
class Derived : public Base
{
public:
	void go() { cout << "go() called on Derived" << endl; }
};
int main()
{
	Derived myDerived;
	Base& ref{ myDerived };
	ref.go();//go() called on Base
}
```

Поскольку мы не определили наш базовый метод как virtual, то компилятор и не ищет переопределенный метод.

## virtual table
Статическое связывания(статическая типизация)
```cpp
class A
{
public:
	void say();
}
class B : public A
{
	void say();
}
void say(A a)
{
	a.say();
}

B b;
say(b);
```
При статическом связывании компилятор на этапе компиляции знает какой метод будет вызвана в функции say, метод класса A, поскольку мы не имеет виртуальных методов. Т.е. обычные функции связываются статически. Даже если физически они приходят из динамических библиотек или являются позиционно независимыми и адресуются через PLT, это неважно

Динамическое связывание состоит в том, чтобы во время выполнения программы выбирать какой метод вызывать, ключевое слово virtual обеспечивает динамическое связывание, для определения нужной функции компилятор строит виртуальную таблицу - это специальная область памяти.

Каждый класс содержащий хотя бы один виртуальный метод имеет vtable, и каждый объект этого класса имеет указатель на его таблицу. Эта таблица содержит указатель на реализацию виртуального метода. Когда объект вызывает метод, указатель следует в таблицу и выполняется соответствующая версия метода  на основе фактического типа во время выполнения. В этом и состоит суть динамического связывания.

```cpp
class Base
{
public:
	virtual void func1();
	virtual void func2();
	void nonVirtualFunc();
};
class Derived : public Base
{
public:
	void func2() override;
	void nonVirtualFunc();
};
int main()
{
	Base myBase;
	Derived myDerived;
}
```

![[Drawing 2022-05-08 14.23.26.excalidraw]]

Следует избегать virtual методов, если это необходимо так как оно накладывает дополнительные расходы на память и производительность. Если у нас один экземпляр класса, то расходы не значительны, а если их миллион?


