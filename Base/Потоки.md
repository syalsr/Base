# Потоки
У каждого [[Процессы|процесса]] есть свое адресное пространство и минимум 1 поток управления, чем больше потоков, тем производительнее ПО. Каждый поток имеет свой стек.

# Применение потоков
1. Основная причина применения поток заключается в параллельном использовании нескольких функций одной программы. Допустим, мы хотим одновременно искать похожие слова, помещать их в буфер и печатать. С одним потоком все будет выполнять последовательно.
2. Потоки быстрее создаются и умирают по сравнению с процессами(10-100 раз).
3. Когда потоки работают в рамках одного ЦП они не приносят прироста производительности, но когда выполняются какие-то вычисления и значительная часть времени тратится на ожидание устройств ввода/вывода, наличие потоков позволяет этим действиям перекрываться во времени, ускоряя работу приложения.
4. Потоки полезны в системах с 2-мя и более процессами(ядрами).

# Классическая модель потоков
Когда многопоточный процесс выполняется на однопроцессорной системе, потоки выполняются сменяя друг друга.
Поскольку у потоков общее адресное пространство, они используются одни и те же глобальные переменные, поскольку поток имеет доступ к каждому адресу выделенной памяти, то он может считывать и изменять содержимое стека другого потока. В отличии от процессов, у поток нет никакой защиты.

У каждого потока свой стек, стек содержит по одной фрейму, фрейм содержит локальные переменные, процедуры и адрес возврата управления.

# Состояния потоков
У потока есть 4 состояния:
1. Выполняемый поток расходует ресурсы ЦП и является активным в данный момент.
2. Заблокированный поток ожидает событие которое его разблокирует(считывание данных)
3. Готовый поток планируется к выполнению и будет выполнен как только подойдет его очередь.

Переходы аналогично как и у [[Процессы#Состояния процессов|процесса]]

# Реализация потоков
Потоки можно реализовать в пользовательском пространстве(user-level-threads ULT) и в пространстве ядра(kernel-level-threads KLT).

## User level threads
При этом подходе реализацию поток берет на себя программа, ядро об этом ничего не знает и думает, что приложение работает в однопоточном режиме.

**Преимущества:**
1.  Потоки можно реализовать даже, если ОС их не поддерживает.
2. Планирование производится в зависимости от специфики программы. Для одного приложения лучше один алгоритм, для другого другой.
3. Переключение потоков не включает в себя переход в режим ядра, т.к. структура данных потоков находится в одно адресном пространстве.

**Недостатки:**
1. В типичной ОС многие системные вызовы являются блокирующими $=>$ если поток вызовет блокирующий системный вызов, то заблокируется весь процесс.
2. При только таком подходе(без KLT) мы не сможем воспользоваться многопроцессорной технологией, поскольку каждый процесс закрепляется за одним процессором, поэтому несколько потоков не смогут выполняться одновременно.

## Kernel level threads
При этом подходе у ядра есть таблица потоков, в которой отслеживаются все потоки, имеющиеся в системе, управление потоков осуществляется ядром. Когда потоку необходимо создать или уничтожить поток, он обращается к ядру, которое создает или разрушает их путем обновления таблицы потоков. Планирование осуществляется ядром исходя из состояния потоков. При таком подходе мы избавляемся от 2-ух недостатков ULT
1. Ядро может одновременно осуществлять планирование работы нескольких потоков одного и того же процесса н нескольких процессорах
2. При блокировке одного потока, все потоки процесса не блокируются, ядро может выбрать для выполнения другой поток.

**Недостатки:**
1. При переключении потоков одного процесса приходиться переключаться в режим ядра.
2. Системные вызовы довольные затратны.

# Race condition
Случается, когда 2 потока изменяют одни и те же данные, для предотвращения подобных ошибок нужно [[mutex и lock_guard|блокировать]] критические секции - это секции, где происходит гонка данных

# Data race
Это борьба двух потоков за ячейку памяти без синхронизации.

# Dead lock
Потоки блокируют друг друга в результате программа работает бесконечно
#do/important_start найти пример
# Live lock
Как и с deal lock, потоки друг другу мешают, но в данном случае планировщик может все разрулить и какой-то начнет выполнения, но когда - неизвестно