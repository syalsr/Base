# Использование методов и глобальных функций
Всегда стоит использовать методы контейнеров нежели одноименные функции, поскольку глобальная функция не знает ничего не знает об устройстве контейнера, нежели метод написанный специально для данного контейнера.

# Deque
Двусторонняя очередь бывает из людей или запросов. Новые приходят в конец и удаляются из начала(или наоборот).

```cpp
d.push_back (x) // добавление в конец 
d.pop_back (x) // удаление из конца 
d.push_front (x) // добавление в начало 
d.pop_front (x) // удаление из начала 
d[i] // обращение к элементу по индексу
```
Зачем использовать? Если нужно работать с двумя концами.

В отличии от вектора элементы хранятся не по порядку, а блоками, следовательно инвалидации ссылок можно избежать.

![[../Files/Pasted image 20220216140656.png]]

В деке хранится вектор указателей на чанки(блоки), количество элементов и сдвиг.

![[../Files/Pasted image 20220216141001.png]]

Как тогда найти второй элемент? К сдвигу прибавляем индекс, т.е. нам нужен 4 элемент, размер блока 3, $4/3=1$, значит 1 чанк и там идем в элемент 4%3, то есть берем остаток от деления и получаем, что в первом блоке памяти нам нужен первый элемент.

В итоге, нет инвалидации ссылок, просто вставлять в начало и конец, но сложно интерироваться и получать элемент по индексу.

# Queue
Основана на деке, работает быстрее,  но операций меньше. Это именно односторонняя очередь

```cpp
q.push(x), q.pop(x) // вставляем в начало и удаляем из конца 
q.front (), q.back () // ссылки на первый и последний элементы очереди 
q.size (), q.empty () // размер и проверка на пустоту
```

# Stack
Позволяет лишь добавлять в конец и удалять из конца. Как вектор, но умеет меньше.

```cpp
st.push(x), st.pop(x) // вставляем в конец и удаляем из конца 
st.top () // ссылка на последний элемент 
st.size (), st.empty () // размер и проверка на пустоту
```

# List
Для каждого элемента свой блок памяти в которой хранится значение и адрес следующего элемента.
![[../Files/Pasted image 20220216143448.png]]

Если list двухсторонний, то хранится адрес предыдущего элемента.

![[../Files/Pasted image 20220216143504.png]]

С такой реализацией можно быстро удалять элементы из любой позиции, все указатели и итераторы останутся валидными, если элемент на который они указывали, не удалили.

Итог: лист эффективнее вектора в удалении, допустим мы удаляем элементы в цикле, чем меньше элементов за цикл удаляется тем list эффективнее.

# Array
Это вектор, но память выделяется на стеке, поэтому про объявлении мы должны указать тип и размер.

# String_view
string_view – это ссылка на где-то хранящийся диапазон символов(он работает не с итераторами, а с позициями). Допустим нам дана строка состоящая из пробелов и слов, нужно написать функцию которая возвращает вектор из этих строк

```cpp
string_view LeftSpace(string_view& s)
{
	while(!s.empty() && isspace(s[0]))
		s.remove_prefix(1);
}
vector<string_view> SplitIntoWords(string_view s)
{
	vector<string_view> result;
	LeftSpace(s); //убираем пробелы слева, если бы мы использовали string и итераторы, код бы значительно усложнился
	while(true){
		size_t space = str.find(' ');
		result.push_back(str.substr(0, space));

		if(space == s.npos)
			break;
		else
			s.remove_prefix(space + 1);
	}
	return result;	
}
```

Т.к. string_view это ссылка на где-то находящийся диапазон символов, то не стоит в функции принимать значение по ссылке, если в дальнейшем строка уничтожится, string_view будет не понятно на что указывать, лучше принимать по значению, т.е. копировать.

Т.к. string_view это ссылка на где-то находящийся диапазон символов, то не стоит в функции принимать string `vector<string_view> SplitIntoWords(const string& str)` поскольку строка на которую указывает str, может уничтожиться, а string_view это ссылка на символы этой строки, в таком случае на что они будут указывать? Так что лучше принимать string_view по значению.

# Ассоциативные контейнеры
Это контейнеры, которые хранят значения по различным ключам.

# Vector
```cpp
vector<int> v = {1,2,3};
```

При создание вектора из 3 чисел на стеке будет указатель на кучу, длина и capacity этого вектора. Capacity - доступное количество памяти.

![[../Files/Pasted image 20220216133815.png]]

Сейчас вектор полностью заполнен, если мы хотим добавить новое число, его capacity нужно увеличить, увеличится оно в 2 раза. То есть выделяет новый блок памяти из 6 int, копирует старые значения в новые ячейки.

![[../Files/Pasted image 20220216134117.png]]

Какой вывод можно сделать?

Если вы заранее знаете размер вектора, то лучше его указать, чтобы не было ненужных копирований элементов

Сейчас в векторе после элемента 4 хранятся мусорные значения(напомню capacity=6), если мы хотим очистить память от этих двух чисел, то можем использовать:

```cpp
v.shrink_to_fit();
```

## Инвалидация ссылок в векторе
```cpp
vector<int> v = {1,2,3};
int& first = v[0];
v.push_back(4);
cout << first; //теперь first не указывает на первый элемент вектора, поскольку после push_back выделился новый блок памяти и туда скопировались все элементы. Ссылка перестала быть валидной - инвалидировалась.
```

# map и set
map и set представляют из себя сбалансированное двоичное дерево поиска (красно-черное дерево).

* Двоичное дерево — у каждого узла дерева может быть не более двух потомков; 
* Поиска — объекты в дереве упорядочены. Все значения узлов поддерева, меньшие данного узла, попадает в его левое поддерево, а все значение большие данного узла — в правое. 
* Сбалансированное — для каждого узла высоты его левого и правого поддеревьев примерно равны. В некоторых реализациях, например, они могут отличаться не более чем на один.

Как работает поиск? Мы сравниваем значение с корнем, если значение меньше, чем значение в корне, то уходим в левое поддерево и т.д. по цепочке.

# unordered_map и unordered_set
Этот контейнер отличается от map, тем что здесь ключи не сортируются, соответственно если нам не важен порядок, то можем выбрать в этот контейнер для большей производительности.

unordered контейнеры используют хеш-функции для составления хеш-таблицы на основе которых хранятся данные. Допустим нам нужно хранить автомобильные номера, в таком случае хеш-функцией может выступать номер региона, если все номера будут одного региона, то будет крайне не производительно, а если мы будем умножать простое число на каждый элемент номера, то получится уникальное число.

Хеш-таблица состоит из нескольких корзин по которым раскладываются объекты на основе хеш-функции. Если корзина занята другим объектом, то происходит коллизия. Для разрешения данной проблем используется метод цепочек, корзина состоит из списка объектов, сначала проверяется, что объекта нет в корзине, потом он добавляется по цепочке. Чем длиннее цепочка, тем менее производительнее таблица.

Для того, чтобы цепочки в корзине были короткими при добавлении нового объекта может случиться рехеширование в результате чего итератор инвалидируются. Удалять итераторы можно не опасаясь за итераторы на другие элементы.

Если в ассоциативном контейнере мы используем пользовательский тип данных, то хеш-функцию должны написать сами. Для встроенных типов данных уже есть хеш-функции(`std::hash<double> dhash`)

```cpp
struct Plate { 
	char C1; 
	int Number; 
	char C2; 
	char C3;
	int Region; 
};
bool operator==(const Plate& l, const Plate& r) { 
	return (l.C1 == r.C1) && (l.Number == r.Number) && (l.C2 == r.C2) && (l.C3 == r.C3) && (l.Region == r.Region); 
}
struct PlateHasher {
	size_t x = 9973;
	size_t operator() (const Plate& p) const { 
		size_t result = x * x * ihash(p.Number) + x * ihash(p.Region) + x * chash(p.C1) + x * chash(p.C2) + x * chash(p.C3);
		return result;
	}
	hash<int> ihash;
	hash<char> chash;
};
int main() {
	unordered_set<Plate, PlateHasher> h_plates; 
}
```

# set && map
## merge && extract
```cpp
struct NCString : public string { 
	using string::string; 
	NCString(const NCString&) = delete; 
	NCString(NCString&&) = default; 
};
int main(){
	set<NCString> ss; 
	ss.insert("Aaa"); 
	ss.insert("Bbb"); 
	ss.insert("Ccc"); 
	for (const auto& el : ss) {
		cout << el << ’ ’; 
	} 
	cout << endl; 
	auto it = ss.begin();
	auto node = ss.extract(it); //перемещаем целый узел
	string& temp = node.value();
	temp[0] = tolower(temp[0]); 
	ss.insert(move(node));
}
```

```cpp
struct NCString : public string { 
	using string::string; 
	NCString(const NCString&) = delete; 
	NCString(NCString&&) = default; 
};
int main(){
	set<NCString> ss1;
	ss1.insert("Aaa"); 
	ss1.insert("Bbb"); 
	ss1.insert("Ccc"); 
	
	set<NCString> ss2; 
	ss2.insert("Xxx"); 
	ss2.insert("Yyy"); 
	ss2.insert("Zzz");
	//хотим слить два дерева, можно с помощью цикла и extract вставлять каждый узел, а можно одной функцией merge
	ss1.merge(ss2);
}
```

Тоже самое работает и со словарем