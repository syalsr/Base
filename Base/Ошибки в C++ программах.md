# Ошибки в C++ программах
## Введение
* Ошибки времени компиляции(compile-time errors). Это ошибки, обнаруженные компилятором. Их можно подразделить на категории в зависимости от того, какие правила языка он нарушают:
	* синтаксические ошибки;
	* ошибки, связанные с типами.
* Ошибки времени редактирования связей(link-time errors). Это ошибки , обнаруженные редактором связей при попытке объединить объектные файлы в выполнимый модуль.
* Ошибки времени выполнения(run-time errors). Это ошибки, обнаруженные проверками в работающей программе. Их можно подразделить на следующие категории:
	* ошибки, обнаруженные компьютером (аппаратным обеспечением и/или операционной системой) ;
	* ошибки, обнаруженные библиотекой (например, стандартной библиотекой С++);
	* ошибки, обнаруженные кодом пользователя.
* Логические ошибки(logic errors). Это ошибки , найденные программистом в поисках причины неправильных результатов.

## Источники ошибок
* Плохая спецификация. Если мы слабо представляем себе, что должна делать программа, то вряд ли сможем адекватно проверить все ее "темные углы" и убедиться, что все варианты обрабатываются правильно (т. е . что при любом входном наборе данных мы получим либо правильный ответ, либо осмысленное сообщение об ошибке).
* Неполные программы. В ходе разработки неизбежно возникают варианты, которые мы не предусмотрели. Наша цель - убедиться. что все варианты обработаны правильно.
* Непредусмотренные аргументы. Функции принимают аргументы . Если функция принимает аргумент, который не был предусмотрен, то возникнет проблема, как, например, при вызове стандартной библиотечной функции извлечения корня из - 1 . 2: sqrt ( -1 . 2) . Поскольку функция sqrt ( ) вычисляет квадратный корень от значения типа douЫe и возвращает результат типа douЫe. в этом случае она не сможет вернуть правильный результат. Такие проблемы обсуждаются в разделе 5 . 5 .3.
* Непредусмотренные входны.е данные. Обычно программы считывают данные (с клавиаrуры, из файлов, средствами графического пользовательского интерфейса, из сетевых соединений и т.д.). Как правило. программы предъявляют к входным данным много требований, например, чтобы было введено целочисленное значение. Но что если пользователь введет не ожидаемое целочисленное значение, а строку "Отвали! "? Этот вид проблем обсуждается в разделах 5.6.3 и 1 0 . 6 .
* Непредусмотренное состояние. Большинство программ хранит большое количество данных ("состояний"), предназначенных для использования разными частями системы. К их числу относятся списки адресов, каталоги телефонов или записанные в vector данные о температуре. Что если эти данные окажутся неполными или неправильными? В этом случае разные части программы должны сохранять управляемость. Эти проблемы обсуждаются в разделе 26.3.5.
* Логические ошибки. Это ошибки. когда программа просто делает не то, что от нее ожидается; мы должны найти и исправить эти ошибки. Примеры поиска таких ошибок приводятся в разделе 6 . 6 и 6.9.

## Ошибки времени компиляции
### Синтаксические ошибки
```cpp
int area(int length, int width);

int a1 = area(7; //Ошибка - пропущена скобка )
int a2 = area(7) //Ошибка - пропущена точка с запятой ;
```
При нахождение ошибки, компилятор может указать на строку которая не содержит ошибок, стоит проверить предшествующие строки программы.

Компилятор не знает, что именно вы пытаетесь сделать, потому что формулирует сообщения об ошибках с учетом того, что вы на самом деле сделали, а не ваших намерений. Например обнаружив ошибочное объявление переменной `a3`, компилятор вряд ли напишет что-то вроде:

* "Вы неправильно написали слово int: не следует употреблять прописную букву i."

Скорее всего он выразится так:

* Синтаксическая ошибка: пропущена ' ; ' перед идентификатором 'sЗ'"
* "У переменной 'sЗ' пропущен идентификатор класса или типа"
* "Неправильный идентификатор класса или типа `Int`"

Все эти сообщения можно перевести так:

* "Перед переменной aЗ имеется синтаксическая ошибка, и надо что-то сделать либо с типом `Int`, либо с переменной aЗ."

### Ошибки, связанные с типами
```cpp
int area(int length, int width);

int a1 = arean(7); //Ошибка - необъявленная функция
int a2 = area(7); //Ошибка - неверное количество аргументов
int a3 = area("seve", 2); //Ошибка - первый аргумент имеет неверный тип
```
### Не ошибки
```cpp
int area(int length, int width);

int a1 = area(7, -5); // ОК - но почему у фигуры отрицательная сторона
int a2 = area(2.3, 4.4) // ОК - но будет вызвана area(2,4)
char a3 = area(100, 9999) // ОК - но результат будет усечен
```

## Ошибки времени редактирования связей
* Любая программа состоит из нескольких отдельно компилируемых частей, которые называют единицами трансляции(translation units). 
* Каждая функция в программе должна быть объявлена с одним и тем же типом во всех единицах трансляции, в которых она используется. Для этого используются заголовочные файлы. 
* Каждая функция должно быть определена в программе 1 раз.

Если хотя бы одно из этих правил нарушено, редактор связей сообщит об ошибке.

```cpp
int area(int length, int width);

int main()
{
	int x = area(2,3); //Если мы подключим файл, где есть определение функции area(), тогда все хорошо, иначе ошибка
	// Кроме того в другом файле должна быть определена точно такая же функция
	// НЕ double area(int lenght, int width)
	// НЕ int area(int length, int width, int less)
}
```

## Ошибки времени выполнения программы
```cpp
int area(int length, int width) // вычисление площади прямоугольника
{
	return length*width;
}
int framed_area(int x, int y) // вычисление площади в пределах рамки
{
	return area(x–2,y–2);
}
int main()
{
	int x = –1;
	int y = 2;
	int z = 4;
	// . . .
	int area1 = area(x,y);
	int area2 = framed_area(1,z);
	int area3 = framed_area(y,z);
	double ratio = double(area1)/area3; // преобразуем в тип double
										// чтобы выполнить деление с плавующей точкой
}
```

* Приведеные вызовы функций возвращат отрицательные числа, присвоенные переменным `area1`, `area2`
* Деление на ноль в последнем вычисление

### Обработка ошибок в вызывающем коде
```cpp
	if (x<=0) error("Неположительное x");
	if (y<=0) error("Неположительное y");
	int area1 = area(x,y);
	// функция error() останавливает программу, выдавая сообщение об ошибке
```

Если нет необходимости сообщать об ошибках в каждом из аргументов, код можно упростить:

```cpp
	if (x<=0 || y<=0) error("non-positive area() argument");
	int area1 = area(x,y);
```
Для того, чтобы полностью защитить функцию area() от неправильных аргументов, необходимо исправить вызовы функции framed_area():

```cpp
	if (z<=2)
		error("Неположительный второй аргумент функции  area() при вызове из функции framed_area()");
	int area2 = framed_area(1,z);
	if (y<=2 || z<=2)
		error("Неположительный аргумент функции area() при вызове из функции framed_area()");
	int area3 = framed_area(y,z);
```

Если изменится тело функции framed_area(), то наш код будет непригоден, его называют хрупким. Можем ввести переменную, чтобы этого избежать:

```cpp
constexpr int frame_width = 2;
int framed_area(int x, int y)
{
	return area(x–frame_width,y–frame_width);
}
...
	if (1– frame_width<=0 || z–frame_width<=0)
		error("Неположительный аргумент функции area() при вызове из функции framed_area()");
	int area2 = framed_area(1,z);
	if (y– frame_width<=0 || z–frame_width<=0)
		error("Неположительный аргумент функции area() при вызове из функции framed_area()");
	int area3 = framed_area(y,z);
```

Код стал большим и сложным.

### Обработка ошибок в вызываемом коде
```cpp
int framed_area(int x, int y)
{
	constexpr int frame_width = 2;
	if (x–frame_width<=0 || y–frame_width<=0)
		error("non-positive area() argument called by framed_area()");
	return area(x–frame_width,y–frame_width);
}
```
Это решение выглядит неплохо и нам не нужно будет писать проверку для каждого вызова функций framed_area()

```cpp
int area(int length, int width)
{
	if (length<=0 || width <=0) 
		error("non-positive area() argument");
	return length*width;
}
```

**Почему проверка аргументов функции пишется не всегда?**

* Мы не можем модифицировать определение функции. Функция находится в библиотеке, которую по тем или иным причинам невозможно изменить. Возможно, она будет использована другими людьми, не разделяющими вашего подхода к обработке ошибок. Возможно, она принадлежит кому-то еще, и вы не имеете доступа к ее исходному коду. Возможно, она включена в постоянно обновляющуюся библиотеку, так что, изменив эту функцию, вы будете вынуждены изменять ее в каждой новой версии.
* Вызываемая функция не знает, что делать при выявлении ошибки. Эта ситуация типична для библиотечных функций. Автор библиотеки может выявить ошибку, но только вы знаете, что в таком случае следует делать.
* Вызываемая функция не знает, откуда ее вызвали. Получив сообщение об ошибке, вы понимаете, что произошло нечто непредвиденное, но не можете знать, как именно выполняемая программа оказалась в данной точке. И ногда необходимо. чтобы сообщение было более конкретным.
* Производительность. Дпя небольшой функции стоимость проверки может перевесить стоимость вычисления самого результата. Например, в случае с функцией area ( ) проверка вдвое увеличивает ее размер (т.е. удваивает количество машинных инструкций, которые необходимо выполнить, а не просто длину исходного кода) . В некоторых программах этот факт может оказаться критически важным, особенно если одна и та же информация проверяется постоянно функциями, вызывающими одна другую, и передающими при этом информацию более или менее неизменной.

Что в итоге делать? Проверять аргументы функции, если у вас нет веских причин поступать иначе.

## Логические ошибки
Программа делает ровно то, что вы написали. Если вы ожидали другой результат и все предыдущие ошибки устранены, то нужно искать ошибку в логике программы.