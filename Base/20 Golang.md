# 20 Golang
# Проект
Создать проект в папке /src/ваш_любой_ник/имя_проекта. Если у вас уже есть github аккаунт то можете создать проект так: /src/github.com/username/имя_проекта.

# Пакеты
Код пакета располагается в одном или нескольких файлах с расширением `go`. Для определения пакета применяется ключевое слово `package`. Например:

```go
package main

import "fmt"
 
func main() {
     
    fmt.Println("Hello Go")
}
```

Если в нескольких файлах будет объявление `package main`, то считается, что их функциональность определена в одном общем пакете, и не надо использовать `import`

В данном случае пакет называется `main`. Определение пакета должно идти в начале файла.

Есть два типа пакетов: исполняемые (executable) и библиотеки (reusable). Для создания исполняемых файлов пакет должен иметь имя `main`. Все остальные пакеты не являются исполняемыми. При этом пакет **main** должен содержать функцию `main`, которая является входной точкой в приложение.

Если уже есть готовые пакеты с нужной нам функциональностью, которую мы хотим использовать, то для их использования мы можем их импортировать в программу с помощью оператора `import`.

```go
import "fmt" 
import "math"

import ( 
	"fmt" 
	"math" 
)
```

Если после импорта написать точку, то получим поведение аналогичному в C++ при использовании `using namespace std`
```go
package main

import . "fmt"
import ( 
	. "fmt" 
)
```

## Импорт c синонимом
Так же мы можем присвоить импорту "синоним" - то есть заменить fmt на другое слово при использовании этого пакета.

```go
package main

import custom "fmt"

func main() {
	custom.Println("Hello!")
}
```
Пакеты импортируют, задавая синонимы, в нескольких случаях:

-   Имя импортируемого пакета неудобное/некрасивое/… и хочется использовать другое;
-   Имя импортируемого пересекается с именем другого пакета;
-   Хочется бесшовно подменить пакет — интерфейсы пакетов должны совпадать

# Модули
Модуль, это коллекция пакетов, распространяемых вместе (возможно это компоненты одной программы или одной библиотеки). В корне модуля находится файл go.mod, в котором записано имя модуля, версия Go, в которой он был написан, а также пути ко всем импортированным в модуле пакетам. Модуль включает в себя пакеты, находящиеся ниже корневой директории даже в том случае, если сами эти пакеты содержат файл go.mod.

Модуль инициализируется следующим образом:

```go
// name не обязателен
go mod init <name> // инициализировать новый модуль в текущем каталоге

// другие команды
go mod download    скачать модули в локальный кеш
go mod edit        редактировать go.mod из инструментов или скриптов
go mod graph       напечатать граф требований модуля
go mod tidy        добавить отсутствующие и удалить неиспользуемые модули
go mod vendor      делает вендорную копию зависимостей
go mod verify      проверить зависимости ожидаемого содержания
go mod why         объяснять, зачем нужны пакеты или модули
```


# Переменные
```go
a := 5
var a int = 5
var a = 5
var (         
	name string = "Dima"         
	age int = 23     
)
```

# Чтение данных с консоли
```go
package main  
  
import "fmt"  
  
func main() {  
   var name string  
   var age int  
   fmt.Print("Введите имя: ")  
   fmt.Scan(&name)  
   fmt.Print("Введите возраст: ")  
   fmt.Scan(&age)  
  
   fmt.Println(name, age)  
}
```

# Вывод
```go
fmt.Print("Ivan", 27) // Ivan27 - один из объектов строка, поэтому пробел между объектами не ставится
fmt.Println("Ivan", 27) // Ivan 27 - используем метод `Println()`  поэтому пробел ставится в любом случае
fmt.Print(33, 27) // 33 27 - нет строк - поэтому метод `Print()`   вставляет пробел между выводимыми объектами
```

# const
Вычисляются на этапе компиляции
```go
const pi float64 = 3.1415 
pi = 2.7182           // ! Ошибка

package main  
import (  
   "fmt"  
)  
const(  
   A int = 45  
   B  
   C float32 = 3.3  
   D  
)  
func main() {  
   fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3  
}
```

# iota
```go
package main  
  
import (  
   "fmt"  
)  
  
const (  
   Sunday = iota  
   Monday  
   Tuesday   Wednesday   Thursday   Friday   Saturday   _   _   Add)  
  
func main() {  
   fmt.Println(Sunday)   // вывод 0  
   fmt.Println(Saturday) // вывод 6  
   fmt.Println(Add)      // вывод 9

	const (  
	   u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)  
	   v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)  
	   w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)  
)  
  
// переменные ни в одном блоке const, поэтому индекс не увеличился  
const x = iota  // x == 0  
const y = iota  // y == 0
}
```

# if
```go
a := 6  
b := 7  
if a < b {  
   fmt.Println("a меньше b")  
} else if a > b {  
   fmt.Println("a больше b")  
} else {  
   fmt.Println("a равно b")  
}

if v := math.Pow(x, n); v < lim {  
	// ...  
}
```

# switch
```go
switch i {  // i - может быть любым типом данных, значения case-ов не должны повторяться
   case 0: fmt.Println("Zero")  
   case 1: fmt.Println("One")  
   case 2: fmt.Println("Two")  
   case 3: fmt.Println("Three")  
   case 4: fmt.Println("Four")  
   case 5: fmt.Println("Five")  
   default: fmt.Println("Unknown Number")  
}
```
Если в текущем `case` написать `fallthrough`, то тело следующего `case` выполнится вне зависимости от того истинно ли его (следующего `case`) условие:

```go
v := 42  
switch v {  
case 100:  
   fmt.Println(100)  
   fallthrough  
case 42:  
   fmt.Println(42)  
   fallthrough  
case 1:  
   fmt.Println(1)  
   fallthrough  
default:  
   fmt.Println("default")  
}  
// Вывод:  
// 42  
// 1  
// default
```

```cpp
var c uint32  
fmt.Scan(&c)  
switch {  
case 1 <= c && c <= 9:  
   fmt.Println("от 1 до 9")  
case 100 <= c && c <= 250:  
   fmt.Println("от 100 до 250")  
case 1000 <= c && c <= 6000:  
   fmt.Println("от 1000 до 6000")  
}
```

# for
```go
package main  
  
import "fmt"  
  
func main() {  
   sum := 0  
   for i := 1; i < 10; i++ {  
      sum += i  
   }  
   fmt.Println(sum)
   for {//бесконечный цикл
   }
}
```

# Форматирование
## Printf()
Сначала идет спецификатор, потом переменная:
```go
var a rune = 'Ы' 
fmt.Printf("%q", a) 
// вывод: 'Ы'
```
Каждый спецификатор представляет определенный тип данных:
-   `%t`: для вывода значений типа boolean (true или false)
-   `%b`: для вывода целых чисел в двоичной системе
-   `%c`: для вывода символов, представленных числовым кодом
-   `%d`: для вывода целых чисел в десятичной системе
-   `%o`: для вывода целых чисел в восьмеричной системе
-   `%q`: для вывода символов в одинарных кавычках
-   `%x`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
-   `%X`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
-   `%U`: для вывода символов в формате кодов Unicode, например, U+1234
-   `%e`: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
-   `%E`: тоже самое что `%e` но в верхнем регистре, например, -1.234456E+78
-   `%f`: для вывода чисел с плавающей точкой, например, 123.456
-   `%F`: то же самое, что и %f
-   `%g`   %e для огромных экспонент, %f в противном случае
-   `%G`    %E для огромных экспонент, %F в противном случае
-   `%s`: для вывода строки
-   `%p`: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
-   `%T` для вывода типа переменной

К спецификаторам можно добавлять различные флаги, которые влияют на форматирование значений. Например, число перед спецификатором указывает, какую минимальную длину в символах будет занимать выводимое значение. Например, `%9f` - число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части. Для этого количество символов указывается после точки: `%.2f` - две цифры в дробной части после точки. Например, варианты форматирования чисел с плавающей точкой:

-   `%f`: точность и ширина значения по умолчанию
-   `%9f`: ширина - 9 символов и точность по умолчанию  
    (число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)
-   `%.2f`: ширина по умолчанию и точность - 2 символа
-   `%9.2f`: ширина - 9 и точность - 2
-   `%9.f`: ширина - 9 и точность - 0

```go
var a float64 = 100.123456  
fmt.Printf("это число %f типа %T", a, a)  
// вывод: это число 100.123456 типа float64  
  
var a1 byte = 's'  
var a2 int = 1234  
fmt.Printf("%q %b", a1, a2)  
// вывод: 's' 10011010010  
  
  
// использование \n позволяет сделать перенос строки  
var a1 string = "123"  
var a2 string = "1234"  
fmt.Printf("%q \n%s", a1, a2)  
// вывод: // "123" // 1234
```

## Sprintf() - возвращает результат форматирования
```cpp
package main  
  
import (  
   "fmt"  
)  
  
func main() {  
   var a float64 = 100.123456789  
   result := fmt.Sprintf("%.2f", a)  
   fmt.Printf("%q", result) // вывод: "100.12"  
   // result будет типа string}
```

# Массивы
```go
var a [3]int //длина массива и тип его элементов определяют его тип, то есть var a [5]int имеет другой тип в отличии от var a [3]int
fmt.Println(a) // [0 0 0]

var a [3]int = [3]int{1, 2, 3} 
b := [3]int{1, 2, 3} 
c := [...]int{3, 2, 3} //[...] длина массива определяется в зависимости от количества элементов, но такой вариант не рекомендуется для использования
d := [3]int{1: 12} 

fmt.Println(a) // [1 2 3] 
fmt.Println(b) // [1 2 3] 
fmt.Println(c) // [1 2 3] 
fmt.Println(d) // [0 12 0]

fmt.Println(a == b) // true 
fmt.Println(a == c) // false
//Можем сравнивать массивы одинакового типа, т.е. одинаковый тип элементов и размер

var numbers [5]int = [5]int{1, 2, 3, 4, 5}  
  
fmt.Println(numbers[0]) // 1  
fmt.Println(numbers[4]) // 5  
numbers[0] = 87  
fmt.Println(numbers[0]) // 87

a := [5]int{1, 2, 3, 4, 5}  
fmt.Println(a) // [1 2 3 4 5]  
  
for i := 0; i < len(a); i++ {  
   fmt.Println(a[i])  
   // 1  
   // 2   
   // 3   
   // 4   
   // 5
}

for idx, elem := range a {  //elem является копией, если хотим изменить, нужно обращаться по иденксу
   fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)  
   // Элемент с индексом 0: 1  
   // Элемент с индексом 1: 2   
   // Элемент с индексом 2: 3   
   // Элемент с индексом 3: 4   
   // Элемент с индексом 4: 5
}

for idx, _ := range a {  
   // В этом случае следует использовать приведенный выше вариант,  
   // хотя технически эти варианты работают одинаково   
   fmt.Println(a[idx])  
}  
  
for _, elem := range a {  
   fmt.Println(elem)  
}

```

## Срезы (слайсы, slices)
Срез — это последовательность элементов одного типа переменной длины, по другому - динамический массив. Срез состоит из трех компонентов: указателя, длины и емкости:
-   указатель указывает на первый элемент массива, доступный через срез (который не обязательно совпадает с первым элементом массива);
-   длина (length) — это количество элементов среза;
-   емкость (capacity) - количество элементов между началом среза и концом базового массива.

```go
var a []int  
var b []int = []int{1, 2, 3}  
c := []int{1, 2, 3}  
d := []int{1: 12}  
  
fmt.Println(a) // []  
fmt.Println(b) // [1 2 3]  
fmt.Println(c) // [1 2 3]  
fmt.Println(d) // [0 12]

a := make([]int, 10, 10) // [0 0 0 0 0 0 0 0 0 0] 
fmt.Println(a)
a := make([]int, 10) // [0 0 0 0 0 0 0 0 0 0] 
a := make([]int, 0, 10) // []

```

Многоточия могут использоваться для разворачивания (раскрытие) среза путем указания _справа_ от среза знака многоточия.

```go
func ExampleExpandSlice1() {
	s := []interface{}{1, 2, 3, 4, 5}

	fmt.Println(s)
	fmt.Println(s...)

	// Output:
	// [1 2 3 4 5]
	// 1 2 3 4 5
}
```

### append()
Функция append позволяет добавить в срез новый элемент, выглядит она следующим образом:

```go
func append(slice []Type, elems ...Type) []Type
a := []int{1, 2, 3} 
a = append(a, 4, 5) 
fmt.Println(a) // [1 2 3 4 5]
```


```go
func ExampleExpandSlice2() {
	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{6, 7, 8, 9, 10}
	// append(slice []Type, elems ...Type) []Type
	// s1 = append(s1, s2) не сработает, т.к. второй и
	// последующие аргументы в нашем случае должны быть int
	s1 = append(s1, s2...)
	fmt.Println(s1)
	// Output:
	// [1 2 3 4 5 6 7 8 9 10]
}
```

С помощью этой функции можем также удалить элементы среза:

```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...) //... - означает, что элементы среза передаются как отдельные аргументы
fmt.Println(a) // [1 2 4 5 6 7]
```

### copy()
```go
func copy(dst, src []Type) int
// про функции мы поговорим в 2 модуле, ничего страшного если вам не очень понятно ;)
```

Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:

```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)//если бы указали ([]int, 1, 3) то скопировался бы один элемент
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```

# Функции
```go
package main
import "fmt"
 
func main() {
    add(4, 5)   // x + y = 9
    add(20, 6)  // x + y = 26
}
 
func add(x int, y int){
    var z = x + y
    fmt.Println("x + y = ", z)
}
func add(x, y int, a, b, c float32){
    var z = x + y
    var d = a + b + c
    fmt.Println("x + y = ", z)
    fmt.Println("a + b + c = ", d)
}
func add(x, y int) int {
    return x + y
}
func add(x, y int, firstName, lastName string) (int , string) {
    var z int = x + y
    var fullName = firstName + " " + lastName
    return z, fullName 
    // Использование - var age, name = add(4, 5, "Tom", "Simpson")
    //                     age, name := add(4, 5, "Tom", "Simpson")
}

func sumInt(n ...int ) (c, s int) { 
	for _, e := range n { 
		c++ 
		s+=e 
	} 
	return 
}
```

Также как и в цикле range for, мы также можем игнорировать возвращаемые значения функций:
```go
func fn() (int, error) {
	// Какая-то полезная работа
	// ...
	return 0, nil
}
func ExampleIgnor() {
	fn()

	i, _ := fn()
	fmt.Println(i)

	_, err := fn()
	if err == nil {
		fmt.Println("Ошибок нет")
	}

	// Output:
	// 0
	// Ошибок нет
}
```

## variadic аргументы функции

```go
func Print(a ...interface{}) (n int, err error)
```
Символ многоточия перед указанием типа указывает, что в функцию можно передать произвольное количество параметров указанного типа. Аргумент с именем a воспринимается функцией как срез элементов заданного типа interface{}, внутри функция работает с элементами этого среза соответствующим образом.

Если функция принимает определенные аргументы и еще произвольное число аргументов определенного типа, то при объявлении функции эти «переменные» аргументы указываются в самом конце. 
```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
```

# Указатели
```go
func main() {
        a := 200
        b := &a
        *b++
        fmt.Println(a)
       a := 200 
       var b *int = &a
}
```

Другой способ получить указатель — использовать встроенную функцию `new`:

```
func one(xPtr *int) {
    *xPtr = 1
}
func main() {
    xPtr := new(int)
    one(xPtr)
    fmt.Println(*xPtr) // x is 1
}
```
Также мы можем создать указатель на указатель.

```go
package main

import "fmt"

func main() {
   a := 200
   b := &a
   *b++
   c := &b
   **c++ // указатель на указатель
   fmt.Println(a)
}
```

# Структуры
```go
type Circle struct {
    x float64
    y float64
    r float64
}
type Circle struct { 
	x, y, r float64 
}

var c Circle 
c := Circle{}
c := new(Circle)
c := Circle{x: 0, y: 0, r: 5}
c := Circle{0, 0, 5}
fmt.Println(c.x, c.y, c.r) 
c.x = 10 
c.y = 5
```

## Методы
```
func (c *Circle) area() float64 {
    return math.Pi * c.r * c.r
}
fmt.Println(c.area())
```

Между ключевым словом `func` и именем функции мы добавили «получателя». Получатель похож на параметр — у него есть имя и тип, но объявление функции таким способом позволяет нам вызывать функцию с помощью оператора `.`

Нам не нужно использовать оператор `&` (Go автоматически предоставляет доступ к указателю на `Circle` для этого метода), и поскольку эта функция может быть использована только для `Circle` мы можем назвать её просто `area`.

## Встраиваемые типы

Обычно, поля структур представляют отношения принадлежности (включения). Например, у `Circle` (круга) есть `radius` (радиус). Предположим, у нас есть структура `Person` (личность):
```go
type Person struct {
    Name string
}
func (p *Person) Talk() {
    fmt.Println("Hi, my name is", p.Name)
}
```

И если мы хотим создать новую структуру `Android`, то можем сделать так:
```go
type Android struct {
    Person Person
    Model string
}
```

Это будет работать, но мы можем захотеть создать другое отношение. Сейчас у андроида «есть» личность, можем ли мы описать отношение андроид «является» личностью? Go поддерживает подобные отношения с помощью встраиваемых типов, также называемых анонимными полями.
```go
type Android struct {
    Person
    Model string
}
```

Мы использовали тип (`Person`) и не написали его имя. Объявленная таким способом структура доступна через имя типа:
```go
a := new(Android)
a.Person.Talk()
```

Но мы также можем вызвать любой метод `Person` прямо из `Android`:
```go
a := new(Android)
a.Talk()
```

Это отношение работает достаточно интуитивно: личности могут говорить, андроид это личность, значит андроид может говорить.  
  
Также мы можем при создании инициализировать нужные переменные:

```go
var a = Android{
	Model: "model",
	Person: Person {
		Name: "name",
	},
}
```

# string
Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов `Hello World`. Различие между ними в том, что строки в двойных кавычках позволяют использовать [[Escape sequence]].

Строка представляет собой неизменяемую последовательность байтов. Из этого следует ряд выводов:
-   к строке применимы операции, применимые к массивам и срезам;
-   чтобы изменить строку, необходимо создать новую строку;
-   мы можем итерироваться по строке как и по всякой последовательности, но итерируясь по строке, мы будем итерироваться по байтам, составляющим строку, а не по символам;
-   мы можем определить в строке подстроку.

```go
func ExampleString() {  
   // Создадим строковый литерал s, значение которого "Это строка".  
   // Строка состоит из 10 символов.   var s string = "Это строка"  
  
   // Однако длина строки len(s) составит 19 байт, т.к. использованные кирилические символы  
   // занимают 2 байта, а пробел занимает 1 байт.   fmt.Printf("Длина строки: %d байт\n", len(s))  
   // Длина строки: 19 байт  
  
   // Посмотрим как взять подстроку   fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])  
   // Напечатаем только второе слово в кавычках: "строка"  
  
   /*      Попробуем изменить что-то встроке:      s[3] = 12      Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.   */  
   // "Изменим строку", создав новую   s = s + " Новая строка"  
   fmt.Printf("%v\n", s)  
   // Это строка Новая строка  
  
   // А теперь проитерируемся по этой строке   for _, b := range s {  
      fmt.Printf("%c ", b)  
   } //Э т о   с т р о к а   Н о в а я   с т р о к а  
   fmt.Println(" ")  
   for idx, b := range s {  
      fmt.Print(s[idx], b, " ")  
   }//208 1069 209 1090 208 1086 32 32 209 1089 209 1090 209 1088 208 1086 208 1082 208 1072 32 32 208 1053 208 1086 208 1074 208 1072 209 1103 32 32 209 1089 209 1090 209 1088 208 1086 208 1082 208 1072   
fmt.Print("\n")  
}
```

Строки поддерживают проверку на равенство и неравенство, а вот проверки <> со строками уже не дадут нужного нам результата, т.к. сравнивать Go будет байты, а не символы, т.е. результат для нас может быть не тот, что мы ожидаем (сравнивается не длина строк):

```go
func ExampleEqualString() {
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")

	fmt.Printf("\"Строка1\" > \"Строка2\": %v", "Строка1" > "Строка2")

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false
}
```

Go содержит большое количество функций для работы со строками в пакете `strings` , кратко рассмотрим основные: 

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(    
        // Содержится ли подстрока в строке    
        strings.Contains("test", "es"), 
        // результат: true

        // Кол-во подстрок в строке
        strings.Count("test", "t"),
        // результат: 2

        // Начинается ли строка с префикса       
        strings.HasPrefix("test", "te"), 
        // результат: true

        // Заканчивается ли строка суффиксом
        strings.HasSuffix("test", "st"), 
        // результат: true

        // Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
        strings.Index("test", "e"), 
        // результат: 1

        // объединяет массив строк через символ
        strings.Join([]string{"hello","world"}, "-"),
        // результат: "hello-world"

        // Повторяет строку n раз подряд
        strings.Repeat("a", 5), 
        // результат: "aaaaa"

        // Функция Replace заменяет любое вхождение old в вашей строке на new
        // Если значение n равно -1, то будут заменены все вхождения.
        // Общий вид: func Replace(s, old, new string, n int) string
        // Пример:
        strings.Replace("blanotblanot", "not", "***", 	-1),
        // результат: "bla***bla***"
 
        // Разбивает строку согласно разделителю
        strings.Split("a-b-c-d-e", "-"), 
        // результат: []string{"a","b","c","d","e"}

        // Возвращает строку c нижним регистром
        strings.ToLower("TEST"), 
        // результат: "test"

        // Возвращает строку c верхним регистром
        strings.ToUpper("test"), 
        // результат: "TEST"

        // Возвращает строку с вырезанным набором
        strings.Trim("tetstet", "te"),
        // результат: s
        var s string = strings.Trim("tetstetstet", "te")
		//результат stets
    )
}
```

#do/continue разобраться с []rune и []byte

# Ошибки
В отличии от других языков, в Go функция может возвратить тип `error`, а мы должны проверить возвращаемое значение и принять соответствующие меры.

```go
package main

import "fmt"

func divide(a int, b int) int {
	return a / b
}

func main() {
	var input int
	_, err := fmt.Scan(&input) // функция Scan возвращает два параметра, но нам сейчас важно проверить только ошибку
	if err != nil {//nil - пустота, возвращая ошибку, в ней должно что-то содержаться
		fmt.Println("Проверьте типы входных параметров")
	} else {
		fmt.Println(divide(input, 5)) //Выведем результат, если ошибок нет
	}
}
```

Существуют две встроенные функции для создания ошибок: `errors.New` и `fmt.Errorf`.
```
func main() {
    err := errors.New("my error")
    fmt.Println("", err)
}
```

## panic
Оператор **panic** позволяет сгенерировать ошибку и выйти из программы:

```go
package main
import "fmt"
 
func main() {
    fmt.Println(divide(15, 5))
    fmt.Println(divide(4, 0))
    fmt.Println("Program has been finished")
}
func divide(x, y float64) float64{
    if y == 0{ 
        panic("division by zero!")
    }
    return x / y
}
```

## Оператор defer

Оператор defer позволяет выполнить определенную операцию после каких-то действий (даже если сработает panic), при этом не важно, где в реальности вызывается эта функция. Например:

```go
package main
import "fmt"
 
func main() {
    defer finish()
    defer fmt.Println("Program has been started")
    fmt.Println("Program has been started")
    fmt.Println("Program is working")
}
 
func finish(){
    fmt.Println("Program has been finished")
}
```

Здесь функция finish вызывается с оператором defer, поэтому данная функция в реальности будет вызываться в самом конце выполнения программы, несмотря на то, что ее вызов определен в начале функции main, а вывод с defer будет идти предпоследним