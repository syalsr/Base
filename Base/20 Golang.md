# 20 Golang

# Переменные
```go
a := 5
var a int = 5
var a = 5
var (         
	name string = "Dima"         
	age int = 23     
)
```

# Чтение данных с консоли
```go
package main  
  
import "fmt"  
  
func main() {  
   var name string  
   var age int  
   fmt.Print("Введите имя: ")  
   fmt.Scan(&name)  
   fmt.Print("Введите возраст: ")  
   fmt.Scan(&age)  
  
   fmt.Println(name, age)  
}
```

# Вывод
```go
fmt.Print("Ivan", 27) // Ivan27 - один из объектов строка, поэтому пробел между объектами не ставится
fmt.Println("Ivan", 27) // Ivan 27 - используем метод `Println()`  поэтому пробел ставится в любом случае
fmt.Print(33, 27) // 33 27 - нет строк - поэтому метод `Print()`   вставляет пробел между выводимыми объектами
```

# const
Вычисляются на этапе компиляции
```go
const pi float64 = 3.1415 
pi = 2.7182           // ! Ошибка

package main  
import (  
   "fmt"  
)  
const(  
   A int = 45  
   B  
   C float32 = 3.3  
   D  
)  
func main() {  
   fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3  
}
```

# iota
```go
package main  
  
import (  
   "fmt"  
)  
  
const (  
   Sunday = iota  
   Monday  
   Tuesday   Wednesday   Thursday   Friday   Saturday   _   _   Add)  
  
func main() {  
   fmt.Println(Sunday)   // вывод 0  
   fmt.Println(Saturday) // вывод 6  
   fmt.Println(Add)      // вывод 9

	const (  
	   u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)  
	   v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)  
	   w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)  
)  
  
// переменные ни в одном блоке const, поэтому индекс не увеличился  
const x = iota  // x == 0  
const y = iota  // y == 0
}
```

# if
```go
a := 6  
b := 7  
if a < b {  
   fmt.Println("a меньше b")  
} else if a > b {  
   fmt.Println("a больше b")  
} else {  
   fmt.Println("a равно b")  
}

if v := math.Pow(x, n); v < lim {  
	// ...  
}
```

# switch
```go
switch i {  // i - может быть любым типом данных, значения case-ов не должны повторяться
   case 0: fmt.Println("Zero")  
   case 1: fmt.Println("One")  
   case 2: fmt.Println("Two")  
   case 3: fmt.Println("Three")  
   case 4: fmt.Println("Four")  
   case 5: fmt.Println("Five")  
   default: fmt.Println("Unknown Number")  
}
```
Если в текущем `case` написать `fallthrough`, то тело следующего `case` выполнится вне зависимости от того истинно ли его (следующего `case`) условие:

```go
v := 42  
switch v {  
case 100:  
   fmt.Println(100)  
   fallthrough  
case 42:  
   fmt.Println(42)  
   fallthrough  
case 1:  
   fmt.Println(1)  
   fallthrough  
default:  
   fmt.Println("default")  
}  
// Вывод:  
// 42  
// 1  
// default
```

```cpp
var c uint32  
fmt.Scan(&c)  
switch {  
case 1 <= c && c <= 9:  
   fmt.Println("от 1 до 9")  
case 100 <= c && c <= 250:  
   fmt.Println("от 100 до 250")  
case 1000 <= c && c <= 6000:  
   fmt.Println("от 1000 до 6000")  
}
```

# for
```go
package main  
  
import "fmt"  
  
func main() {  
   sum := 0  
   for i := 1; i < 10; i++ {  
      sum += i  
   }  
   fmt.Println(sum)
   for {//бесконечный цикл
   }
}
```

# Форматирование
## Printf()
Сначала идет спецификатор, потом переменная:
```go
var a rune = 'Ы' 
fmt.Printf("%q", a) 
// вывод: 'Ы'
```
Каждый спецификатор представляет определенный тип данных:
-   `%t`: для вывода значений типа boolean (true или false)
-   `%b`: для вывода целых чисел в двоичной системе
-   `%c`: для вывода символов, представленных числовым кодом
-   `%d`: для вывода целых чисел в десятичной системе
-   `%o`: для вывода целых чисел в восьмеричной системе
-   `%q`: для вывода символов в одинарных кавычках
-   `%x`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
-   `%X`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
-   `%U`: для вывода символов в формате кодов Unicode, например, U+1234
-   `%e`: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
-   `%E`: тоже самое что `%e` но в верхнем регистре, например, -1.234456E+78
-   `%f`: для вывода чисел с плавающей точкой, например, 123.456
-   `%F`: то же самое, что и %f
-   `%g`   %e для огромных экспонент, %f в противном случае
-   `%G`    %E для огромных экспонент, %F в противном случае
-   `%s`: для вывода строки
-   `%p`: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
-   `%T` для вывода типа переменной

К спецификаторам можно добавлять различные флаги, которые влияют на форматирование значений. Например, число перед спецификатором указывает, какую минимальную длину в символах будет занимать выводимое значение. Например, `%9f` - число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части. Для этого количество символов указывается после точки: `%.2f` - две цифры в дробной части после точки. Например, варианты форматирования чисел с плавающей точкой:

-   `%f`: точность и ширина значения по умолчанию
-   `%9f`: ширина - 9 символов и точность по умолчанию  
    (число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)
-   `%.2f`: ширина по умолчанию и точность - 2 символа
-   `%9.2f`: ширина - 9 и точность - 2
-   `%9.f`: ширина - 9 и точность - 0

```go
var a float64 = 100.123456  
fmt.Printf("это число %f типа %T", a, a)  
// вывод: это число 100.123456 типа float64  
  
var a1 byte = 's'  
var a2 int = 1234  
fmt.Printf("%q %b", a1, a2)  
// вывод: 's' 10011010010  
  
  
// использование \n позволяет сделать перенос строки  
var a1 string = "123"  
var a2 string = "1234"  
fmt.Printf("%q \n%s", a1, a2)  
// вывод: // "123" // 1234
```

## Sprintf() - возвращает результат форматирования
```cpp
package main  
  
import (  
   "fmt"  
)  
  
func main() {  
   var a float64 = 100.123456789  
   result := fmt.Sprintf("%.2f", a)  
   fmt.Printf("%q", result) // вывод: "100.12"  
   // result будет типа string}
```

# Массивы
```go
var a [3]int //длина массива и тип его элементов определяют его тип, то есть var a [5]int имеет другой тип в отличии от var a [3]int
fmt.Println(a) // [0 0 0]

var a [3]int = [3]int{1, 2, 3} 
b := [3]int{1, 2, 3} 
c := [...]int{3, 2, 3} //[...] длина массива определяется в зависимости от количества элементов, но такой вариант не рекомендуется для использования
d := [3]int{1: 12} 

fmt.Println(a) // [1 2 3] 
fmt.Println(b) // [1 2 3] 
fmt.Println(c) // [1 2 3] 
fmt.Println(d) // [0 12 0]

fmt.Println(a == b) // true 
fmt.Println(a == c) // false
//Можем сравнивать массивы одинакового типа, т.е. одинаковый тип элементов и размер

var numbers [5]int = [5]int{1, 2, 3, 4, 5}  
  
fmt.Println(numbers[0]) // 1  
fmt.Println(numbers[4]) // 5  
numbers[0] = 87  
fmt.Println(numbers[0]) // 87

a := [5]int{1, 2, 3, 4, 5}  
fmt.Println(a) // [1 2 3 4 5]  
  
for i := 0; i < len(a); i++ {  
   fmt.Println(a[i])  
   // 1  
   // 2   
   // 3   
   // 4   
   // 5
}

for idx, elem := range a {  //elem является копией, если хотим изменить, нужно обращаться по иденксу
   fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)  
   // Элемент с индексом 0: 1  
   // Элемент с индексом 1: 2   
   // Элемент с индексом 2: 3   
   // Элемент с индексом 3: 4   
   // Элемент с индексом 4: 5
}

for idx, _ := range a {  
   // В этом случае следует использовать приведенный выше вариант,  
   // хотя технически эти варианты работают одинаково   
   fmt.Println(a[idx])  
}  
  
for _, elem := range a {  
   fmt.Println(elem)  
}

```

## Срезы (слайсы, slices)
Срез — это последовательность элементов одного типа переменной длины, по другому - динамический массив. Срез состоит из трех компонентов: указателя, длины и емкости:
-   указатель указывает на первый элемент массива, доступный через срез (который не обязательно совпадает с первым элементом массива);
-   длина (length) — это количество элементов среза;
-   емкость (capacity) - количество элементов между началом среза и концом базового массива.

```go
var a []int  
var b []int = []int{1, 2, 3}  
c := []int{1, 2, 3}  
d := []int{1: 12}  
  
fmt.Println(a) // []  
fmt.Println(b) // [1 2 3]  
fmt.Println(c) // [1 2 3]  
fmt.Println(d) // [0 12]

a := make([]int, 10, 10) // [0 0 0 0 0 0 0 0 0 0] 
fmt.Println(a)
a := make([]int, 10) // [0 0 0 0 0 0 0 0 0 0] 
a := make([]int, 0, 10) // []

```

### append()
Функция append позволяет добавить в срез новый элемент, выглядит она следующим образом:

```go
func append(slice []Type, elems ...Type) []Type
a := []int{1, 2, 3} 
a = append(a, 4, 5) 
fmt.Println(a) // [1 2 3 4 5]
```

С помощью этой функции можем также удалить элементы среза:

```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...) //... - означает, что элементы среза передаются как отдельные аргументы
fmt.Println(a) // [1 2 4 5 6 7]
```

### copy()
```go
func copy(dst, src []Type) int
// про функции мы поговорим в 2 модуле, ничего страшного если вам не очень понятно ;)
```

Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:

```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)//если бы указали ([]int, 1, 3) то скопировался бы один элемент
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```