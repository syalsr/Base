# Что такое динамическая память и откуда она берется в системе

# Чем динамическая память отличается от других типов памяти в модели С++

# Выделение и освобождение динамической памяти
## Операторы new && delete
Для того, чтобы выделить память в куче нужно использовать оператор `new` и указатель `T*`, указатель должен быть чем-то проинициализирован либо быть `nullptr`.

```cpp
int* pInt = new int;//pInt указатель на значение типа int
//pInt как адрес, будет храниться на стеке и указаывать на область памяти в куче.

int** handle { nullptr };
handle = new int*;//handle - адресс находящийся на стеке, который указывает на переменную
*handle = new int;//*handle находящуюся в куче которая указывает на переменную int тоже находящуюся в куче
```

Оператор `new` возвращает указатель на объект который он создал(если тип double, то new вернет указатель типа double*), если их несколько, как в примере выше, то на первый объект.

Мы не можем присваивать указатели разных типов друг другу, т.к. они имеют разные типы $=>$  они занимают разный объем памяти.

Указатель – это адрес в памяти. Память в С++ представляется как линейный массив байтов. Указатель – это индекс в этом массиве.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
cout << ∗s << ' ' << s−>size () << endl; 
// Hello 5
```

Оператор `*`, примененный к указателю, возвращает ссылку на объект в куче.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
string& ref_to_s = ∗s; 
ref_to_s += ", world"; 
cout << ∗s << endl; 
// Hello, world
```


Если мы выделим память в куче, не удалим и указатель на эту область выйдет из области видимости, то произойдет утечка, мы никак не сможем удалить ее, т.к. доступа к ней нет, поэтому программа будет тратить лишнюю память. Если выделять память в куче в цикле `for` и не освобождать, то на какой-то итерации произойдет вылет из программы(в зависимости от объема вашей оперативной памяти).

```cpp
int* pInt = new int;
delete pInt;
pInt = nullptr; //рекомендуется занулять удаленный указать, чтобы случайно его не использовать, поскольку pInt еще указывает на область памяти в куче, обращение к ней UB, повторное удаление UB.

int** handle { new int* };
*handle = new int;
delete *handle;
delete handle;
handle = nullptr;
```

Перед delete не обязательно проверять объект на nullptr
## Операторы new[ ] && delete[ ]
Оператор new[] позволяет выделить блок памяти для хранения необходимого количества объектов.

```cpp
double *p;
p = new double[4];//выделяем память для 4 чисел типа double
int* myArrayPtr { new int[] { 1, 2, 3, 4, 5 } };

double** twoarr { new double*[4]};
for (size_t i { 0 }; i < 4; i++) { twoarr[i] = new double; } //allocate
for (size_t i { 0 }; i < 4; i++) {//deallocate
	delete twoarr[i];
	twoarr[i] = nullptr;
}
delete [] twoarr;
twoarr = nullptr;
```

![](cpp_basic16.png)

Доступ к элементам массива мы можем получить с помощью оператора индексирования.

```cpp
double *pd = new double[3];
double x = *pd; //присваиваем x первое значение массива
pd[2] = 2.2;
pd[4] = 4.4;
pd[-3] = -3.3;
delete pd;
pd = nullptr;
```
Т.к. указатель не знает на какой диапазон элементов он указывает, то мы можем выходить за его рамки и компилятор не посчитает это за ошибку. Мы просто изменить значения другого объекта, о котором мы ничего не знаем.

![](cpp_basic18.png)

pd - динамически выделяемый массив, не динамический массив, мы можем указать размер во время выполнения программы, но не можем расширять его

## new и delete для объектов классового типа
При выделении памяти в куче для объекта классового типа вызывается конструктор, при удалении с помощью `delete` вызывается деструктор.

## Разница между new/delete и malloc/free
1. new в отличии от malloc, вызывает констурктор у объекта
```cpp
Foo* myFoo { (Foo*)malloc(sizeof(Foo)) };//выделилась память нужного размера
Foo* myOtherFoo { new Foo{} };//выделилась память и создался объект
```
1. При вызове `free()` у класса не вызовется деструктор в  отличии от `delete`
2. new - оператор который можно переопределить

## Исключения и new
new может выбросить исключение, если ей не удается выделить нужное количество памяти из-за нехватки ресурсов
```cpp
int* ptr { new(nothrow) int };//вместо исключения возратит nullptr, но рекомендуется использовать стандартный new
```

## malloc/calloc/free
#do/start найти где-то инфу как работает, в книге по C какой-нибудь

## Многомерные массивы
Многомерные массивы можно представить как шахматную доску.

### Стек

```cpp
char board[12][12]{};
```

Память в компьютере последовательна, двумерный массив в нем представлен как последовательность `board[0][0], board[0][1]` и т.д., наш массив состоит из 12 мини массивов, когда мы обращаемся по индексу к массиву, мы сначала ищем мини массив, а потом по этому мини массиву нужный элемент.

### Куча
Двумерный массив можно представить как указатель на указатель, а N-мерный, как N указателей.

```cpp
char** board { new char*[xPos] };
for (size_t i { 0 }; i < xPos; i++) {
	board[i] = new char[yPos]; // Allocate ith subarray
}
...
for (size_t i { 0 }; i < xPos; i++) {
	delete [] board[i]; // Delete its subarray
	board[i] = nullptr;
}
delete [] board; // Delete first dimension
board = nullptr;
```

Но это не совсем эффективно, лучше выделить сразу нужный блок памяти $=xPos * yPos * sizeof(char)$ и обращаться к элементам как $x * yPos + y$, поскольку программа будет работать быстрее если ее данные расположены последовательно.

# Встроенный аллокатор
#do/start 
1. https://habr.com/ru/post/274827/
2. https://habr.com/ru/post/505632/ - это как я понял перевод или конспект вот этого https://github.com/mtrebi/memory-allocators#benchmarks
3. Можно сначала прочитать перевод, а потом уже оригинал
# Фрагментация памяти, требования к выравниванию, минимальный кусок выделяемой памяти
#do/start найти инфу

# placement new
#do/start найти инфу
[[Перегрузка операторов#Перегрузка new delete]]

# Многопоточность и аллокация памяти
# Работа с указателями
Мы можем изменить адрес указателя так:

```cpp
char* scaryPointer { (char*)7 };
// указатель имеет адрес 0x0000000000000007, т.е. мы можем вот так вот указывать на чужие данные, что не есть хорошо это UB
```

## C style Касты указателей
```cpp
Document* documentPtr { getDocument() };
char* myCharPtr { (char*)documentPtr };
```

Указатели слабо типизированы, используя c style касты мы можем легко привести их к любому типу, в C++ есть [[casting#static_cast|static_cast]] которые являются более безопасными

# Стек
У каждой функции есть локальные переменные, они хранятся на стеке(область оперативной памяти)

```cpp
void second () { 
	int s_a = 3; 
	double s_d = 2.0; 
} 
void first () { 
	int f_a = 2; 
	char f_c = 'a'; 
	second (); 
} 
int main () { 
	int a = 1; 
	char c = 'r'; 
	first (); 
	second (); 
	a = 2; 
	c = 'q'; 
}
```

Когда на стеке запускается очередная функция, то на стеке резервируется блок памяти, достаточный для хранения локальных переменных. Помимо этого он хранит такую служебную информацию как адрес возврата. Такая область памяти называется стековым фреймом функции.

![[../Files/Pasted image 20220216105531.png]] 

Когда функция `main` запускает функцию `first`, то на стеке ниже функции `main` резервируется фрейм для функции `first`. То же самое происходит, когда функция `first` вызывает функцию `second`.

Когда функция `second` завершает свою работу, то вершина стека перемещается на фрейм предыдущей функции. При этом фрейм отработавшей функции просто остаётся на стеке.

![[../Files/Pasted image 20220216105913.png]]

 Выйдем из функции `first` в функцию `main`, запустим функцию `second` из `main`. Стековый фрейм перетирает данные, которые были в стеке от предыдущих вызовов. Если мы не сами не инициализируем переменные, то ей присвоятся значения, которые были тут от другого фрейма, поэтому важно сразу инициализировать значения, чтобы избегать непредвиденных ситуаций.
 
Когда выходим из программы, то вершина стека поднимается до самого верха.

 ```cpp
void fill(istream& is , vector& ints) { 
	int x; 
	while (is >> x) { 
		ints. push_back (x); 
	} 
} 
int main () { 
	vector ints1 , ints2; 
	istringstream is1("1 2 3 4"); 
	fill(is1 , ints1); 
	istringstream is2("5 7"); 
	fill(is2 , ints2); 
} 
```

После завершения работы функции `fill` в куче будет выделен блок памяти, достаточный для хранения четырех целых чисел. При этом вектор `ints1` будет ссылаться на эту область памяти в куче и будет иметь доступ к своим элементам.

![[../Files/Pasted image 20220216110537.png]]

Когда `fill` отработает во второй раз, то в куче будет выделен отдельный блок памяти, достаточный для хранения двух целых чисел(если бы мы использовали стек, то данные бы просто перезаписались).