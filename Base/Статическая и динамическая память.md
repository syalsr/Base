# Что такое динамическая память и откуда она берется в системе

# Чем динамическая память отличается от других типов памяти в модели С++

# Выделение и освобождение динамической памяти
## Операторы new && delete
Для того, чтобы выделить память в куче нужно использовать оператор `new` и указатель `T*`, указатель должен быть чем-то проинициализирован либо быть `nullptr`.

```cpp
int* pInt = new int;//pInt указатель на значение типа int
//pInt как адрес, будет храниться на стеке и указаывать на область памяти в куче.

int** handle { nullptr };
handle = new int*;//handle - адресс находящийся на стеке, который указывает на переменную
*handle = new int;//*handle находящуюся в куче которая указывает на переменную int тоже находящуюся в куче
```

Оператор `new` возвращает указатель на объект который он создал(если тип double, то new вернет указатель типа double*), если их несколько, как в примере выше, то на первый объект.

Мы не можем присваивать указатели разных типов друг другу, т.к. они имеют разные типы $=>$  они занимают разный объем памяти.

Указатель – это адрес в памяти. Память в С++ представляется как линейный массив байтов. Указатель – это индекс в этом массиве.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
cout << ∗s << ' ' << s−>size () << endl; 
// Hello 5
```

Оператор `*`, примененный к указателю, возвращает ссылку на объект в куче.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
string& ref_to_s = ∗s; 
ref_to_s += ", world"; 
cout << ∗s << endl; 
// Hello, world
```


Если мы выделим память в куче, не удалим и указатель на эту область выйдет из области видимости, то произойдет утечка, мы никак не сможем удалить ее, т.к. доступа к ней нет, поэтому программа будет тратить лишнюю память. Если выделять память в куче в цикле `for` и не освобождать, то на какой-то итерации произойдет вылет из программы(в зависимости от объема вашей оперативной памяти).

```cpp
int* pInt = new int;
delete pInt;
pInt = nullptr; //рекомендуется занулять удаленный указать, чтобы случайно его не использовать, поскольку pInt еще указывает на область памяти в куче, обращение к ней UB, повторное удаление UB.

int** handle { new int* };
*handle = new int;
delete *handle;
delete handle;
handle = nullptr;
```

Перед delete не обязательно проверять объект на nullptr
## Операторы new[ ] && delete[ ]
Оператор new[] позволяет выделить блок памяти для хранения необходимого количества объектов.

```cpp
double *p;
p = new double[4];//выделяем память для 4 чисел типа double
int* myArrayPtr { new int[] { 1, 2, 3, 4, 5 } };

double** twoarr { new double*[4]};
for (size_t i { 0 }; i < 4; i++) { twoarr[i] = new double; } //allocate
for (size_t i { 0 }; i < 4; i++) {//deallocate
	delete twoarr[i];
	twoarr[i] = nullptr;
}
delete [] twoarr;
twoarr = nullptr;
```

![](cpp_basic16.png)

Доступ к элементам массива мы можем получить с помощью оператора индексирования.

```cpp
double *pd = new double[3];
double x = *pd; //присваиваем x первое значение массива
pd[2] = 2.2;
pd[4] = 4.4;
pd[-3] = -3.3;
delete pd;
pd = nullptr;
```
Т.к. указатель не знает на какой диапазон элементов он указывает, то мы можем выходить за его рамки и компилятор не посчитает это за ошибку. Мы просто изменить значения другого объекта, о котором мы ничего не знаем.

![](cpp_basic18.png)

pd - динамически выделяемый массив, не динамический массив, мы можем указать размер во время выполнения программы, но не можем расширять его

## new и delete для объектов классового типа
При выделении памяти в куче для объекта классового типа вызывается конструктор, при удалении с помощью `delete` вызывается деструктор.

## Разница между new/delete и malloc/free
1. new в отличии от malloc, вызывает констурктор у объекта
```cpp
Foo* myFoo { (Foo*)malloc(sizeof(Foo)) };//выделилась память нужного размера
Foo* myOtherFoo { new Foo{} };//выделилась память и создался объект
```
1. При вызове `free()` у класса не вызовется деструктор в  отличии от `delete`
2. new - оператор который можно переопределить

## Исключения и new
new может выбросить исключение, если ей не удается выделить нужное количество памяти из-за нехватки ресурсов
```cpp
int* ptr { new(nothrow) int };//вместо исключения возратит nullptr, но рекомендуется использовать стандартный new
```

## Многомерные массивы
Многомерные массивы можно представить как матрицу и в памяти элементы располагаются так

![[../Files/Pasted image 20220422174530.png]]

```cpp
char board[12][12]{};
```

### jagged array
Помимо этого многомерный массив можно создать с помощью массива указателей

![[../Files/Pasted image 20220422175150.png]]

И вычисляет адреса по разному

```cpp
void foo(int (*pcont)[10]){ 
	pcont[1][2] = 1; //*(&cont[0][0] + 1 * 10 + 2) = 1
}
int cont[5][10]; 
foo(cont); 
cont[1][2] = 1;//*(&cont[0][0] + 1 * 10 + 2) = 1
//-----------------------------------------
void bar(int **pjag) { 
	pjag[1][2] = 1; //*(*(jagged + 1) + 2) = 3
}
int *jagged[10]; 
bar(jagged); 
jagged[1][2] = 1;//*(*(jagged + 1) + 2) = 3
```

Мы всегда можем опускать только самый вложенный индекс: и в инициализаторах и в аргументах функций

```cpp
float flt[2][3] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // ok 
float flt[][3] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // ok 
float flt[][] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // fail
float func(float flt[][3][6]); // ok, float *flt[3][6]
```

### Куча

```cpp
char** board { new char*[xPos] };
for (size_t i { 0 }; i < xPos; i++) {
	board[i] = new char[yPos]; // Allocate ith subarray
}
...
for (size_t i { 0 }; i < xPos; i++) {
	delete [] board[i]; // Delete its subarray
	board[i] = nullptr;
}
delete [] board; // Delete first dimension
board = nullptr;
```

Но это не совсем эффективно, лучше выделить сразу нужный блок памяти $=xPos * yPos * sizeof(char)$ и обращаться к элементам как $x * yPos + y$, поскольку программа будет работать быстрее если ее данные расположены последовательно.

# Встроенный аллокатор
#do/important_start 
1. https://habr.com/ru/post/274827/
2. https://habr.com/ru/post/505632/ - это как я понял перевод или конспект вот этого https://github.com/mtrebi/memory-allocators#benchmarks
3. Можно сначала прочитать перевод, а потом уже оригинал
4. реализация malloc https://danluu.com/malloc-tutorial/

# Фрагментация памяти, требования к выравниванию, минимальный кусок выделяемой памяти
#do/start найти инфу

# Переопределение new/ delete и placement new
#do/important_start найти инфу
## Перегрузка new && delete
Что делает new?
1. Выделяет память
2. Вызывает конструктор объекта
3. Возвращает указатель
```cpp
void* operator new(size_t size);
void* operator new[](size_t size);
void* operator new(size_t size, const std::nothrow_t&) noexcept;
void* operator new[](size_t size, const std::nothrow_t&) noexcept;
```

Есть также функции которые на уже выделенной памяти вызывают конструктор объекта, чтобы занять ее - это функции называются placement new операторы, но C++ запрещает перегружать их

```cpp
void* operator new(size_t size, void* p) noexcept;
void* operator new[](size_t size, void* p) noexcept;

void* ptr { allocateMemorySomehow() };
SpreadsheetCell* cell { new (ptr) SpreadsheetCell{} };
```

Почему это полезно? Мы не тратим время на алоцирование памяти.

Что делает delete?
1. Вызывает деструктор для объекта
2. Очищает память
```cpp
void operator delete(void* ptr) noexcept;
void operator delete[](void* ptr) noexcept;
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* ptr, void*) noexcept;
void operator delete[](void* ptr, void*) noexcept;
```

Перегрузки nothrow и placement delete используется в том случае, если конструктор выбрасывает исключение. В таком случае выбираем тот delete который соответствует new. Если мы удаляем объект как обычно `delete delete[]`, то вызовется обычная перегрузка(не nothrow и placement). Placement delete не особо полезен, поскольку placement new не выделяет память, соответственно placement delete не удаляет ее.


Стоит переопределять new и delete только для специфичных классов, при создании объекта этого класса будут вызываться переопределенные операторы. Если мы переопределяем new, то должны переопределить соответствующую форму оператора delete, иначе вызовется встроенный delete, который может неправильно очистить память.

Пример переопределения:

```cpp
class MemoryDemo
{
public:
	virtual ~MemoryDemo() = default;
	void* operator new(size_t size);
	void operator delete(void* ptr) noexcept;
	void* operator new[](size_t size);
	void operator delete[](void* ptr) noexcept;
	void* operator new(size_t size, const std::nothrow_t&) noexcept;
	void operator delete(void* ptr, const std::nothrow_t&) noexcept;
	void* operator new[](size_t size, const std::nothrow_t&) noexcept;
	void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
};

void* MemoryDemo::operator new(size_t size)
{
	cout << "operator new" << endl;
	return ::operator new(size);
}
void MemoryDemo::operator delete(void* ptr) noexcept
{
	cout << "operator delete" << endl;
	::operator delete(ptr);
}
void* MemoryDemo::operator new[](size_t size)
{
	cout << "operator new[]" << endl;
	return ::operator new[](size);
}
void MemoryDemo::operator delete[](void* ptr) noexcept
{
	cout << "operator delete[]" << endl;
	::operator delete[](ptr);
}
void* MemoryDemo::operator new(size_t size, const nothrow_t&) noexcept
{
	cout << "operator new nothrow" << endl;
	return ::operator new(size, nothrow);
}
void MemoryDemo::operator delete(void* ptr, const nothrow_t&) noexcept
{
	cout << "operator delete nothrow" << endl;
	::operator delete(ptr, nothrow);
}
void* MemoryDemo::operator new[](size_t size, const nothrow_t&) noexcept
{
	cout << "operator new[] nothrow" << endl;
	return ::operator new[](size, nothrow);
}
void MemoryDemo::operator delete[](void* ptr, const nothrow_t&) noexcept
{
	cout << "operator delete[] nothrow" << endl;
	::operator delete[](ptr, nothrow);
}

int main()
{
	MemoryDemo* mem{ new MemoryDemo{} };
	delete mem;
	mem = new MemoryDemo[10];
	delete[] mem;
	mem = new (nothrow) MemoryDemo{};
	delete mem;
	mem = new (nothrow) MemoryDemo[10];
	delete[] mem;
}
/*
	operator new
	operator delete
	operator new[]
	operator delete[]
	operator new nothrow
	operator delete
	operator new[] nothrow
	operator delete[]
*/
```

Мы можем явно сделать delete/default операторы new и delete

```cpp
class MyClass
{
public:
	void* operator new(size_t size) = delete;
	void* operator new[](size_t size) = delete;
};

int main()
{
	MyClass* p1 { new MyClass };//error
	MyClass* p2 { new MyClass[2] };//error
	//явно удалили операторы, теперь мы не сможем динамически создавать этот класс
}
```

Дальше идет с лекции ВЛадимирова

```cpp
int* n = new int(5);//выделяеям память и конструируем объект
n = (int *) ::operator new(sizeof(int));//используем глобальный оператор, происходит только выделение, отличается от malloc тем что может бросить исключение
```

Мы можем переопределить глобальный оператор

```cpp
void *operator new(std::size_t n) {  
    void *p = malloc(n); if (!p) throw std::bad_alloc{};  
    printf("Alloc: %p, size is %zu\n", p, n);  
    return p;  
}  
void operator delete(void *mem) noexcept {  
    printf("Free: %p\n", mem);  
    free(mem);  
}  
int main()  
{  
    std::list<int> l;  
    l.push_back(42);  
    //Alloc: 0x556517ae6eb0, size is 24  
    //Free: 0x556517ae6eb0}
```

При использовании new[] стандарт гарантирует, если вызовется исключение на n объекте, то все ранее созданные удалятся.

Есть операторы которые не кидают исключения noexcept - то есть malloc

```cpp
p = new (nothrow) int{42}; 
p = (int *) ::operator new(sizeof(int), nothrow); *p = 42;
```

### Перегрузка операторов new и delete с extra параметрами
Можем передать в оператор специальный флаг или счетчик

```cpp
class MemoryDemo
{
public:
	void* operator new(size_t size, int extra)
	{
		cout << "operator new with extra int: " << extra << endl;
		return ::operator new(size);
	}
	void operator delete(void* ptr, int extra) noexcept
	{
		cout << "operator delete with extra int: " << extra << endl;
		return ::operator delete(ptr);
	}
};

int main()
{
	MemoryDemo* memp { new(5) MemoryDemo{} };
	delete memp;//вызовется обычный delete
}
/*
	operator new with extra int: 5
	operator delete
*/
```

### Перегрузка оператора delete с размером памяти как параметром
Если в вашем классе объявлены две версии delete - одна с параметром size, другая нет, то всегда будет вызываться версия без параметра. Чтобы этого избежать нужно объявить только версию с параметром


//ВЛадимиров

```cpp
void MemoryDemo::operator delete(void* ptr, size_t size) noexcept
{
	cout << "operator delete with size " << size << endl;
	::operator delete(ptr);//не существует глоабльного delete который принимал бы размер
}
```

Этот оператор нельзя перегрузить, конструирует объект на выделенной памяти

```cpp
void* operator new(std::size_t size, void* ptr) noexcept; 
void* operator new[](std::size_t size, void* ptr) noexcept;

void *raw = ::operator new(sizeof(Widget), std::nothrow); 
if (!raw) { обработка } 
Widget *w = new (raw) Widget;//раз вызываем рука конструктор, то
//...
w->~Widget();//должны сами вызвать деструктор
::operator delete(raw);
```

Мы можем определить оператор new/delete для класса и они могут иметь сколько угодно аргументов, т.е. сколько угодно может перегружать в свое классе.

```cpp
void *operator new(std::size_t n) {  
    void *p = malloc(n);  
    if (!p)  
        throw std::bad_alloc{};  
    printf("Alloc: %p, size is %zu\n", p, n);  
    return p;  
}  
  
void operator delete(void *mem) noexcept {  
    printf("Free: %p\n", mem);  
    free(mem);  
}  
  
struct Widget {  
    static void *operator new(std::size_t n);  
    static void operator delete(void *mem) noexcept;  
    int n[4];  
};  
  
void *Widget::operator new(std::size_t n) {  
    void *p = malloc(n);  
    if (!p)  
        throw std::bad_alloc{};  
    printf("Custom alloc: %p, size is %zu\n", p, n);  
    return p;  
}  
  
void Widget::operator delete(void *mem) noexcept {  
    printf("Custom free: %p\n", mem);  
    free(mem);  
}  
  
int main() {  
    std::list<int> l;  
    l.push_back(42);  
    Widget *w = new Widget;  
    delete w;  
    //Alloc: 0x55b1f9183eb0, size is 24  
    //Custom alloc: 0x55b1f91842e0, size is 16    
    //Custom free: 0x55b1f91842e0    
    //Free: 0x55b1f9183eb0
}
```

[[Перегрузка операторов#Перегрузка new delete]]

# Многопоточность и аллокация памяти
#do/important_start 

# Работа с указателями
Мы можем изменить адрес указателя так:

```cpp
char* scaryPointer { (char*)7 };
// указатель имеет адрес 0x0000000000000007, т.е. мы можем вот так вот указывать на чужие данные, что не есть хорошо это UB
```

## C style Касты указателей
```cpp
Document* documentPtr { getDocument() };
char* myCharPtr { (char*)documentPtr };
```

Указатели слабо типизированы, используя c style касты мы можем легко привести их к любому типу, в C++ есть [[casting#static_cast|static_cast]] которые являются более безопасными

# Стек
У каждой функции есть локальные переменные, они хранятся на стеке(область оперативной памяти)

```cpp
void second () { 
	int s_a = 3; 
	double s_d = 2.0; 
} 
void first () { 
	int f_a = 2; 
	char f_c = 'a'; 
	second (); 
} 
int main () { 
	int a = 1; 
	char c = 'r'; 
	first (); 
	second (); 
	a = 2; 
	c = 'q'; 
}
```

Когда на стеке запускается очередная функция, то на стеке резервируется блок памяти, достаточный для хранения локальных переменных. Помимо этого он хранит такую служебную информацию как адрес возврата. Такая область памяти называется стековым фреймом функции.

![[../Files/Pasted image 20220216105531.png]] 

Когда функция `main` запускает функцию `first`, то на стеке ниже функции `main` резервируется фрейм для функции `first`. То же самое происходит, когда функция `first` вызывает функцию `second`.

Когда функция `second` завершает свою работу, то вершина стека перемещается на фрейм предыдущей функции. При этом фрейм отработавшей функции просто остаётся на стеке.

![[../Files/Pasted image 20220216105913.png]]

 Выйдем из функции `first` в функцию `main`, запустим функцию `second` из `main`. Стековый фрейм перетирает данные, которые были в стеке от предыдущих вызовов. Если мы не сами не инициализируем переменные, то ей присвоятся значения, которые были тут от другого фрейма, поэтому важно сразу инициализировать значения, чтобы избегать непредвиденных ситуаций.
 
Когда выходим из программы, то вершина стека поднимается до самого верха.

 ```cpp
void fill(istream& is , vector& ints) { 
	int x; 
	while (is >> x) { 
		ints. push_back (x); 
	} 
} 
int main () { 
	vector ints1 , ints2; 
	istringstream is1("1 2 3 4"); 
	fill(is1 , ints1); 
	istringstream is2("5 7"); 
	fill(is2 , ints2); 
} 
```

После завершения работы функции `fill` в куче будет выделен блок памяти, достаточный для хранения четырех целых чисел. При этом вектор `ints1` будет ссылаться на эту область памяти в куче и будет иметь доступ к своим элементам.

![[../Files/Pasted image 20220216110537.png]]

Когда `fill` отработает во второй раз, то в куче будет выделен отдельный блок памяти, достаточный для хранения двух целых чисел(если бы мы использовали стек, то данные бы просто перезаписались).