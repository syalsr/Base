## Отключение специальных методов
Мы не можем использовать enable_if для стандартных копирующих и перемещающих конструкторов и операторов присваивания, потому что шаблоны методов никогда не учитываются как специальные методы и игнорируются, когда, например требуется копирующий конструктор.

```cpp
class C {  
public:  
    C(){}  
    template<typename T>  
    C (T const&) {  
        std::cout << "tmpl copy constructor\n";  
    }  
};  
  
int main()  
{  
    C c{};  
    C f{c};//вызывается нешаблонный созданный компилятором конструктор копирования  
}
```

Если удалим конструктор копирования для объекта const volatile, все будет хорошо

```cpp
class C {  
public:  
    C(){}
	C(C const volatile&) = delete;
    template<typename T>  
    C (T const&) {  
        std::cout << "tmpl copy constructor\n";  
    }  
};  
  
int main()  
{  
    C c{};  
    C f{c};//используется шаблон конструктора
}
```