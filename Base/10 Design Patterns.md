# 10 Design Patterns
Паттерны проектирования были придуманы несколькими программистами, чтобы выделить и закрепить прошлый опыт решения архитектурных задач. Классические паттерны делятся на порождающие, структурные и поведенческие.

# Полезное
1. [Introduction to Design Patterns](https://www.patterns.dev/posts/introduction/)
2. 

# Порождающие паттерны
## Фабричный метод 
Cтатический метод, выполняющий функции "виртуального конструктора" 

## Прототип 
То же, но для "виртуального конструктора копирования" 

## Абстрактная фабрика 
Базовый тип для создания в его наследниках групп ассоциированных объектов 

## Синглтон 
Объект с приватным конструктором и статическим методом создания. Например, иногда некий объект идеологически единственный на всю программу:

```cpp
// отображение на экран  
class ViewPort {  
    ViewPort();  
public:  
// ....  
    static ViewPort *queryViewPort();  
};
```

## Строитель 
Кусочное создание объекта для большей гибкости. Например в инфраструктуре LLVM мы хотим работать с любыми даже самыми причудливыми ассемблерами:

```cpp
// we want ADD R0, R1, 1  
MachineInstrBuilder NewMIB(ADD);  
NewMIB.addReg(R0);  
NewMIB.addReg(R1);  
NewMIB.addImm(1);  
MachineInstr *NewMI = NewMIB.get();
```
Здесь MachineInstrBuilder предоставляет методы для гибкого абстрагирования от конкретного синтаксиса и способ создать любую мыслимую инструкцию

# Структурные паттерны
## Адаптер 
Изменяет интерфейс под требования пользователя 

## Декоратор 
Расширяет интерфейс, не изменяя контекст 

## Фасад 
Облегченный интерфейс для сложного контекста 

## Приспособленец (flyweight)
Пул идентичных объектов из которых пользователю либо возвращается существующий либо создаётся новый 

## Мост 
Развязывает семейства конкретных классов через барьеры разделяемых абстракций

![[../Files/Pasted image 20220424141412.png]]

# Поведенческие паттерны
## Команда 
Объект инкапсулирующий одно действие и его параметры 

## Цепочка возможностей 
Серия возможных объектов-обработчиков команды (например обработка и перевыброс исключений) 

## Интерпретатор 
DSL, встроенный в систему 

## Итератор 
Объект для последовательного доступа к объекту, но без раскрытия структуры объекта 

## Посредник 
Абстрагирует взаимодействия объектов, которые могут не знать даже интерфейс друг друга, обмениваясь через посредника 

## Хранитель 
Сериализатор, встроенный в систему

## Наблюдатель
Устанавливает оповещение одного объекта об изменениях в другом 

![[../Files/Pasted image 20220424141852.png]]

```cpp
IntVal subj;  
DIVObs divObs1(&subj, 4); // наблюдает (subj / 4)  
DIVObs divObs2(&subj, 3); // наблюдает (subj / 3)  
MODObs modObs(&subj, 3); // наблюдает (subj % 3)  
subj.setVal(14);  
cout << divObs1.observed() << " "  
	 << divObs2.observed() << " "  
	 << modObs.observed() << " " << std::endl;  
subj.setVal(18); // оповещает всех наблюдателей
```
## Состояние 
Состояние конечного автомата. Имеет поведение и переход в другие состояния. 

## Стратегия 
Общий интерфейс, определяющий методы, совместно используемые объектом для решения соответствующих задач 

## Шаблонный метод 
Невиртуальная часть [[Особые случаи при переопределения методов#Метод базового класса является приватным - идиома NVI|NVI]] это и есть шаблонный метод. 

## Посетитель 
Операция, которая выполняется над объектами других классов

# Антипаттерны 
 http://nishitalab.org/user/paulo/files/resign-patterns.txt

## Детонатор 
Паттерн, который ждёт в вашем коде и готов в любой момент разнести все к чертям 
Хороший пример: отсутствие проверки на нулевой указатель 

## Бригада 
Контейнерный класс для кривого и косого кода, методы в котором были отвергнуты разработчиками остальных классов. Вместе они – БРИГАДА 

## Сыр 
Паттерн сыр полон дыр. Кстати, чем старше сыр, тем крепче запашок 

## Посетитель из ада 
Выход на единицу за границы массива, случайным образом затирающий значение важного флага дальше по стеку 

## Липучка 
Очень плохой код, который вы назначены поддерживать до конца работы в компании (а то и жизни) Примета: коготок в липучке увяз – всей птичке пропасть.