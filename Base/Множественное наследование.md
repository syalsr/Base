# Множественное наследование
## Наследование от нескольких классов
```plantuml
class Dog
class Bird
Dog <|-- DogBird
Bird <|-- DogBird
```

```cpp
class Dog
{
public:
	virtual void bark() { cout << "Woof!" << endl; }
};
class Bird
{
public:
	virtual void chirp() { cout << "Chirp!" << endl; }
};
class DogBird : public Dog, public Bird
{
};

int main()
{
	DogBird myConfusedAnimal;
	myConfusedAnimal.bark();//Woof!
	myConfusedAnimal.chirp();//Chirp!
}
```

1. `DogBIrd` поддерживает публичные методы и содержит данные обоих классов.
2. Методы `DogBIrd` имеют доступ к protected данным и методам в обоих классах.
3. `DogBIrd` может произвести апкаст к `Dog` и `Bird`.
4. Создание `DogBIrd` автоматически вызывает дефолтные конструкторы Dog и Bird, в том порядке в котором классы объявлены.
5. Удаление `DogBIrd` автоматически вызывает деструкторы классов Dog и Bird в обратном порядке объявления классов.

## Коллизия имен
Что произойдет если производный объект будет вызывать метод который находится в обоих базовых класса или использовать данные с одинаковым именем?

```cpp
class Dog
{
public:
	virtual void bark() { cout << "Woof!" << endl; }
	virtual void eat() { cout << "The dog ate." << endl; }
};
class Bird
{
public:
	virtual void chirp() { cout << "Chirp!" << endl; }
	virtual void eat() { cout << "The bird ate." << endl; }
};
class DogBird : public Dog, public Bird
{
};
int main()
{
	DogBird myConfusedAnimal;
	myConfusedAnimal.eat(); // Error! Ambiguous call to method eat()
}
```

Компилятор не будет знать какую версию метода ему вызвать.

Есть 4 способа это исправить:
```cpp
dynamic_cast<Dog&>(myConfusedAnimal).eat(); // Calls Dog::eat()
myConfusedAnimal.Dog::eat(); // Calls Dog::eat()
class DogBird : public Dog, public Bird
{
public:
	void eat() override
	{
		Dog::eat(); // Explicitly call Dog's version of eat()
	}
};
class DogBird : public Dog, public Bird
{
public:
	using Dog::eat; // Explicitly inherit Dog's version of eat()
};
```

## Другой способ вызвать неоднозначность
Дважды наследоваться от одного класса:

```plantuml
class Dog
class Bird
Dog <|-- Bird
Bird <|-- DogBird
Dog <|-- DogBird
```

```cpp
class Dog {};
class Bird : public Dog {};
class DogBird : public Bird, public Dog {}; // Error!
```

## Проблема ромбовидного наследования
```plantuml
Animal <|-- Dog
Animal <|-- Bird
Bird <|-- DogBird
Dog <|-- DogBird
```
```cpp
class Animal
{
public:
	int i = 0;
};
class Dog : public Animal
{
public:
	int g = 0;
};
class Bird : public Animal
{
public:
	int k = 0;
};
class DogBird : public Dog, public Bird
{
public:
	
};

int main()
{
	DogBird dogbird;
	dogbird.g = 2;
	dogbird.k = 1;
	dogbird.i = 5;//error, не понятно, мы обращаемся к Bird::Animal или Dog::Animal
	dogbird.Dog::i = 2;//OK
	dogbird.Bird::i = 3;//OK
}
```

### Виртуальное наследование
С помощью виртуального наследования вызов метода у базового класса перестает быть неоднозначным.
```cpp
class Animal
{
public:
    virtual void eat() = 0;
    virtual void sleep() { cout << "zzzzz...." << endl; }
};
class Dog : public virtual Animal
{
public:
    virtual void bark() { cout << "Woof!" << endl; }
    void eat() override { cout << "The dog ate." << endl; }
};
class Bird : public virtual Animal
{
public:
    virtual void chirp() { cout << "Chirp!" << endl; }
    void eat() override { cout << "The bird ate." << endl; }
};
class DogBird : public Dog, public Bird
{
public:
    void eat() override { Dog::eat(); }
};
int main()
{
    DogBird myConfusedAnimal;
    myConfusedAnimal.sleep(); // Not ambiguous because of virtual base class.
}
```