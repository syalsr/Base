# Конструктор перемещения и перемещающий оператор присваивания
Перемещение в конструкторах и операторах нужно для того, чтобы забрать владение объектом, поскольку он rvalue ref, он временный и скоро удалится, в случае в динамическим массив, мы просто забираем у него указатель на первый элемент себе и зануляем у него, чтобы не было проблем, аллокаций не произошло, в отличие от конструктора копирования
В следующих случаях вызывается конструктор перемещения (move constructor):

![[../Files/Pasted image 20220218114347.png]]

В следующих случаях вызывается оператор перемещающего присваивания (move assignment operator):

![[../Files/Pasted image 20220218114438.png]]

Если у вас есть собственный класс с конструктором копирования, но без конструктора перемещения, то компилятор делает перемещение эквивалентным копированию.

```cpp
template<typename T> 
SimpleVector<T>::SimpleVector(SimpleVector<T>&& other) : ptr(other.ptr_)
	
{ 
	other.ptr_ = nullptr;
} 
// 0 1
```

```cpp
template<typename T>
void SimpleVector<T>::operator=(SimpleVector<T>&& other) 
{ 
	if(this == &other)
		return *this;
	swap(ptr_, other.ptr_);//обменялись данными, теперь наши бывшие данные точно умрут у объекта other
	return *this;
}
```

**Правило 5** - если вы определили(delete к этому тоже относится) один из следующих методов, то должны определить их все:
1. Деструктор
2. Конструктор копирования
3. Оператор присваивания
4. Перемещающий конструктор
5. Оператор перемещающего присваивания

**Правило 0** - если ваш класс требует определение одного из этих методов, а значит их всех, то кроме этих методов класс не должен иметь ничего, поскольку он должен выполнять только одну задачу, то есть либо управлять ресурсами, либо работать с ними, правило 0 о том, чтобы их не определять, для этого надо:
1. Самостоятельно не выделять память в куче
2. Использовать библиотеку STL