# Каналы
**Канал** - это специальный примитивный тип. Он нужен для синхронизации горутин - передачи данных между ними. Работают с конкретным типом, потокобезопасны, похожи на очереди **FIFO**. Каналы хранятся в куче.

Бывает трех типов по направлению работы: **двунаправленные, read-only, send-only**. А также двух типов по вместимости: **буферизованные, не буферизованные**

1) При **не буф-ом** типе горутины общаются по методу рандеву, т.е. встречаются друг с другом лицом к лицу при передаче данных - они синхронизируются. - отправитель блокируется до того, как получатель готов (и наоборот) - отправка всегда происходит до получения - получатель всегда _возвращается_ до отправки - отправитель и получатель **синхронизованны**

2) При **буф-ом** типе отправитель и получатель могут общаться без ожидания друг друга - отправитель отправляет данные и сразу же возвращается - отправитель блокируется только в случае, если буфер полон - получатель блокируется только в случае, если буфер пуст - отправитель и получатель работают **независимо**

**Стандартные кейсы использования буферизированных каналов:** 1) обойти утечку горутин 2) обойти "рандеву" паузы **Не нужно использовать бафер покуда не будет портебности** - буферизация может привести к состоянию гонки. Может понадобится тестирование для определения объема буфера.

**Структура канала** Самые интересные 1-4 поля
```go
type hchan struct {
    buf unsafe.Pointer // кольцевая очередь
    sendx uint         // индекс для записи
    recvx uint         // индекс для чтения
    lock mutex 
    qcount uint        // всего данных в буфере
    dataqsiz uint      // размер буфера
    elemsize uint16    // размер элемента в канале
    closed uint32      // 0 - открыт, 1 - закрыт
    elemtype *_type    // тип элемента
    recvq waitq        // лист ожидания на чтение
    sendq waitq        // лист ожидания на запись
}
// очередь горутин
type waitq struct {
    first *sudog // линкедлист горутин
    last  *sudog
}
```

**Select** нужен, чтобы читать данные из канала без блокировок. Имеет default. 1. сase сортируется. 2. Выбирается первый, который пожет продолжить исполнение. 3. Если такого нет, горутина делает park и ждет, пока она не будет разбуждена действием над каналом. 4. Отправка/чтение/закрытие канала в другой горутине вызывает функцию goready -> select просыпается и продолжает выполнение.

**Правила работы с каналами**
![[../Files/Pasted image 20220928220607.png]]

![[../Files/Pasted image 20220725071659.png]]

Канал представляет собой механизм связи, который позволяет одной горутине отправлять некоторые значения другой горутине. Каждый канал является средством передачи значений определённого типа, который называется типом элементов канала.
```go
channel := make(chan int)    // channel имеет тип 'chan int'
```

Как и отображение, канал является ссылкой на структуру данных. Копируя или передавая канал в функцию в качестве аргумента, мы копируем ссылку на одну и ту же структуру данных. Нулевым значением канала является nil.

Канал имеет две основные операции:
-   **Отправление (запись)** - передаёт через канал значение из одной горутины в другую. `channel <- num // отправляет в канал channel значение num`
-   **Получение (чтение)** - получение через канал значения из другой горутины. `num = <- channel // получение из канала channel в переменную num`

Чтение из канала может производится в цикле:
```go
for v := range channel {//чтение будет осуществляться пока канал открыт
    ...
}
```

Каждый канал имеет длину и емкость (их можно получить с помощью знакомых нам функций len() и cap()): длина - количество значений в канале в текущий момент, емкость - размер буфера.
```go
c := make(chan int, 1)      // здесь 1 - размер буфера  
fmt.Println(len(c), cap(c)) // 0 1  
c <- 1  
fmt.Println(len(c), cap(c)) // 1 1  
<-c  
fmt.Println(len(c), cap(c)) // 0 1
```

## Определение канала на запись/чтение
Открывает и закрывает канал тот кто в него пишет.
```go
func worker(done chan<- struct{})//запись
func worker(done <-chan struct{})//чтение
```

## close - закрытие канала
Каналы поддерживают операцию закрытия встроенной функцией close:
```go
close(channel)
```

1. Запись в закрытый канал приведет к панике
2. Но читать можно - будут получены все значения, которые были отправлены, но еще не прочитаны. После получения всех значений из канала, будет возвращаться нулевое значение типа канала.

Чтобы понимать, что мы получаем 0  который прислала другая горутина, а не zero value поскольку буфер пуст, нужно проверять корректность
```go
v, ok := <- ch
if !ok{

}
```

## select
select - аналог switch case, но нужен для получения данных из канала 
```go
func worker(done chan<- string) {  
   time.Sleep(100 * time.Millisecond)  
   done <- "Hello"  
}  
func worker1(done chan<- string) {  
   time.Sleep(100 * time.Millisecond)  
   done <- "Hello11"  
}  
func main() {  
   ch1, ch2 := make(chan string), make(chan string)  
  
   go worker(ch1)  
   go worker1(ch2)  
  
LOOP: //LOOP - метка, чтобы прервать цикл for, а не select  
   for {  
      select {  
      case str, ok := <-ch1:  
         fmt.Println(str, " ", ok)  
         break LOOP  
      case str, ok := <-ch2:  
         fmt.Println(str, " ", ok)  
         break LOOP  
      default:  
         time.Sleep(10 * time.Millisecond)  
      }  
   }  
}
```

В зависимости от того, какой канал успел записать, то и выведется. default работает, если остальные заблокированы

## Буферизированный
Буферизованные каналы представляют из себя [[std queue]], операция отправления в буферизованный канал добавляет элемент в конец очереди `channel <- "A"`, операция извлечения, извлекает первый элемент из очереди `fmt.Println(<-channel) // "A"`.

Если канал заполнен, операция отправления блокирует свою горутину, до тех пор, пока другая горутина не освободит место, получив данные из канала.
```go
chan := make(chan int, 2)
chan <- 1//ok
chan <- 1//ok
chan <- 1//deadlock
```

## Небуферизированный
При взаимодействии с небуферизованным каналом важно знать:
1. При отправление значения в небуферизованный канал, отправляющая горутина блокируется до тех пор, пока другая горутина не выполнит получение из этого канала. После этого обе горутины продолжают работать. 
2. Если горутина получает значение, она блокируется, пока другая горутина не отправит новое значение в канал.
```go
func worker(ch chan int, wg *sync.WaitGroup) {  
   defer wg.Done()  
   value := <-ch  
   fmt.Printf("%d\n", value)  
}  
func main() {  
   wg := new(sync.WaitGroup)  
  
   channel := make(chan int)  
  
   wg.Add(1)  
   go worker(channel, wg)  
   channel <- 1 //без этого был бы deadlock  
   wg.Wait()  
}
```

Если же размер буфера будет 0, то выполнение программы приведет к панике, так как записанное значение одновременно с записью в канал не вычитывается.

```go
pipe := make(chan int)     // небуферизованный канал
pipe := make(chan int, 0)  // небуферизованный канал
pipe := make(chan int, 5)  // буферизованный канал с ёмкостью 5
```

Небуферизованные каналы дают более надежные гарантии синхронизации, потому что каждая операция отправления связана с операцией получения. В случае буферизованных каналов, эти операции разделены.

# Блокировки
Горутины блокируются для повышения производительности неработоспособных каналов.

## Блокировка при записи
Горутина, посылающая данные в канал, блокируется, покуда другая горутина не прочитает данные из него.

## Блокировка при чтении
Горутина, получающая данные из канала,  может быть заблокирована до момента получения данных в канал. Аналогично блокировке при записи.

# select
Используя конструкцию _**select-case**_ можно избежать блокирующего поведения.
```go
package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:
			x, y = y, x+y
		case <-quit:
			fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
```
Если данные есть, горутина их прочитает, иначе выйдет из функции.