# Перегрузка функций
1. Три правила для обычных функций 
	1. Идеальное совпадение выигрывает 
	```cpp
void foo(int x); // 1
void foo(short x); // 2
foo(1); // → 1

void foo(const int& x); // 1
void foo(short x); // 2
foo(1); // → 1

void foo(const int& x); // 1
void foo(int x); // 2
foo(1); // → FAIL, два идеальных совпадения это конфликт
```
	2. Все стандартные преобразования равны 
	```cpp
void foo(char x); // 1
void foo(long x); // 2
foo(1); // → FAIL

struct MyClass { MyClass(int x) {} };
void foo(char x); // 1
void foo(MyClass x); // 2
foo(1); // → 1, Любые стандартные преобразования выигрывают у пользовательских, хоть и у класса есть преобразования int
```
	3. Троеточия проигрывают почти всему
```cpp
void foo(int x); // 1
void foo(long x); // 2
void foo(MyClass x); // 3
void foo(...); // 4
foo(1); // → 1, 2, 3 и только потом 4

void foo(...); // 1
void foo(int& x); // 2
foo(1); // → 1, троеточия выигрывают только у неправильных ссылок
```

Перегрузки можно запрещать:

```cpp
int foo(int x) { return x + 42; }
int foo(bool) = delete;
int foo(char) = delete;

//Но они участвуют в подстановке 
int t = foo (true); // ошибка, а не преобразование к int
```

Разрешаются перегрузки между всеми функциями, даже если они не доступны.

```cpp
class Bar {
	int foo(int);
public:
	int foo(char);
};
Bar b;
b.foo(1);//выигрывает приватная функция foo(int)
```