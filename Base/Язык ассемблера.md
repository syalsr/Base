# Язык Ассемблера
Для каждой архитектуры существует свой ассемблер, свой набор команд [[ISA]]

1. Инструкции копирования можно разделить на 3 типа:
	1. Память => регистр
	2. Регистр => регистр
	3. Память => память(редко)
2. Арифметические инструкции: 
	1. + 
	2. -
	3. /
	4.  *
3. Побитовые инструкции
	1. `>>`
	2. `<<`
4. Инструкции перехода, для того чтобы перейти к другому участку кода
5. А также множество специфичных инструкций

Регистры - это очень быстрые, поименованные ячейки памяти.
1. Регистры специального назначения
	1. Указатель команд IP - содержит адрес следующей инструкции или последней исполненной
	2. Флаговый регистр - хранит состояние процессора
	3. И т.д.
2. Регистры общего назначения
	1. Арифметические операции

## Далее будем говорить об архитектуре X86-64.

1. Указатель команд - RIP
2. Флаговый регистр - RFLAGS
	1. ZF = результат операции 0
	2. CF - произошло беззнаковое переполнение
	3. OF - произошло знаковое переполнение
3. Регистры общего назначения
	1. Указатель стека rsp
	2. Указатель базы(указатель стек фрейма) rbp
	3. rax, rbx, rcx; rdx, rsi, rdi; r8-r15
4. Инструкции
	1. mov - инструкция копирования, movq - q означает, что мы копируем 8 байтное значение
		1. `movq<src>, <dst>`
		2. `movq %rax, %rbx` - копируем значение rax в rbx
		3. `movq (%rax), %rax` - разыменовываем регистр rax, берем его значение, интерпретируем как адрес, идем в этот адрес и копируем в rax значение лежащее по этому адресу
		4. `movq $42, %rax` - записываем 42 в rax
		5. `movq 42, %rax` - 42 - адрес, идем по этому адресу и копируем значение в rax
	2. `addq <src>, <dst>` - складываем значения и результат сохраняем во 2 аргумент
		1. `addq %rax, %rbx` - $rbx=rax+rbx$
		2. `%rax, value` $value=rax+value$
		3. `42, %rax` $rax +=42$
	3. `subq <src>, <dst>` - вычитаем 1 аргумент из 2-го и сохраняем результат во 2 аргумент.
	4. `incq <op>` - +1 инкремент
	5. `decq <op>` - -1 декремент
	6. `mulq <op>` - умножение, в качестве 2 аргумента используется rax, старшие биты результат сохраняются в rax, младшие биты в rdx 
		1. $rax=(<op>*rax)mod2^{64}$
		2. $rdx=(<op>*rax)/2^{64}$
	7. `divq <op>` - вычисляет частное в rax и остаток от деления в rdx
		1. $rax=(rdx*2^{64}+rax)/<op>$ 
		2. $rdx=(rdx*2{64}+rax)mod<op>$
	8. `cmpq <src>, <dst>` - вычисляет разность, работает как subq, но dst не не изменяет src, dst, только RFLAGS

## Стек
Это область памяти на которую указывает rsp, в X86 стек растет вниз, т.е. чем раньше создался стековый фрейм, тем больше его адрес
1. `pushq <src>` - сдвигаем rsp на 8 байт и сохраняем src в rsp
	1. `pushq $42`
	2. `pushq %rax`
2. `popq <dst>` - удаляет значение со стека и сохраняет в dst
	1. `popq %rax`
	2. `movq (%rsp), %rax`
![[../Files/Pasted image 20220504104336.png]]
![[../Files/Pasted image 20220504104620.png]]

## Метка
Это имя которое ссылается на какой-то адрес в памяти

```asm
value:
		.quad 42 # ссылается куда-то где есть 42
add42: # указывает на начало этого кода
		movq %rdi, %rax
		...
		retq # возврат из функции
```
Чтобы куда-то вернуться нужно сохранить адрес возврата, процессор сохраняет следующий адрес которой идет после call в стек. Поэтому если мы в вызываемой функции, что-то пишем на стек, то должны очистить, иначе вернемся не туда.
![[../Files/retq.png]]
## Инструкции перехода
1. `jmp <label>` - инструкция безусловного перехода
2. `call <label` - инструкция вызова функции

## Инструкции условного перехода
1. `jcc <label>` - выполняет переход, если условие cc истинно
2. jz, je проверяет, что $ZF=1$
	1. `subq $42, %rax; je do_smth` - если $rax=42$, то выполнится переход
	2. jne, jnz - $ZF=0$
	3. jg - если больше(знаковый вариант)
	4. jge - больше или равно(знаковый вариант)
	5. ja - если больше(беззнаковый вариант)
	6. jae - больше или равно(беззнаковый вариант)

```asm
max: # поиск максимального значения в rdi и rsi
		movq %rdi, %rax
		cmpq %rsi, %rdi
		ja   rdi_get  # инструкции выполняются последовательно, если ja сработало retq
		movq %rsi, %rax # иначе будет выполнена эта функция и потом мы пойдем дальше до retq
rdi_get:
		retq
```
