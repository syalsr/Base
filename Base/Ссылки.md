# Ссылки
Ссылки - псевдонимы(alias) на другую переменную. Т.е. ссылка становится этой переменной, все что происходит с ссылкой, то и происходит с переменной, но т.о. мы не тратим доп. память на создание такой же переменной. Ссылка, можно сказать, это константный указатель, мы можем изменять значение ссылки, но не то на что оно ссылается.

```cpp
int x { 3 };
int& xRef { x };
xRef = 10;//x=10
int& emptyRef;//error, ссылки всегда должны на что-то указывать
```

Константная ссылка - это константный указатель на константу. Мы не можем изменить не объект на который ссылка ссылается, не саму ссылку.

```cpp
int z;
const int& zRef { z };
zRef = 4; // DOES NOT COMPILE
```

non-const ref должна быть инициализирована [[rvalue lvalue reference|lvalue]]

Константная ссылка продлевает время жизни объекта, т.е. мы можем присвоить ей временное значение, допустим целочисленный литерал, возвращаемое значение функции, и эта ссылка сохранит его в памяти, иначе со следующей строки, временный объект уничтожился бы.

```cpp
int& unnamedRef1 { 5 }; // DOES NOT COMPILE
const int& unnamedRef2 { 5 }; // Works as expected

string getString() { return "Hello world!"; }
string& string1 { getString() }; // DOES NOT COMPILE
const string& string2 { getString() }; // Works as expected
```

Ссылка живет до конца своего выражения:

```cpp
struct S{
	int x;
	const int& y;
}

S x{1,2};//ok x=1, y=2, продлили время жизни объекта, он умрет когда x выйдет из скоупа
S* p = new S{1,2};//bad, у нас выражение new S{1,2}, после того как оно завершится, т.е. выделится память и вызовется конструктор, временный объект уничтожится и мы получим висячую ссылку
```

# Ссылка на указатель и указатель на ссылку
```cpp
int* intP { nullptr };
int*& ptrRef { intP };
ptrRef = new int;
*ptrRef = 5; //intP = 5
```

Мы не можем определить ссылку на ссылку и ссылку на указатель.

# Ссылка как возвращаемое значение функции
Можем вернуть ссылку на переменную из функции, но только если она продолжает жить после завершения работы функции, иначе получается мы возвращаем локальную ссылку которая уничтожается во время завершения функции, а это UB.

Зачем возвращать ссылки? Если мы хотим использовать их как lvalue, полезно для конвейерного вызова методов

```cpp
class Build
public:
	Build() {}
	Build& BuildFactory() { return *this;}
	Build& BuildHouse()  { return *this;}
};
int main()
{
	Build b;
	b.BuildFactory().BuildHouse();
}
```

# Различия между ссылка и указателями
1. Все что мы можем сделать с помощью ссылок, можно сделать с помощью указателей
2. Ссылки делают код чище и понятнее
3. В большинстве случае используют ссылки, но есть случаи когда нужны указатели.
	1. Использование динамической памяти
	2. Использование полиморфных объектов в контейнерах
	3. Когда нужно опционально его использовать, т.е. либо он на что-то указывает, либо на nullptr.

#do/review 
1. Возможно что-то убрать, к примеру часть с ссылка как возврат. знач. возможно в ООП у нас про это написано
2. Если нет, то добавить в файл слинковать все это
3. 