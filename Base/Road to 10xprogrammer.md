# Road to 10xprogrammer
## C++ все расположено в порядке изучения, кроме самих топиков
* [x] АКОС
	* [x] [Первый 3 лекции по ассемблеру](https://www.youtube.com/playlist?list=PLd7QXkfmSY7a2zw_PVPn7vKs9F9BG6Pd4)
	* [x] Лекции 4-8 по [акосу](https://www.youtube.com/playlist?list=PLd7QXkfmSY7a2zw_PVPn7vKs9F9BG6Pd4)
	* [x] Лекции 11-12 по [сборке](https://www.youtube.com/playlist?list=PLd7QXkfmSY7a2zw_PVPn7vKs9F9BG6Pd4)
	* [x] [КСЦ Операционные системы](https://stepik.org/course/1780/syllabus)  
* [ ] **Математика**  
    * [ ] Мат. логика  и теория алгоритмов  
        * [ ] [Дашков 1 семестр](https://www.youtube.com/playlist?list=PL4_hYwCyhAvb4c-Z43ppdKwC1hWX6hOYi)  
        * [ ] [Дашков 2 семестр](https://www.youtube.com/playlist?list=PL4_hYwCyhAvYJx5swFZ7-ZDJV9LhLIdqD)  
    * [ ] Комбинаторика  
        * [ ] Виленкин до 144 страницы  
    * [ ] Дискретная математика  
        * [ ] Сюзанна
    * [ ] Алгоритмы и структуры данных  
        * [x] Грокаем алгоритмы  
        * [ ] [КСЦ Алгоритмы. Теория. Практика. Методы](https://stepik.org/course/217/syllabus)  
        * [ ] Формальные языки
            * [ ] [2019](https://www.youtube.com/playlist?list=PL4_hYwCyhAvbl7pkWGbeOjWyU-z7hDnlb)  
            * [ ] [2021](https://www.youtube.com/playlist?list=PL4_hYwCyhAvYkVw2wY5Ax6Mq79vBGbze3)
        * [ ] LeetCode
* [ ] C++
    * [x] Белый пояс  
    * [x] Желтый пояс  
    * [x] Красный пояс  
    * [ ] Коричневый пояс  
    * [x] Марк Грегоир Профессиональный C++ **больше 20 часов**  
    * [x] Базовые лекции Константина Владимирова 35 часов, кроме концептов и метапрограммирования
    * [x] ПРО лекции Константина Владимирова
        * [x] strings, function templates, class templates, exceptions, type deduction, rvalue, variadic, lambda, smart pointers
        * [ ] Asynchronous, Concurency, Atomicity, Allocators, SFINAE, Meta, constexpr
        * [ ] Coroutines, Ranges, Modules, Concepts
    * [ ] C++ Templates The Complete Guide - Basic and In Depth  
        * [x] basic 18 часов 38 минут
        * [ ] depth
    * [x] Тулчейн ГЦЦ Константина Владимирова  2 часа, посмотрел 1.5 лекции, пиздец как не понятно почти все, в общем вернусь к этому как нибудь через годик, когда лучше изучу акос, наверно, найду что-нибудь по проще по сборке
* [ ] Многопоточность  
    * [ ] https://www.youtube.com/watch?v=z6M5YCWm4Go
    * [ ] https://www.youtube.com/playlist?list=PLlb7e2G7aSpQCPeKTcVBHJns_JOxrc_fT
    * [ ] Липовский - лекции + семинары + репа курса  
    * [ ] Perf book  
* [ ] Проекты
	* [x] vector
	* [x] Allocator
	* [ ] Garbage collector
	* [ ] Транспортный справочник
* [ ] Статьи
* [ ] Видео
* [x] Простая академия - 9 часов 28 минут

## C++ все что нужно знать для начала
* [x] Базовые конструкции
	* [x] Лог. операторы
	* [x] Циклы
	* [x] Арифметические операции
	* [x] Битовые операции
* [x] Функции
	* [x] Функторы
	* [x] Лямбды
* [x] Типы данных
	* [x] Статическая типизация
	* [x] Динамическая типизация
* [x] Указатели и ссылки
	* [x] Ссылки
		* [x] Провисание ссылок
	* [x] Умные указатели
		* [x] unique_ptr
		* [x] shared_ptr
	* [x] Модель памяти - lifetime objects
	* [x] Сырые указатели
		* [x] new/delete
		* [x] Утечки памяти
	* [x] placement new
	* [x] overload new
* [x] Разделение кода
	* [x] Понимание сборки проектов
	* [ ] Cmake
	* [x] Область видимости
	* [x] Пространство имен
* [x] Структуры и классы
	* [x] ООП
		* [x] Статический полиморфизм
			* [x] Перегрузка методов
		* [x] Динамический полиморфизм
			* [x] Виртуальные методы
			* [x] Таблица виртуальных методов
		* [x] Правило 0/3/5
		* [x] Множественное наследование
			* [x] Ромбовидное наследование
			* [x] Виртуальное наследование
* [x] Обработка ошибок
	* [x] Исключение
	* [x] Проброс исключений
	* [x] Вложенные исключения
* [x] Концепции языка
	* [x] auto
	* [x] type casting
		* [x] static_cast
		* [x] const_cast
		* [x] dynamic_cast
		* [x] reinterpret_cast
	* [ ] UB
	* [x] Макросы
* [ ] STL
	* [x] IO streams
	* [x] File stream
	* [ ] Дата/время
	* [x] Контейнеры
	* [x] Итератоы
	* [x] Алгоритмы
	* [ ] Многопоточность
* [ ] Шаблоны
	* [x] variadic
	* [x] специализация
		* [x] полная
		* [x] частичная
	* [x] type deduction
	* [x] type traits
	* [ ] sfinae
* [ ] Идиомы
	* [x] RAII
	* [x] pimpl
	* [x] non-copyable/non-moveable
	* [x] erase-remove
	* [x] copy and swap
	* [x] copy on write
	* [ ] CRTP
	* [ ] Covariant Return Types
	* [x] Empty Base Optimization
	* [ ] enable if
	* [x] Small Object Optimization
	* [ ] Type erasure
* [ ] Алгоритмы
	* [x] Сложность алгоритмов
	* [ ] Динамическое программирование
	* [ ] Жадные алгоритмы
	* [ ] Графы
		* [x] BFS
		* [x] DFS
		* [ ] Алгоритм Беллмана-Форда
	* [x] sort
		* [x] quick sort
		* [x] bubble sort
	* [x] bin search
* [ ] Конечные автоматы
* [ ] Структуры данных
	* [ ] Деревья
		* [x] двоичное дерево
		* [ ] черно красное дерево
		* [ ] Сбалансированные деревья – AVL-дерево
	* [x] Графы
	* [x] hash table
	* [x] forward, bidirectional list
	* [x] Динамический массив
	* [x] stack
	* [x] queue
	* [x] priority_queue
* [ ] Принципы разработки
	* [x] KISS - keep it simple, stupid
	* [x] DRY - dont repeat yourself
	* [ ] YAGNI - you arent gonna need it
	* [x] APO - avoid premature optimization
	* [ ] BDUF - big design up front
	* [x] Композиция предпочтительнее наследования
	* [ ] Бритва Оккама
	* [x] Разделяй и властвуй
* [ ] Архитектура ПО
	* [x] UML
	* [x] SOLID
	* [ ] GOF
* [ ] АКОС
	* [ ] Статическая библиотека
	* [ ] Динамическая библиотека
	* [ ] Память
		* [x] Стек
		* [ ] Куча
		* [ ] Глобальная память
		* [ ] Память приложения
		* [x] Выравнивание
		* [ ] Управление памятью
		* [ ] Виртуальная память
	* [ ] Потоки
		* [ ] Ошибки
			* [x] Dead lock
			* [x] Race condition
			* [x] Live lock
			* [ ] Starvation
		* [ ] Concurency
			* [x] Мьютексы
			* [ ] Семафоры
			* [ ] lock-free алгоритмы и структуры данных
	* [ ] Процессы
		* [ ] Межпроцессное взаимодействие
			* [ ] shared memory
	* [ ] Файловая система
* [x] Сети
	* [x] TCP/IP
		* [x] Сокеты
			* [x] TCP
			* [x] UDP
		* [x] HTTP
	* [x] OSI
* [ ] Английский язык для чтения статей

# Jossutis c++11
* [x] pairs
* [x] tuples
* [x] shared_ptr
* [ ] weak_ptr 84-98
* [ ] unique_ptr до 114
* [x] type traits До 134
* [x] 5.4.1 Purpose of Type Traits 
	* [x] 5.4.2 Type Traits in Detail 
	* [x] 5.4.3 Reference Wrappers 
	* [x] 5.4.4 Function Type Wrappers .
* [x] Auxiliary Functionsдо
	* [x] 5.5.1 Processing the Minimum and Maximum
	* [x] 5.5.2 Swapping Two Values 
	* [x] 5.5.3 Supplementary Comparison Operators
* [ ] Compile-Time Fractional Arithmetic with Class ratio<> . . . . . . . . . . . . . 140
* [ ] 5.7 Clocks and Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
	* [ ] 5.7.1 Overview of the Chrono Library . . . . . . . . . . . . . . . . . . . . . . 143
	* [ ] 5.7.2 Durations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
	* [ ] 5.7.3 Clocks and Timepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
	* [ ] 5.7.4 Date and Time Functions by C and POSIX . . . . . . . . . . . . . . . . . 157
	* [ ] 5.7.5 Blocking with Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
* [x] 5.8 Header Files `<cstddef>, <cstdlib>, and <cstring>` . . . . . . . . . . . . . . 161
	* [x]  5.8.1 Definitions in` <cstddef>` . . . . . . . . . . . . . . . . . . . . . . . . . . 161
	* [x] 5.8.2 Definitions in `<cstdlib>` . . . . . . . . . . . . . . . . . . . . . . . . . . 162
	* [x] 5.8.3 Definitions in `<cstring>` . . . . . . . . . . . . . . . . . . . . . . . . . . 163
* [x] 6.1 STL Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
* [x] 6.2 Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
	* [x] 6.2.1 Sequence Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
	* [x] 6.2.2 Associative Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
	* [x] 6.2.3 Unordered Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
	* [x] 6.2.4 Associative Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
	* [x] 6.2.5 Other Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
	* [x] 6.2.6 Container Adapters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
* [x] 6.3 Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
	* [x] 6.3.1 Further Examples of Using Associative and Unordered Containers . . . . 193
	* [x] 6.3.2 Iterator Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
* [x] 6.4 Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
	* [x] 6.4.1 Ranges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
	* [x] 6.4.2 Handling Multiple Ranges . . . . . . . . . . . . . . . . . . . . . . . . . 207
* [ ] 6.5 Iterator Adapters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
	* [x] 6.5.1 Insert Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
	* [ ] 6.5.2 Stream Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
	* [x] 6.5.3 Reverse Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
	* [x] 6.5.4 Move Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
* [x] 6.6 User-Defined Generic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
* [x] 6.7 Manipulating Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
	* [x] 6.7.1 “Removing” Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
	* [x] 6.7.2 Manipulating Associative and Unordered Containers . . . . . . . . . . . 221
	* [x] 6.7.3 Algorithms versus Member Functions . . . . . . . . . . . . . . . . . . . 223
* [x] 6.8 Functions as Algorithm Arguments . . . . . . . . . . . . . . . . . . . . . . . . . 224
	* [x] 6.8.1 Using Functions as Algorithm Arguments . . . . . . . . . . . . . . . . . 224
	* [x] 6.8.2 Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
* [x] 6.9 Using Lambdas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
* [ ] 6.10 Function Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
	* [ ] 6.10.1 Definition of Function Objects . . . . . . . . . . . . . . . . . . . . . . . 233
	* [x] 6.10.2 Predefined Function Objects . . . . . . . . . . . . . . . . . . . . . . . . 239
	* [ ] 6.10.3 Binders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
	* [x] 6.10.4 Function Objects and Binders versus Lambdas . . . . . . . . . . . . . . . 243
* [x] 6.11 Container Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
	* [x] 6.11.1 Requirements for Container Elements . . . . . . . . . . . . . . . . . . . 244
	* [x] 6.11.2 Value Semantics or Reference Semantics . . . . . . . . . . . . . . . . . . 245
* [x] 6.12 Errors and Exceptions inside the STL . . . . . . . . . . . . . . . . . . . . . . . . 245
	* [x] 6.12.1 Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
	* [x] 6.12.2 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
* [x] 6.13 Extending the STL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
	* [x] 6.13.1 Integrating Additional Types . . . . . . . . . . . . . . . . . . . . . . . . 250
	* [x] 6.13.2 Deriving from STL Types . . . . . . . . . . . . . . . . . . . . . . . . . . 251
* [x] 7.1 Common Container Abilities and Operations . . . . . . . . . . . . . . . . . . . . 254
	* [x] 7.1.1 Container Abilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
	* [x] 7.1.2 Container Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
	* [x] 7.1.3 Container Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
* [x] 7.2 Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
	* [x] 7.2.1 Abilities of Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
	* [x] 7.2.2 Array Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
	* [x] 7.2.3 Using arrays as C-Style Arrays . . . . . . . . . . . . . . . . . . . . . . 267
	* [x] 7.2.4 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
	* [x] 7.2.5 Tuple Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
	* [x] 7.2.6 Examples of Using Arrays . . . . . . . . . . . . . . . . . . . . . . . . . 268
* [x] 7.3 Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
	* [x] 7.3.1 Abilities of Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
	* [x] 7.3.2 Vector Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
	* [x] 7.3.3 Using Vectors as C-Style Arrays . . . . . . . . . . . . . . . . . . . . . . 278
	* [x] 7.3.4 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
	* [x] 7.3.5 Examples of Using Vectors . . . . . . . . . . . . . . . . . . . . . . . . . 279
	* [x] 7.3.6 Class vector`<bool>` . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
* [x] 7.4 Deques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
	* [x] 7.4.1 Abilities of Deques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
	* [x] 7.4.2 Deque Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
	* [x] 7.4.3 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
	* [x] 7.4.4 Examples of Using Deques . . . . . . . . . . . . . . . . . . . . . . . . . 288
* [x] 7.5 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
	* [x] 7.5.1 Abilities of Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
	* [x] 7.5.2 List Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
	* [x] 7.5.3 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
	* [x] 7.5.4 Examples of Using Lists . . . . . . . . . . . . . . . . . . . . . . . . . . 298
* [x] 7.6 Forward Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
	* [x] 7.6.1 Abilities of Forward Lists . . . . . . . . . . . . . . . . . . . . . . . . . . 300
	* [x] 7.6.2 Forward List Operations . . . . . . . . . . . . . . . . . . . . . . . . . . 302
	* [x] 7.6.3 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
	* [x] 7.6.4 Examples of Using Forward Lists . . . . . . . . . . . . . . . . . . . . . . 312
* [x] 7.7 Sets and Multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
	* [x] 7.7.1 Abilities of Sets and Multisets . . . . . . . . . . . . . . . . . . . . . . . 315
	* [x] 7.7.2 Set and Multiset Operations . . . . . . . . . . . . . . . . . . . . . . . . . 316
	* [x] 7.7.3 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
	* [x] 7.7.4 Examples of Using Sets and Multisets . . . . . . . . . . . . . . . . . . . 325
	* [x] 7.7.5 Example of Specifying the Sorting Criterion at Runtime . . . . . . . . . . 328
* [ ] 7.8 Maps and Multimaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
	* [ ] 7.8.1 Abilities of Maps and Multimaps . . . . . . . . . . . . . . . . . . . . . . 332
	* [ ] 7.8.2 Map and Multimap Operations . . . . . . . . . . . . . . . . . . . . . . . 333
	* [ ] 7.8.3 Using Maps as Associative Arrays . . . . . . . . . . . . . . . . . . . . . 343
	* [ ] 7.8.4 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
	* [ ] 7.8.5 Examples of Using Maps and Multimaps . . . . . . . . . . . . . . . . . . 345
	* [ ] 7.8.6 Example with Maps, Strings, and Sorting Criterion at Runtime . . . . . . 351
* [ ] 7.9 Unordered Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
	* [ ] 7.9.1 Abilities of Unordered Containers . . . . . . . . . . . . . . . . . . . . . 357
	* [ ] 7.9.2 Creating and Controlling Unordered Containers . . . . . . . . . . . . . . 359
	* [ ] 7.9.3 Other Operations for Unordered Containers . . . . . . . . . . . . . . . . 367
	* [ ] 7.9.4 The Bucket Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374
	* [ ] 7.9.5 Using Unordered Maps as Associative Arrays . . . . . . . . . . . . . . . 374
	* [ ] 7.9.6 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
	* [ ] 7.9.7 Examples of Using Unordered Containers . . . . . . . . . . . . . . . . . 375
* [ ] 7.10 Other STL Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
	* [ ] 7.10.1 Strings as STL Containers . . . . . . . . . . . . . . . . . . . . . . . . . 385
	* [ ] 7.10.2 Ordinary C-Style Arrays as STL Containers . . . . . . . . . . . . . . . . 386
* [ ] 7.11 Implementing Reference Semantics . . . . . . . . . . . . . . . . . . . . . . . . . 388
* [x] 7.12 When to Use Which Container . . . . . . . . . . . . . . . . . . . . . . . . . . . . 392
* [x] 8.1 Type Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397
* [ ] 8.2 Create, Copy, and Destroy Operations . . . . . . . . . . . . . . . . . . . . . . . . 400
* [ ] 8.3 Nonmodifying Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
	* [ ] 8.3.1 Size Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
	* [ ] 8.3.2 Comparison Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 404
	* [ ] 8.3.3 Nonmodifying Operations for Associative and Unordered Containers . . . 404
* [ ] 8.4 Assignments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
* [ ] 8.5 Direct Element Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
* [ ] 8.6 Operations to Generate Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . 410
* [ ] 8.7 Inserting and Removing Elements . . . . . . . . . . . . . . . . . . . . . . . . . . 411
	* [ ] 8.7.1 Inserting Single Elements . . . . . . . . . . . . . . . . . . . . . . . . . . 411
	* [ ] 8.7.2 Inserting Multiple Elements . . . . . . . . . . . . . . . . . . . . . . . . . 416
	* [ ] 8.7.3 Removing Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
	* [ ] 8.7.4 Resizing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
* [ ] 8.8 Special Member Functions for Lists and Forward Lists . . . . . . . . . . . . . . . 420
	* [ ] 8.8.1 Special Member Functions for Lists (and Forward Lists) . . . . . . . . . 420
	* [ ] 8.8.2 Special Member Functions for Forward Lists Only . . . . . . . . . . . . 423
* [ ] 8.9 Container Policy Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
	* [ ] 8.9.1 Nonmodifying Policy Functions . . . . . . . . . . . . . . . . . . . . . . 427
	* [ ] 8.9.2 Modifying Policy Functions . . . . . . . . . . . . . . . . . . . . . . . . 428
	* [ ] 8.9.3 Bucket Interface for Unordered Containers . . . . . . . . . . . . . . . . . 429
* [ ] 8.10 Allocator Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430
	* [ ] 8.10.1 Fundamental Allocator Members . . . . . . . . . . . . . . . . . . . . . . 430
	* [ ] 8.10.2 Constructors with Optional Allocator Parameters . . . . . . . . . . . . . 430
* [ ] 9.1 Header Files for Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
* [ ] 9.2 Iterator Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
	* [ ] 9.2.1 Output Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
	* [ ] 9.2.2 Input Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
	* [ ] 9.2.3 Forward Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
	* [ ] 9.2.4 Bidirectional Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
	* [ ] 9.2.5 Random-Access Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . 438
	* [ ] 9.2.6 The Increment and Decrement Problem of Vector Iterators . . . . . . . . 440
* [ ] 9.3 Auxiliary Iterator Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
	* [ ] 9.3.1 advance() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 441
	* [ ] 9.3.2 next() and prev() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
	* [ ] 9.3.3 distance() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
	* [ ] 9.3.4 iter_swap() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446
* [ ] 9.4 Iterator Adapters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
	* [ ] 9.4.1 Reverse Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448
	* [ ] 9.4.2 Insert Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 454
	* [ ] 9.4.3 Stream Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460
	* [ ] 9.4.4 Move Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466
* [ ] 9.5 Iterator Traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466
	* [ ] 9.5.1 Writing Generic Functions for Iterators . . . . . . . . . . . . . . . . . . . 468
* [ ] 9.6 Writing User-Defined Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 471
* [ ] 10.1 The Concept of Function Objects . . . . . . . . . . . . . . . . . . . . . . . . . . 475
	* [ ] 10.1.1 Function Objects as Sorting Criteria . . . . . . . . . . . . . . . . . . . . 476
	* [ ] 10.1.2 Function Objects with Internal State . . . . . . . . . . . . . . . . . . . . 478
	* [ ] 10.1.3 The Return Value of for_each() . . . . . . . . . . . . . . . . . . . . . 482
	* [ ] 10.1.4 Predicates versus Function Objects . . . . . . . . . . . . . . . . . . . . . 483
* [ ] 10.2 Predefined Function Objects and Binders . . . . . . . . . . . . . . . . . . . . . . 486
	* [ ] 10.2.1 Predefined Function Objects . . . . . . . . . . . . . . . . . . . . . . . . 486
	* [ ] 10.2.2 Function Adapters and Binders . . . . . . . . . . . . . . . . . . . . . . . 487
	* [ ] 10.2.3 User-Defined Function Objects for Function Adapters . . . . . . . . . . . 495
	* [ ] 10.2.4 Deprecated Function Adapters . . . . . . . . . . . . . . . . . . . . . . . 497
* [ ] 10.3 Using Lambdas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
	* [ ] 10.3.1 Lambdas versus Binders . . . . . . . . . . . . . . . . . . . . . . . . . . 499
	* [ ] 10.3.2 Lambdas versus Stateful Function Objects . . . . . . . . . . . . . . . . . 500
	* [ ] 10.3.3 Lambdas Calling Global and Member Functions . . . . . . . . . . . . . . 502
	* [ ] 10.3.4 Lambdas as Hash Function, Sorting, or Equivalence Criterion . . . . . . . 504
* [ ] 11.1 Algorithm Header Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
* [ ] 11.2 Algorithm Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
	* [ ] 11.2.1 A Brief Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 506
	* [ ] 11.2.2 Classification of Algorithms . . . . . . . . . . . . . . . . . . . . . . . . 506
* [ ] 11.3 Auxiliary Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517
* [ ] 11.4 The for_each() Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 519
* [ ] 11.5 Nonmodifying Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524
	* [ ] 11.5.1 Counting Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524
	* [ ] 11.5.2 Minimum and Maximum . . . . . . . . . . . . . . . . . . . . . . . . . . 525
	* [ ] 11.5.3 Searching Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
	* [ ] 11.5.4 Comparing Ranges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
	* [ ] 11.5.5 Predicates for Ranges . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550
* [ ] 11.6 Modifying Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
	* [ ] 11.6.1 Copying Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
	* [ ] 11.6.2 Moving Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561
	* [ ] 11.6.3 Transforming and Combining Elements . . . . . . . . . . . . . . . . . . 563
	* [ ] 11.6.4 Swapping Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 566
	* [ ] 11.6.5 Assigning New Values . . . . . . . . . . . . . . . . . . . . . . . . . . . 568
	* [ ] 11.6.6 Replacing Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571
* [ ] 11.7 Removing Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 575
	* [ ] 11.7.1 Removing Certain Values . . . . . . . . . . . . . . . . . . . . . . . . . . 575
	* [ ] 11.7.2 Removing Duplicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . 578
* [ ] 11.8 Mutating Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 583
	* [ ] 11.8.1 Reversing the Order of Elements . . . . . . . . . . . . . . . . . . . . . . 583
	* [ ] 11.8.2 Rotating Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 584
	* [ ] 11.8.3 Permuting Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
	* [ ] 11.8.4 Shuffling Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 589
	* [ ] 11.8.5 Moving Elements to the Front . . . . . . . . . . . . . . . . . . . . . . . 592
	* [ ] 11.8.6 Partition into Two Subranges . . . . . . . . . . . . . . . . . . . . . . . . 594
* [ ] 11.9 Sorting Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 596
	* [ ] 11.9.1 Sorting All Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . 596
	* [ ] 11.9.2 Partial Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 599
	* [ ] 11.9.3 Sorting According to the nth Element . . . . . . . . . . . . . . . . . . . 602
	* [ ] 11.9.4 Heap Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
* [ ] 11.10 Sorted-Range Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 608
	* [ ] 11.10.1 Searching Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 608
	* [ ] 11.10.2 Merging Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 614
* [ ] 11.11 Numeric Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 623
	* [ ] 11.11.1 Processing Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 623
	* [ ] 11.11.2 Converting Relative and Absolute Values . . . . . . . . . . . . . . . . . . 627
* [ ] 12.1 Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632
	* [ ] 12.1.1 The Core Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633
	* [ ] 12.1.2 Example of Using Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . 633
	* [ ] 12.1.3 A User-Defined Stack Class . . . . . . . . . . . . . . . . . . . . . . . . . 635
	* [ ] 12.1.4 Class stack<> in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . 637
* [ ] 12.2 Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 638
	* [ ] 12.2.1 The Core Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 639
	* [ ] 12.2.2 Example of Using Queues . . . . . . . . . . . . . . . . . . . . . . . . . 640
	* [ ] 12.2.3 A User-Defined Queue Class . . . . . . . . . . . . . . . . . . . . . . . . 641
	* [ ] 12.2.4 Class queue<> in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . 641
* [ ] 12.3 Priority Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641
	* [ ] 12.3.1 The Core Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 643
	* [ ] 12.3.2 Example of Using Priority Queues . . . . . . . . . . . . . . . . . . . . . 643
	* [ ] 12.3.3 Class priority_queue<> in Detail . . . . . . . . . . . . . . . . . . . . 644
* [ ] 12.4 Container Adapters in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645
	* [ ] 12.4.1 Type Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645
	* [ ] 12.4.2 Constructors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 646
	* [ ] 12.4.3 Supplementary Constructors for Priority Queues . . . . . . . . . . . . . . 646
	* [ ] 12.4.4 Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 647
* [ ] 12.5 Bitsets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 650
	* [ ] 12.5.1 Examples of Using Bitsets . . . . . . . . . . . . . . . . . . . . . . . . . 651
	* [ ] 12.5.2 Class bitset in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . 653
* [ ] 13.1 Purpose of the String Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 656
	* [ ] 13.1.1 A First Example: Extracting a Temporary Filename . . . . . . . . . . . . 656
	* [ ] 13.1.2 A Second Example: Extracting Words and Printing Them Backward . . . 660
* [ ] 13.2 Description of the String Classes . . . . . . . . . . . . . . . . . . . . . . . . . . 663
	* [ ] 13.2.1 String Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 663
	* [ ] 13.2.2 Operation Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 666
	* [ ] 13.2.3 Constructors and Destructor . . . . . . . . . . . . . . . . . . . . . . . . 667
	* [ ] 13.2.4 Strings and C-Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . 668
	* [ ] 13.2.5 Size and Capacity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 669
	* [ ] 13.2.6 Element Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 671
	* [ ] 13.2.7 Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 672
	* [ ] 13.2.8 Modifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 673
	* [ ] 13.2.9 Substrings and String Concatenation . . . . . . . . . . . . . . . . . . . . 676
	* [ ] 13.2.10 Input/Output Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . 677
	* [ ] 13.2.11 Searching and Finding . . . . . . . . . . . . . . . . . . . . . . . . . . . 678
	* [ ] 13.2.12 The Value npos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 680
	* [ ] 13.2.13 Numeric Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 681
	* [ ] 13.2.14 Iterator Support for Strings . . . . . . . . . . . . . . . . . . . . . . . . . 684
	* [ ] 13.2.15 Internationalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 689
	* [ ] 13.2.16 Performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 692
	* [ ] 13.2.17 Strings and Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 692
* [ ] 13.3 String Class in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 693
	* [ ] 13.3.1 Type Definitions and Static Values . . . . . . . . . . . . . . . . . . . . . 693
	* [ ] 13.3.2 Create, Copy, and Destroy Operations . . . . . . . . . . . . . . . . . . . 694
	* [ ] 13.3.3 Operations for Size and Capacity . . . . . . . . . . . . . . . . . . . . . . 696
	* [ ] 13.3.4 Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 697
	* [ ] 13.3.5 Character Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 699
	* [ ] 13.3.6 Generating C-Strings and Character Arrays . . . . . . . . . . . . . . . . 700
	* [ ] 13.3.7 Modifying Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 700
	* [ ] 13.3.8 Searching and Finding . . . . . . . . . . . . . . . . . . . . . . . . . . . 708
	* [ ] 13.3.9 Substrings and String Concatenation . . . . . . . . . . . . . . . . . . . . 711
	* [ ] 13.3.10 Input/Output Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 712
	* [ ] 13.3.11 Numeric Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 713
	* [ ] 13.3.12 Generating Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 714
	* [ ] 13.3.13 Allocator Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 715
* [ ] 14.1 The Regex Match and Search Interface . . . . . . . . . . . . . . . . . . . . . . . 717
* [ ] 14.2 Dealing with Subexpressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 720
* [ ] 14.3 Regex Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 726
* [ ] 14.4 Regex Token Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 727
* [ ] 14.5 Replacing Regular Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . 730
* [ ] 14.6 Regex Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 732
* [ ] 14.7 Regex Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 735
* [ ] 14.8 The Regex ECMAScript Grammar . . . . . . . . . . . . . . . . . . . . . . . . . 738
* [ ] 14.9 Other Grammars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 739
* [ ] 14.10 Basic Regex Signatures in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . 740
* [ ] 15.1 Common Background of I/O Streams . . . . . . . . . . . . . . . . . . . . . . . . 744
	* [ ] 15.1.1 Stream Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 744
	* [ ] 15.1.2 Stream Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 744
	* [ ] 15.1.3 Global Stream Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 745
	* [ ] 15.1.4 Stream Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 745
	* [ ] 15.1.5 Manipulators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 746
	* [ ] 15.1.6 A Simple Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 746
* [ ] 15.2 Fundamental Stream Classes and Objects . . . . . . . . . . . . . . . . . . . . . . 748
	* [ ] 15.2.1 Classes and Class Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . 748
	* [ ] 15.2.2 Global Stream Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . 751
	* [ ] 15.2.3 Header Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 752
* [ ] 15.3 Standard Stream Operators << and >> . . . . . . . . . . . . . . . . . . . . . . . . 753
	* [ ] 15.3.1 Output Operator << . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 753
	* [ ] 15.3.2 Input Operator >> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 754
	* [ ] 15.3.3 Input/Output of Special Types . . . . . . . . . . . . . . . . . . . . . . . 755
* [ ] 15.4 State of Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 758
	* [ ] 15.4.1 Constants for the State of Streams . . . . . . . . . . . . . . . . . . . . . 758
	* [ ] 15.4.2 Member Functions Accessing the State of Streams . . . . . . . . . . . . . 759
	* [ ] 15.4.3 Stream State and Boolean Conditions . . . . . . . . . . . . . . . . . . . 760
	* [ ] 15.4.4 Stream State and Exceptions . . . . . . . . . . . . . . . . . . . . . . . . 762
* [ ] 15.5 Standard Input/Output Functions . . . . . . . . . . . . . . . . . . . . . . . . . . 767
	* [ ] 15.5.1 Member Functions for Input . . . . . . . . . . . . . . . . . . . . . . . . 768
	* [ ] 15.5.2 Member Functions for Output . . . . . . . . . . . . . . . . . . . . . . . 771
	* [ ] 15.5.3 Example Uses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 772
	* [ ] 15.5.4 sentry Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 772
* [ ] 15.6 Manipulators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 774
	* [ ] 15.6.1 Overview of All Manipulators . . . . . . . . . . . . . . . . . . . . . . . 774
	* [ ] 15.6.2 How Manipulators Work . . . . . . . . . . . . . . . . . . . . . . . . . . 776
	* [ ] 15.6.3 User-Defined Manipulators . . . . . . . . . . . . . . . . . . . . . . . . . 777
* [ ] 15.7 Formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 779
	* [ ] 15.7.1 Format Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 779
	* [ ] 15.7.2 Input/Output Format of Boolean Values . . . . . . . . . . . . . . . . . . 781
	* [ ] 15.7.3 Field Width, Fill Character, and Adjustment . . . . . . . . . . . . . . . . 781
	* [ ] 15.7.4 Positive Sign and Uppercase Letters . . . . . . . . . . . . . . . . . . . . 784
	* [ ] 15.7.5 Numeric Base . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 785
	* [ ] 15.7.6 Floating-Point Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . 787
	* [ ] 15.7.7 General Formatting Definitions . . . . . . . . . . . . . . . . . . . . . . . 789
* [ ] 15.8 Internationalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 790
* [ ] 15.9 File Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 791
	* [ ] 15.9.1 File Stream Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 791
	* [ ] 15.9.2 Rvalue and Move Semantics for File Streams . . . . . . . . . . . . . . . 795
	* [ ] 15.9.3 File Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 796
	* [ ] 15.9.4 Random Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 799
	* [ ] 15.9.5 Using File Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . 801
* [ ] 15.10 Stream Classes for Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 802
	* [ ] 15.10.1 String Stream Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 802
	* [ ] 15.10.2 Move Semantics for String Streams . . . . . . . . . . . . . . . . . . . . . 806
	* [ ] 15.10.3 char* Stream Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 807
* [ ] 15.11 Input/Output Operators for User-Defined Types . . . . . . . . . . . . . . . . . . . 810
	* [ ] 15.11.1 Implementing Output Operators . . . . . . . . . . . . . . . . . . . . . . 810
	* [ ] 15.11.2 Implementing Input Operators . . . . . . . . . . . . . . . . . . . . . . . 812
	* [ ] 15.11.3 Input/Output Using Auxiliary Functions . . . . . . . . . . . . . . . . . . 814
	* [ ] 15.11.4 User-Defined Format Flags . . . . . . . . . . . . . . . . . . . . . . . . . 815
	* [ ] 15.11.5 Conventions for User-Defined Input/Output Operators . . . . . . . . . . . 818
* [ ] 15.12 Connecting Input and Output Streams . . . . . . . . . . . . . . . . . . . . . . . . 819
	* [ ] 15.12.1 Loose Coupling Using tie() . . . . . . . . . . . . . . . . . . . . . . . . 819
	* [ ] 15.12.2 Tight Coupling Using Stream Buffers . . . . . . . . . . . . . . . . . . . 820
	* [ ] 15.12.3 Redirecting Standard Streams . . . . . . . . . . . . . . . . . . . . . . . . 822
	* [ ] 15.12.4 Streams for Reading and Writing . . . . . . . . . . . . . . . . . . . . . . 824
* [ ] 15.13 The Stream Buffer Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 826
	* [ ] 15.13.1 The Stream Buffer Interfaces . . . . . . . . . . . . . . . . . . . . . . . . 826
	* [ ] 15.13.2 Stream Buffer Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . 828
	* [ ] 15.13.3 User-Defined Stream Buffers . . . . . . . . . . . . . . . . . . . . . . . . 832
* [ ] 15.14 Performance Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 844
	* [ ] 15.14.1 Synchronization with C’s Standard Streams . . . . . . . . . . . . . . . . 845
	* [ ] 15.14.2 Buffering in Stream Buffers . . . . . . . . . . . . . . . . . . . . . . . . . 845
	* [ ] 15.14.3 Using Stream Buffers Directly . . . . . . . . . . . . . . . . . . . . . . . 846
* [ ] 16.1 Character Encodings and Character Sets . . . . . . . . . . . . . . . . . . . . . . . 850
	* [ ] 16.1.1 Multibyte and Wide-Character Text . . . . . . . . . . . . . . . . . . . . . 850
	* [ ] 16.1.2 Different Character Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 851
	* [ ] 16.1.3 Dealing with Character Sets in C++ . . . . . . . . . . . . . . . . . . . . 852
	* [ ] 16.1.4 Character Traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 853
	* [ ] 16.1.5 Internationalization of Special Characters . . . . . . . . . . . . . . . . . 857
* [ ] 16.2 The Concept of Locales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 857
	* [ ] 16.2.1 Using Locales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 858
	* [ ] 16.2.2 Locale Facets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 864
	* [ ] 16.3 Locales in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 866
* [ ] 16.4 Facets in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 869
	* [ ] 16.4.1 Numeric Formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 870
	* [ ] 16.4.2 Monetary Formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . 874
	* [ ] 16.4.3 Time and Date Formatting . . . . . . . . . . . . . . . . . . . . . . . . . 884
	* [ ] 16.4.4 Character Classification and Conversion . . . . . . . . . . . . . . . . . . 891
	* [ ] 16.4.5 String Collation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 904
	* [ ] 16.4.6 Internationalized Messages . . . . . . . . . . . . . . . . . . . . . . . . . 905
* [ ] 17.1 Random Numbers and Distributions . . . . . . . . . . . . . . . . . . . . . . . . . 907
	* [ ] 17.1.1 A First Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 908
	* [ ] 17.1.2 Engines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 912
	* [ ] 17.1.3 Engines in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 915
	* [ ] 17.1.4 Distributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 917
	* [ ] 17.1.5 Distributions in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . 921
* [ ] 17.2 Complex Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 925
	* [ ] 17.2.1 Class complex<> in General . . . . . . . . . . . . . . . . . . . . . . . . 925
	* [ ] 17.2.2 Examples Using Class complex<> . . . . . . . . . . . . . . . . . . . . . 926
	* [ ] 17.2.3 Operations for Complex Numbers . . . . . . . . . . . . . . . . . . . . . 928
	* [ ] 17.2.4 Class complex<> in Detail . . . . . . . . . . . . . . . . . . . . . . . . . 935
* [ ] 17.3 Global Numeric Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 941
* [x] 17.4 Valarrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 943
* [ ] 18.1 The High-Level Interface: async() and Futures . . . . . . . . . . . . . . . . . . 946
	* [ ] 18.1.1 A First Example Using async() and Futures . . . . . . . . . . . . . . . 946
	* [ ] 18.1.2 An Example of Waiting for Two Tasks . . . . . . . . . . . . . . . . . . . 955
	* [ ] 18.1.3 Shared Futures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 960
* [ ] 18.2 The Low-Level Interface: Threads and Promises . . . . . . . . . . . . . . . . . . 964
	* [ ] 18.2.1 Class std::thread . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 964
	* [ ] 18.2.2 Promises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 969
	* [ ] 18.2.3 Class packaged_task<> . . . . . . . . . . . . . . . . . . . . . . . . . . 972
* [ ] 18.3 Starting a Thread in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 973
	* [ ] 18.3.1 async() in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 974
	* [ ] 18.3.2 Futures in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 975
	* [ ] 18.3.3 Shared Futures in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . 976
	* [ ] 18.3.4 Class std::promise in Detail . . . . . . . . . . . . . . . . . . . . . . . 977
	* [ ] 18.3.5 Class std::packaged_task in Detail . . . . . . . . . . . . . . . . . . . 977
	* [ ] 18.3.6 Class std::thread in Detail . . . . . . . . . . . . . . . . . . . . . . . . 979
	* [ ] 18.3.7 Namespace this_thread . . . . . . . . . . . . . . . . . . . . . . . . . 981
* [ ] 18.4 Synchronizing Threads, or the Problem of Concurrency . . . . . . . . . . . . . . 982
	* [ ] 18.4.1 Beware of Concurrency! . . . . . . . . . . . . . . . . . . . . . . . . . . 982
	* [ ] 18.4.2 The Reason for the Problem of Concurrent Data Access . . . . . . . . . . 983
	* [ ] 18.4.3 What Exactly Can Go Wrong (the Extent of the Problem) . . . . . . . . . 983
	* [ ] 18.4.4 The Features to Solve the Problems . . . . . . . . . . . . . . . . . . . . . 987
* [ ] 18.5 Mutexes and Locks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 989
	* [ ] 18.5.1 Using Mutexes and Locks . . . . . . . . . . . . . . . . . . . . . . . . . . 989
	* [ ] 18.5.2 Mutexes and Locks in Detail . . . . . . . . . . . . . . . . . . . . . . . . 998
	* [ ] 18.5.3 Calling Once for Multiple Threads . . . . . . . . . . . . . . . . . . . . . 1000
* [ ] 18.6 Condition Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1003
	* [ ] 18.6.1 Purpose of Condition Variables . . . . . . . . . . . . . . . . . . . . . . . 1003
	* [ ] 18.6.2 A First Complete Example for Condition Variables . . . . . . . . . . . . 1004
	* [ ] 18.6.3 Using Condition Variables to Implement a Queue for Multiple Threads . . 1006
	* [ ] 18.6.4 Condition Variables in Detail . . . . . . . . . . . . . . . . . . . . . . . . 1009
* [x] 18.7 Atomics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1012
	* [ ] 18.7.1 Example of Using Atomics . . . . . . . . . . . . . . . . . . . . . . . . . 1012
	* [ ] 18.7.2 Atomics and Their High-Level Interface in Detail . . . . . . . . . . . . . 1016
	* [ ] 18.7.3 The C-Style Interface of Atomics . . . . . . . . . . . . . . . . . . . . . . 1019
	* [ ] 18.7.4 The Low-Level Interface of Atomics . . . . . . . . . . . . . . . . . . . . 1019
* [x] Allocators 1023
	* [ ] 19.1 Using Allocators as an Application Programmer . . . . . . . . . . . . . . . . . . 1023
	* [ ] 19.2 A User-Defined Allocator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1024
	* [ ] 19.3 Using Allocators as a Library Programmer . . . . . . . . . . . . . . . . . . . . . 1026

# Jossutis c++17
* [ ] 1 Structured Bindings 3
	* [ ] 1.1 Structured Bindings in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
	* [ ] 1.2 Where Structured Bindings can be Used . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
		* [ ] 1.2.1 Structures and Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
		* [ ] 1.2.2 Raw Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
		* [ ] 1.2.3 std::pair, std::tuple, and std::array . . . . . . . . . . . . . . . . . . . 9
	* [ ] 1.3 Providing a Tuple-Like API for Structured Bindings . . . . . . . . . . . . . . . . . . . . 11
	* [ ] 1.4 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
* [ ] 2 if and switch with Initialization 19
	* [ ] 2.1 if with Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
	* [ ] 2.2 switch with Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
	* [ ] 2.3 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
* [ ] 3 Inline Variables 23
	* [ ] 3.1 Motivation of Inline Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
	* [ ] 3.2 Using Inline Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
	* [ ] 3.3 constexpr now implies inline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
	* [ ] 3.4 Inline Variables and thread_local . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
	* [ ] 3.5 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
* [ ] 4 Aggregate Extensions 31
	* [ ] 4.1 Motivation for Extended Aggregate Initialization . . . . . . . . . . . . . . . . . . . . . . 32
	* [ ] 4.2 Using Extended Aggregate Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
	* [ ] 4.3 Definition of Aggregates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
	* [ ] 4.4 Backward Incompatibilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
	* [ ] 4.5 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
* [ ] 5 Mandatory Copy Elision or Passing Unmaterialized Objects 37
	* [ ] 5.1 Motivation for Mandatory Copy Elision for Temporaries . . . . . . . . . . . . . . . . . 37
	* [ ] 5.2 Benefit of Mandatory Copy Elision for Temporaries . . . . . . . . . . . . . . . . . . . . 39
	* [ ] 5.3 Clarified Value Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
		* [ ] 5.3.1 Value Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
		* [ ] 5.3.2 Value Categories Since C++17 . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
	* [ ] 5.4 Unmaterialized Return Value Passing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
	* [ ] 5.5 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
* [ ] 6 Lambda Extensions 45
	* [ ] 6.1 constexpr Lambdas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
	* [ ] 6.2 Passing Copies of this to Lambdas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
	* [ ] 6.3 Capturing by Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
	* [ ] 6.4 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
* [ ] 7 New Attributes and Attribute Features 51
	* [ ] 7.1 Attribute [[nodiscard]] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
	* [ ] 7.2 Attribute [[maybe_unused]] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
	* [ ] 7.3 Attribute [[fallthrough]] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
	* [ ] 7.4 General Attribute Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
	* [ ] 7.5 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
* [ ] 8 Other Language Features 57
	* [ ] 8.1 Nested Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
	* [ ] 8.2 Defined Expression Evaluation Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
	* [ ] 8.3 Relaxed Enum Initialization from Integral Values . . . . . . . . . . . . . . . . . . . . . 61
	* [ ] 8.4 Fixed Direct List Initialization with auto . . . . . . . . . . . . . . . . . . . . . . . . . . 62
	* [ ] 8.5 Hexadecimal Floating-Point Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
	* [ ] 8.6 UTF-8 Character Literals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
	* [ ] 8.7 Exception Specifications as Part of the Type . . . . . . . . . . . . . . . . . . . . . . . . . 65
	* [ ] 8.8 Single-Argument static_assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
	* [ ] 8.9 Preprocessor Condition __has_include . . . . . . . . . . . . . . . . . . . . . . . . . . 69
	* [ ] 8.10 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
* [ ] 9 Class Template Argument Deduction 73
	* [ ] 9.1 Usage of Class Template Argument Deduction . . . . . . . . . . . . . . . . . . . . . . . 74
		* [ ] 9.1.1 Copying by Default . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
		* [ ] 9.1.2 Deducing the Type of Lambdas . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
		* [ ] 9.1.3 No Partial Class Template Argument Deduction . . . . . . . . . . . . . . . . . 77
		* [ ] 9.1.4 Class Template Argument Deduction Instead of Convenience Functions . . 78
	* [ ] 9.2 Deduction Guides . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
		* [ ] 9.2.1 Using Deduction Guides to Force Decay . . . . . . . . . . . . . . . . . . . . . 81
		* [ ] 9.2.2 Non-Template Deduction Guides . . . . . . . . . . . . . . . . . . . . . . . . . . 81
		* [ ] 9.2.3 Deduction Guides versus Constructors . . . . . . . . . . . . . . . . . . . . . . . 82
		* [ ] 9.2.4 Explicit Deduction Guides . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
		* [ ] 9.2.5 Deduction Guides for Aggregates . . . . . . . . . . . . . . . . . . . . . . . . . . 83
		* [ ] 9.2.6 Standard Deduction Guides . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
	* [ ] 9.3 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
* [ ] 10 Compile-Time if 91
	* [ ] 10.1 Motivation for Compile-Time if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
	* [ ] 10.2 Using Compile-Time if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
		* [ ] 10.2.1 Caveats for Compile-Time if . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
		* [ ] 10.2.2 Other Compile-Time if Examples . . . . . . . . . . . . . . . . . . . . . . . . . 97
	* [ ] 10.3 Compile-Time if with Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
	* [ ] 10.4 Using Compile-Time if Outside Templates . . . . . . . . . . . . . . . . . . . . . . . . . 100
	* [ ] 10.5 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
* [ ] 11 Fold Expressions 103
	* [ ] 11.1 Motivation for Fold Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
	* [ ] 11.2 Using Fold Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
		* [ ] 11.2.1 Dealing with Empty Parameter Packs . . . . . . . . . . . . . . . . . . . . . . . 106
		* [ ] 11.2.2 Supported Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
		* [ ] 11.2.3 Using Fold Expressions for Types . . . . . . . . . . . . . . . . . . . . . . . . . . 112
	* [ ] 11.3 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
* [ ] 12 Dealing with Strings as Template Parameters 115
	* [ ] 12.1 Using Strings in Templates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
	* [ ] 12.2 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
* [ ] 13 Placeholder Types like auto as Template Parameters 117
	* [ ] 13.1 Using auto as Template Parameter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
		* [ ] 13.1.1 Parameterizing Templates for Characters and Strings . . . . . . . . . . . . . . 118
		* [ ] 13.1.2 Defining Metaprogramming Constants . . . . . . . . . . . . . . . . . . . . . . . 119
	* [ ] 13.2 Using auto as Variable Template Parameter . . . . . . . . . . . . . . . . . . . . . . . . 120
	* [ ] 13.3 Using decltype(auto) as Template Parameter . . . . . . . . . . . . . . . . . . . . . . 122
	* [ ] 13.4 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
* [ ] 14 Extended Using Declarations 125
	* [ ] 14.1 Using Variadic Using Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
	* [ ] 14.2 Variadic Using Declarations for Inheriting Constructors . . . . . . . . . . . . . . . . . 126
	* [ ] 14.3 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
* [ ] 15 std::optional<> 131
	* [ ] 15.1 Using std::optional<> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
		* [ ] 15.1.1 Optional Return Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
		* [ ] 15.1.2 Optional Arguments and Data Members . . . . . . . . . . . . . . . . . . . . . . 133
	* [ ] 15.2 std::optional<> Types and Operations . . . . . . . . . . . . . . . . . . . . . . . . . . 135
		* [ ] 15.2.1 std::optional<> Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
		* [ ] 15.2.2 std::optional<> Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
	* [ ] 15.3 Special Cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
		* [ ] 15.3.1 Optional of Boolean or Raw Pointer Values . . . . . . . . . . . . . . . . . . . . 140
		* [ ] 15.3.2 Optional of Optional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
	* [ ] 15.4 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
* [ ] 16 std::variant<> 143
	* [ ] 16.1 Motivation of std::variant<> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
	* [ ] 16.2 Using std::variant<> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
	* [ ] 16.3 std::variant<> Types and Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
		* [ ] 16.3.1 std::variant<> Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
		* [ ] 16.3.2 std::variant<> Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
		* [ ] 16.3.3 Visitors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
		* [ ] 16.3.4 Valueless by Exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
	* [ ] 16.4 Polymorphism and Inhomogeneous Collections with std::variant . . . . . . . . . 156
		* [ ] 16.4.1 Geometric Objects with std::variant . . . . . . . . . . . . . . . . . . . . . . 156
		* [ ] 16.4.2 Other Inhomogeneous Collections with std::variant . . . . . . . . . . . . 159
		* [ ] 16.4.3 Comparing variant Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . 160
	* [ ] 16.5 Special Cases with std::variant<> . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
		* [ ] 16.5.1 Having Both bool and std::string Alternatives . . . . . . . . . . . . . . . 161
	* [ ] 16.6 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
* [ ] 17 std::any 163
	* [ ] 17.1 Using std::any . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
	* [ ] 17.2 std::any Types and Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
		* [ ] 17.2.1 Any Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
		* [ ] 17.2.2 Any Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
	* [ ] 17.3 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
* [ ] 18 std::byte 171
	* [ ] 18.1 Using std::byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
	* [ ] 18.2 std::byte Types and Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
		* [ ] 18.2.1 std::byte Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
		* [ ] 18.2.2 std::byte Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
	* [ ] 18.3 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
* [ ] 19 String Views 177
	* [ ] 19.1 Differences to std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
	* [ ] 19.2 Using String Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
	* [ ] 19.3 Using String Views Similar to Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
		* [ ] 19.3.1 String View Considered Harmful . . . . . . . . . . . . . . . . . . . . . . . . . . 180
	* [ ] 19.4 String View Types and Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
		* [ ] 19.4.1 Concrete String View Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
		* [ ] 19.4.2 String View Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
		* [ ] 19.4.3 String View Support by Other Types . . . . . . . . . . . . . . . . . . . . . . . . 187
	* [ ] 19.5 Using String Views in API’s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
		* [ ] 19.5.1 Using String Views to Initialize Strings . . . . . . . . . . . . . . . . . . . . . . 188
		* [ ] 19.5.2 Using String Views instead of Strings . . . . . . . . . . . . . . . . . . . . . . . 190
	* [ ] 19.6 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
* [ ] 20 The Filesystem Library 193
	* [ ] 20.1 Basic Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
		* [ ] 20.1.1 Print Attributes of a Passed Filesystem Path . . . . . . . . . . . . . . . . . . . 193
		* [ ] 20.1.2 Switch Over Filesystem Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
		* [ ] 20.1.3 Create Different Types of Files . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
		* [ ] 20.1.4 Dealing with Filesystems Using Parallel Algorithms . . . . . . . . . . . . . . 202
	* [ ] 20.2 Principles and Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
		* [ ] 20.2.1 General Portability Disclaimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
		* [ ] 20.2.2 Namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
		* [ ] 20.2.3 Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
		* [ ] 20.2.4 Normalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
		* [ ] 20.2.5 Member versus Free-Standing Functions . . . . . . . . . . . . . . . . . . . . . 205
		* [ ] 20.2.6 Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
		* [ ] 20.2.7 File Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
	* [ ] 20.3 Path Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
		* [ ] 20.3.1 Path Creation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
		* [ ] 20.3.2 Path Inspection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
		* [ ] 20.3.3 Path I/O and Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
		* [ ] 20.3.4 Conversions Between Native and Generic Format . . . . . . . . . . . . . . . . 216
		* [ ] 20.3.5 Path Modifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
		* [ ] 20.3.6 Path Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
		* [ ] 20.3.7 Other Path Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
	* [ ] 20.4 Filesystem Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
		* [ ] 20.4.1 File Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
		* [ ] 20.4.2 File Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
		* [ ] 20.4.3 Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
		* [ ] 20.4.4 Filesystem Modifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
		* [ ] 20.4.5 Symbolic Links and Filesystem-Dependent Path Conversions . . . . . . . . . 233
		* [ ] 20.4.6 Other Filesystem Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
	* [ ] 20.5 Iterating Over Directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
		* [ ] 20.5.1 Directory Entries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
	* [ ] 20.6 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
* [ ] 21 Type Traits Extensions 245
	* [ ] 21.1 Type Traits Suffix _v . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
	* [ ] 21.2 New Type Traits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
	* [ ] 21.3 std::bool_constant<> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
	* [ ] 21.4 std::void_t<> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
	* [ ] 21.5 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
* [ ] 22 Parallel STL Algorithms 251
	* [ ] 22.1 Using Parallel Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
		* [ ] 22.1.1 Using a Parallel for_each() . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
		* [ ] 22.1.2 Using a Parallel sort() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
	* [ ] 22.2 Execution Policies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
	* [ ] 22.3 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
	* [ ] 22.4 Benefit of not using Parallel Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
	* [ ] 22.5 Overview of Parallel Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
	* [ ] 22.6 New Algorithms for Parallel Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
		* [ ] 22.6.1 reduce() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
	* [ ] 22.7 Parallel Algorithms in Detail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
	* [ ] 22.8 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
* [ ] 23 Substring and Subsequence Searchers 273
	* [ ] 23.1 Using Substring Searchers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
		* [ ] 23.1.1 Using Searchers with search() . . . . . . . . . . . . . . . . . . . . . . . . . . 273
		* [ ] 23.1.2 Using Searchers Directly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
	* [ ] 23.2 Using General Subsequence Searchers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
	* [ ] 23.3 Using Searcher Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
	* [ ] 23.4 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
* [ ] 24 Other Utility Functions and Algorithms 279
	* [ ] 24.1 size(), empty(), and data() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
		* [ ] 24.1.1 Generic size() Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
		* [ ] 24.1.2 Generic empty() Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
		* [ ] 24.1.3 Generic data() Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
	* [ ] 24.2 as_const() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
		* [ ] 24.2.1 Capturing by Const Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
	* [ ] 24.3 clamp() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
	* [ ] 24.4 sample() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
	* [ ] 24.5 for_each_n() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
	* [ ] 24.6 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
* [ ] 25 Container Extensions 291
	* [ ] 25.1 Container-Support of Incomplete Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
	* [ ] 25.2 Node Handles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
	* [ ] 25.3 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
* [ ] 26 Multi-Threading and Concurrency 297
	* [ ] 26.1 Supplementary Mutexes and Locks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
		* [ ] 26.1.1 std::scoped_lock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
		* [ ] 26.1.2 std::shared_mutex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
	* [ ] 26.2 is_always_lock_free() for Atomics . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
	* [ ] 26.3 Cache-Line Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
	* [ ] 26.4 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
* [ ] 27 Polymorphic Memory Resources (PMR) 305
	* [ ] 27.1 Using Standard Memory Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
		* [ ] 27.1.1 Motivating Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
		* [ ] 27.1.2 Standard Memory Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
		* [ ] 27.1.3 Standard Memory Resources in Detail . . . . . . . . . . . . . . . . . . . . . . . 313
	* [ ] 27.2 Defining Custom Memory Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
		* [ ] 27.2.1 Equality of Memory Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
	* [ ] 27.3 Providing Memory Resources Support for Custom Types . . . . . . . . . . . . . . . . . 324
		* [ ] 27.3.1 Definition of a PMR Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
		* [ ] 27.3.2 Usage of a PMR Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
		* [ ] 27.3.3 Dealing with the Different Types . . . . . . . . . . . . . . . . . . . . . . . . . . 328
	* [ ] 27.4 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
* [ ] 28 new and delete with Over-Aligned Data 331
	* [ ] 28.1 Using new with Alignments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
		* [ ] 28.1.1 Distinct Dynamic/Heap Memory Arenas . . . . . . . . . . . . . . . . . . . . . 332
		* [ ] 28.1.2 Passing the Alignment with the new Expression . . . . . . . . . . . . . . . . . 333
	* [ ] 28.2 Implementing operator new() for Aligned Memory . . . . . . . . . . . . . . . . . . 334
		* [ ] 28.2.1 Implementing Aligned Allocation Before C++17 . . . . . . . . . . . . . . . . 334
		* [ ] 28.2.2 Implementing Type-Specific operator new() . . . . . . . . . . . . . . . . . 337
	* [ ] 28.3 Implementing Global operator new() . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
	* [ ] 28.3.1 Backward Incompatibilities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344
	* [ ] 28.4 Tracking all ::new Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
	* [ ] 28.5 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348
* [ ] 29 Other Library Improvements for Experts 349
	* [ ] 29.1 Low-Level Conversions between Character Sequences and Numeric Values . . . . . 349
		* [ ] 29.1.1 Example Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
		* [ ] 29.1.2 Floating-Point Round-Trip Support . . . . . . . . . . . . . . . . . . . . . . . . . 352
	* [ ] 29.2 Afternotes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354

# William concurency
* [ ] 1 Hello, world of concurrency in C++! 1
	* [ ] 1.1 What is concurrency? 2
		* [ ] Concurrency in computer systems 2
		* [ ] Approaches to concurrency 4
	* [ ] 1.2 Why use concurrency? 6
		* [ ] Using concurrency for separation of concerns 6
		* [ ] Using concurrency for performance 7 
		* [ ] When not to use concurrency 8
	* [ ] 1.3 Concurrency and multithreading in C++ 9
		* [ ] History of multithreading in C++ 10 
		* [ ] Concurrency support in the new standard 10 ■ Efficiency in the C++
		* [ ] Thread Library 11 
		* [ ] Platform-specific facilities 12
	* [ ] 1.4 Getting started 13
		* [ ] Hello, Concurrent World 13
	* [ ] 1.5 Summary 14
* [ ] 2 Managing threads 15
	* [ ] 2.1 Basic thread management 16
		* [ ] Launching a thread 16 
		* [ ] Waiting for a thread to complete 18
		* [ ] Waiting in exceptional circumstances 19 
		* [ ] Running threads in the background 21
	* [ ] 2.2 Passing arguments to a thread function 23
	* [ ] 2.3 Transferring ownership of a thread 25
	* [ ] 2.4 Choosing the number of threads at runtime 28
	* [ ] 2.5 Identifying threads 31
	* [ ] 2.6 Summary 32
* [ ] 3 Sharing data between threads 33
	* [ ] 3.1 Problems with sharing data between threads 34
		* [ ] Race conditions 35 
		* [ ] Avoiding problematic race conditions 36
	* [ ] 3.2 Protecting shared data with mutexes 37
		* [ ] Using mutexes in C++ 38 
		* [ ] Structuring code for protecting shared data 39 
		* [ ] Spotting race conditions inherent in interfaces 40 
		* [ ] Deadlock: the problem and a solution 47
		* [ ] Further guidelines for avoiding deadlock 49 
		* [ ] Flexible locking with std::unique_lock 54 
		* [ ] Transferring mutex ownership between scopes 55 
		* [ ] Locking at an appropriate granularity 57
	* [ ] 3.3 Alternative facilities for protecting shared data 59
		* [ ] Protecting shared data during initialization 59 
		* [ ] Protecting rarely updated data structures 63 
		* [ ] Recursive locking 64
	* [ ] 3.4 Summary 65
* [ ] 4 Synchronizing concurrent operations 67
	* [ ] 4.1 Waiting for an event or other condition 68
		* [ ] Waiting for a condition with condition variables 69
		* [ ] Building a thread-safe queue with condition variables 71
	* [ ] 4.2 Waiting for one-off events with futures 76
		* [ ] Returning values from background tasks 77 
		* [ ] Associating a task with a future 79 
		* [ ] Making (std::)promises 81 
		* [ ] Saving an exception for the future 83 
		* [ ] Waiting from multiple threads 85
	* [ ] 4.3 Waiting with a time limit 87
		* [ ] Clocks 87 
		* [ ] Durations 88 
		* [ ] Time points 89
		* [ ] Functions that accept timeouts 91
	* [ ] 4.4 Using synchronization of operations to simplify code 93
		* [ ] Functional programming with futures 93 
		* [ ] Synchronizing operations with message passing 97
	* [ ] 4.5 Summary 102
* [ ] 5 The C++ memory model and operations on atomic types 103
	* [ ] 5.1 Memory model basics 104
		* [ ] Objects and memory locations 104 
		* [ ] Objects, memory locations, and concurrency 105 
		* [ ] Modification orders 106
	* [ ] 5.2 Atomic operations and types in C++ 107
		* [ ] The standard atomic types 107 
		* [ ] Operations on std::atomic_flag 110
		* [ ] Operations on std::atomic`<bool>` 112
		* [ ] Operations on std::atomic<T*>: pointer arithmetic 114
		* [ ] Operations on standard atomic integral types 116
		* [ ] The std::atomic<> primary class template 116 
		* [ ] Free functions for atomic operations 117
	* [ ] 5.3 Synchronizing operations and enforcing ordering 119
		* [ ] The synchronizes-with relationship 121 
		* [ ] The happens-before relationship 122 
		* [ ] Memory ordering for atomic operations 123
		* [ ] Release sequences and synchronizes-with 141
		* [ ] Fences 143
		* [ ] Ordering nonatomic operations with atomics 145
	* [ ] 5.4 Summary 147
* [ ] 6 Designing lock-based concurrent data structures 148
	* [ ] 6.1 What does it mean to design for concurrency? 149
		* [ ] Guidelines for designing data structures for concurrency 149
	* [ ] 6.2 Lock-based concurrent data structures 151
		* [ ] A thread-safe stack using locks 151 
		* [ ] A thread-safe queue using locks and condition variables 154
		* [ ] A thread-safe queue using fine-grained locks and condition variables 158
	* [ ] 6.3 Designing more complex lock-based data structures 169
		* [ ] Writing a thread-safe lookup table using locks 169
		* [ ] Writing a thread-safe list using locks 175
	* [ ] 6.4 Summary 179
* [ ] 7 Designing lock-free concurrent data structures 180
	* [ ] 7.1 Definitions and consequences 181
		* [ ] Types of nonblocking data structures 181
		* [ ] Lock-free data structures 182 
		* [ ] Wait-free data structures 182
		* [ ] The pros and cons of lock-free data structures 183
	* [ ] 7.2 Examples of lock-free data structures 184
		* [ ] Writing a thread-safe stack without locks 184
		* [ ] Stopping those pesky leaks: managing memory in lock-free data structures 188
		* [ ] Detecting nodes that can’t be reclaimed using hazard pointers 193
		* [ ] Detecting nodes in use with reference counting 200 
		* [ ] Applying the memory model to the lock-free stack 205
		* [ ] Writing a thread-safe queue without locks 209
	* [ ] 7.3 Guidelines for writing lock-free data structures 221
		* [ ] Guideline: use std::memory_order_seq_cst for prototyping 221
		* [ ] Guideline: use a lock-free memory reclamation scheme 221
		* [ ] Guideline: watch out for the ABA problem 222
		* [ ] Guideline: identify busy-wait loops and help the other thread 222
	* [ ] 7.4 Summary 223
* [ ] 8 Designing concurrent code 224
	* [ ] 8.1 Techniques for dividing work between threads 225
		* [ ] Dividing data between threads before processing begins 226
		* [ ] Dividing data recursively 227 
		* [ ] Dividing work by task type 231
	* [ ] 8.2 Factors affecting the performance of concurrent code 233
		* [ ] How many processors? 234 
		* [ ] Data contention and cache ping-pong 235
		* [ ] False sharing 237 
		* [ ] How close is your data? 238 
		* [ ] Oversubscription and excessive task switching 239
	* [ ] 8.3 Designing data structures for multithreaded performance 239
		* [ ] Dividing array elements for complex operations 240
		* [ ] Data access patterns in other data structures 242
	* [ ] 8.4 Additional considerations when designing for concurrency 243
		* [ ] Exception safety in parallel algorithms 243 
		* [ ] Scalability and Amdahl’s law 250
		* [ ] Hiding latency with multiple threads 252
		* [ ] Improving responsiveness with concurrency 253
	* [ ] 8.5 Designing concurrent code in practice 255
		* [ ] A parallel implementation of std::for_each 255
		* [ ] A parallel implementation of std::find 257 
		* [ ] A parallel implementation of std::partial_sum 263
	* [ ] 8.6 Summary 272
* [ ] 9 Advanced thread management 273
	* [ ] 9.1 Thread pools 274
		* [ ] The simplest possible thread pool 274
		* [ ] Waiting for tasks submitted to a thread pool 276
		* [ ] Tasks that wait for other tasks 280
		* [ ] Avoiding contention on the work queue 283
		* [ ] Work stealing 284
	* [ ] 9.2 Interrupting threads 289
		* [ ] Launching and interrupting another thread 289
		* [ ] Detecting that a thread has been interrupted 291
		* [ ] Interrupting a condition variable wait 291
		* [ ] Interrupting a wait on std::condition_variable_any 294 
		* [ ] Interrupting other blocking calls 296
		* [ ] Handling interruptions 297
		* [ ] Interrupting background tasks on application exit 298
	* [ ] 9.3 Summary 299
* [ ] 10 Testing and debugging multithreaded applications 300
	* [ ] 10.1 Types of concurrency-related bugs 301
		* [ ] Unwanted blocking 301 
		* [ ] Race conditions 302
	* [ ] 10.2 Techniques for locating concurrency-related bugs 303
		* [ ] Reviewing code to locate potential bugs 303
		* [ ] Locating concurrency-related bugs by testing 305
		* [ ] Designing for testability 307 
		* [ ] Multithreaded testing techniques 308 
		* [ ] Testing the performance of multithreaded code 314
	* [ ] 10.3 Summary 314

#roadto