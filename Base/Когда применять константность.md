# Когда применять константность
Константность нужна для того, чтобы защититься от случайного изменения объектов в программах, но она может серьезно раздувать код, поэтому надо искать золотую середину

1. если переменная не изменяется, то объявляйте ее константной
2. не загромождайте ваш код
3. не нарушать инвариантность класса, у множества по итератору нельзя изменить значение(разыменование итератора множества возвращает константную ссылку на элемент), поскольку оно представляет собой дерево двоичного поиска(слева элементы меньше, справа больше)
4. Некоторые объекты полезно делать константными.
```cpp
void CopyIfNotEqual(const vector<T>& src, vector<T>& dst, T value) {
	std::remove_copy(begin(src), end(src), back_inserter(dst), value); //в данном примере входной веткор src не должен изменять, поэтому мы делаем его константным. Если мы случайно передадаим его в back_inserter случиться ошибка, а чтобы было если бы мы не объявли его const
}
```
5. Не снимать константность у методов которые не должны изменять объект. Если вы хотите снять `const`, возможно вы делаете что-то не так, а также помните про mutable. Но не стоит объявлять все поля как mutable, в этом случае мы нарушаем гарантии которые дает `const`
6. Помните про потокобезопасность `mutable` полей.
