# Многопоточность Golang
В Go независимо запущенная задача называется **горутиной** - это [[Потоки#User level threads|user level threads]]
Преимущества горутин:
1.  Они легковесны.
2.  Легко и без проблем масштабируют.
3.  Они — практически потоки.
4.  Требуют меньше памяти (2KB).
5.  Предоставляют дополнительную память горутинам во время выполнения.

Для запуска горутины перед вызовом функции нужно прописать `go`
```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	names := [4]string{"Gopher", "Rob Pike", "Ken Thompson", "Linus Torvalds"}
	go hi()
	go name(names)

	time.Sleep(time.Second * 10)
	fmt.Println("Time is over - bye!")
}

func hi() {
	for {
		val := rand.Intn(3)
		time.Sleep(time.Second * time.Duration(val))
		fmt.Println("Hi!")
	}
}

func name(names [4]string) {
	for {
		val := rand.Intn(3)
		time.Sleep(time.Second * time.Duration(val))
		fmt.Println("My name is:", names[val])
	}
}
```

# Изменение количества ядер
```
runtime.GOMAXPROCS(4)
```

# Каналы
Канал представляет собой механизм связи, который позволяет одной горутине отправлять некоторые значения другой горутине. Каждый канал является средством передачи значений определённого типа, который называется типом элементов канала.
```go
channel := make(chan int)    // channel имеет тип 'chan int'
```

Как и отображение, канал является ссылкой на структуру данных. Копируя или передавая канал в функцию в качестве аргумента, мы копируем ссылку на одну и ту же структуру данных. Нулевым значением канала является nil.

Канал имеет две основные операции:
-   **Отправление (запись)** - передаёт через канал значение из одной горутины в другую. `channel <- num // отправляет в канал channel значение num`
-   **Получение (чтение)** - получение через канал значения из другой горутины. `num = <- channel // получение из канала channel в переменную num`

Чтение из канала может производится в цикле:

```go
for v := range channel {//чтение будет осуществляться пока канал открыт
    ...
}
```

Каналы поддерживают операцию закрытия встроенной функцией close:

```go
close(channel)
```

Попытка передать данные в закрытый канал приведет к возникновению аварийной ситуации, однако операция получения будет работать и с закрытым каналом - будут получены все значения, которые были отправлены, но еще не прочитаны. После получения всех значений из канала, будет возвращаться нулевое значение типа канала.

Каждый канал имеет длину и емкость (их можно получить с помощью знакомых нам функций len() и cap()): длина - количество значений в канале в текущий момент, емкость - размер буфера.

При отправлении значения в небуферизованный канал отправляющая горутина блокируется до тех пор, пока другая горутина не выполнит получение из этого канала. После этого обе горутины продолжают работать. Верно и обратное, если горутина получает значение, она блокируется, пока значение не будет получено.

```go
c := make(chan int, 1)      // здесь 1 - размер буфера  
fmt.Println(len(c), cap(c)) // 0 1  
c <- 1  
fmt.Println(len(c), cap(c)) // 1 1  
<-c  
fmt.Println(len(c), cap(c)) // 0 1
```

Если же размер буфера будет 0, то выполнение программы приведет к панике, так как записанное значение одновременно с записью в канал не вычитывается.

```go
pipe := make(chan int)     // небуферизованный канал
pipe := make(chan int, 0)  // небуферизованный канал
pipe := make(chan int, 5)  // буферизованный канал с ёмкостью 5
```

Буферизованные каналы представляют из себя [[queue]], операция отправления в буферизованный канал добавляет элемент в конец очереди `channel <- "A"`, операция извлечения, извлекает первый элемент из очереди `fmt.Println(<-channel) // "A"`.

Если канал заполнен, операция отправления блокирует свою горутину, до тех пор, пока другая горутина не освободит место, получив данные из канала.

Небуферизованные каналы дают более надежные гарантии синхронизации, потому что каждая операция отправления связана с операцией получения. В случае буферизованных каналов, эти операции разделены.

# Блокировки
Горутины блокируются для повышения производительности неработоспособных каналов.

## Блокировка при записи
Горутина, посылающая данные в канал, блокируется, покуда другая горутина не прочитает данные из него. Всё просто.

## Блокировка при чтении
Горутина, получающая данные из канала,  может быть заблокирована до момента получения данных в канал. Аналогично блокировке при записи.

## select
Используя конструкцию _**select-case**_ можно избежать блокирующего поведения.
```go
package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:
			x, y = y, x+y
		case <-quit:
			fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
```
Если данные есть, горутина их прочитает, иначе выйдет из функции.