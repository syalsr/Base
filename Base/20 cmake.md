# 20 cmake
#do/start  https://www.youtube.com/watch?v=LZwEtbc9gEA

# Минимальный проект
Все CMake проект начинаются с файла `CMakeLists.txt` - это что-то на подобие проектного файла, определяющий все что связано со сборкой.

```cmake
cmake_minimum_required(VERSION 3.3)

project(MyApp)

add_executable(myExe
    main.cpp
    src1.cpp
    src2.h
)

set_target_properties(
		MyExe PROPERTIES
		CXX_STANDART 11
		CXX_STANDART_REQUIRED ON
)
```

1. cmake_minimum_required() - устанавливаем минимальную версию cmake, при наличии более старой версии выдаст ошибку.
2. project - создание проекта с именем MyApp - отвечает не только за имя проекта, но и за инициализацию чего-то, в общем обязательная функция, как и версия cmake.
3. add_executable - из 2 объектных файлов хотим собрать исполняемый файл myExe, файла .h не обязательно добавлять, т.к. компилятор итак при препроцесинге их вставляет в .cpp, но так они хотя бы отображаются в проекте.
4. set_target_properties - указываем свойства проекта - собираем проект на как минимум 11 стандарте


Имена команд не чувствительны к регистру

## Команда project()
В LANGUAGES указываются языки C, CXX, Fortran, ASM, Java и другие(по умолчанию C и CXX). Можно указать `LANGUAGES NONE`, что означает поддержку ни одного из языков.

```shell
project(myProh C CXX)
```

Команда `project()` проверяет наличие компилятора для каждого `LANGUAGES` и их работоспособность. Проблемы с настройкой компилятора и компоновщика обнаруживаются очень рано. Как только эти проверки пройдены, CMake устанавливает ряд переменных и свойств, которые управляют сборкой для включенных языков. Если `CMakeLists.txt` не вызывает project() или не вызывает его достаточно рано, CMake будет неявно вызывать его внутренне для языков по умолчанию `C` и `CXX`, чтобы гарантировать, что компиляторы и компоновщики правильно настроены для других команд, которые полагаются на них.

Когда проверки компилятора и компоновщика, выполняемые CMake, успешны, их результаты кэшируются, так что их не нужно повторять в последующих запусках CMake. Эти кэшированные сведения хранятся в каталоге сборки в `CMakeCache.txt`.

## Команда add_executable()
Эта команда говорит CMake'у создать исполняемый файл из набора исходных файлов. Базовая запись команды
```shell
add_executable(targetName source1 [source2 ...])
```
`targetName` - это имя исполняемого файла. По умолчанию на Windows имя исполняемого файла будет таким `targetName.exe`, на Unix(Linux, MacOS и т.л.) - `targetName`. 

Несколько исполняемых файлов могут быть определены в пределах одного `CMakeLists.txt`, вызывая `add_executable()` несколько раз с разными целевыми именами. Если одно и то же целевое имя используется более чем в одной команде `add_executable()`, будет ошибк.

## Комментирование
Комментарий начинается с символа `#`. Пример
```sh
cmake_minimum_required(VERSION 3.2)
# We don't use the C++ compiler, so don't let project()
# test for it in case the platform doesn't have one
project(MyApp VERSION 4.7.2 LANGUAGES C)

# Primary tool for this project
add_executable(mainTool
    main.c
    debug.c # Optimized away for release builds
)
# Helpful diagnostic tool for development and testing
add_executable(testTool testTool.c)
```

#do/review все что ниже переписать, либо стереть и заново книгу прочитать
## Building Simple Targets
### Executables
Более полная форма команды `add_executable()`
```sh
add_executable(targetName [WIN32] [MACOSX_BUNDLE]
               [EXCLUDE_FROM_ALL]
               source1 [source2 ...]
)
```
Единственные отличия в новый ключевых словах
* WIN32
    При построении исполняемого файла на платформе Windows этот параметр указывает CMake построить исполняемый файл как приложение с графическим интерфейсом Windows. На практике это означает, что он будет создан с точкой входа WinMain() вместо просто main() и будет связан с параметром /SUBSYSTEM:WINDOWS. На всех других платформах параметр WIN32 игнорируется.
* MACOSX_BUNDLE
    CMake направляет его на сборку пакета приложений при сборке на платформах MacOS и iOS. CMake также будет генерировать базовую информацию.plist-файл для пакетов.
* EXCLUDE_FROM_ALL
    Иногда проект определяет несколько целей, но по умолчанию должны быть построены только некоторые из них. Если во время сборки цель не указана, то по умолчанию создается цель `ALL`. Если исполняемый файл определен с параметром `EXCLUDE_FROM_ALL`, он не будет включен в этот целевой объект по умолчанию `ALL`. Затем исполняемый файл будет построен только в том случае, если он явно запрашивается командой build или если он является зависимостью для другого целевого объекта, который является частью сборки `ALL` по умолчанию. Распространенная ситуация, когда может быть полезно исключить цель из всех, - это когда исполняемый файл является инструментом разработчика, который требуется только иногда. #do/review ничего не понятно по этому exclude найти другую инфу

### Команда add_library()
Целевые объекты библиотеки определяются с помощью команды add_library (), которая содержит несколько форм. Наиболее основными из них являются следующие:
```sh
add_library(targetName [STATIC | SHARED | MODULE]
            [EXCLUDE_FROM_ALL]
            source1 [source2 ...]
)
```
Имя цели используется в списках `CMakeLists.txt` для ссылки на библиотеку, причем имя встроенной библиотеки в файловой системе по умолчанию является производным от этого имени. Ключевое слово EXCLUDE_FROM_ALL имеет точно такой же эффект, как и для add_executable (), а именно для предотвращения включения библиотеки в целевой объект ALL по умолчанию. Тип создаваемой библиотеки определяется одним из оставшихся трех ключевых слов `STATIC`, `SHARED` или `MODULE`.

* STATIC
    Указывает статическую библиотеку или архив. В Windows имя библиотеки по умолчанию будет targetName.lib, в то время как на Unix-подобных платформах это обычно будет libtargetName.a
* SHARED
    Указывает общую или динамически связанную библиотеку. В Windows имя библиотеки по умолчанию будет targetName.dll, на платформах Apple - libtargetName.dylib и на других Unix-подобных - libtargetName.so 
* MODULE
    Указывает библиотеку, которая чем-то похожа на общую библиотеку, но предназначена для динамической загрузки во время выполнения, а не для прямой связи с библиотекой или исполняемым файлом. Обычно это плагины или дополнительные компоненты, которые пользователь может выбрать для загрузки или нет. На платформах Windows библиотека импорта для библиотеки DLL не создается.

Можно опустить ключевое слово, определяющее, какой тип библиотеки следует построить. Если проект специально не требует определенного типа библиотеки, предпочтительной практикой является не указывать его и оставлять выбор за разработчиком при построении проекта. В таких случаях библиотека будет либо статической, либо общей, причем выбор будет определяться значением переменной CMake, называемой BUILD_SHARED_LIBS. Если для параметра BUILD_SHARED_LIBS установлено значение true, то целевой библиотекой будет общая библиотека, иначе она будет статичной. Работа с переменными подробно описана позже, но на данный момент один из способов установить эту переменную - включить опцию -D в командной строке cmake следующим образом:
```sh
cmake -DBUILD_SHARED_LIBS=YES /path/to/source
```

Он может быть установлен в `CMakeLists.txt` со следующим текстом(помещается перед любыми командами `add_library()`), но это потребует от разработчиков изменить его, если они захотят изменить его (т. е. он будет менее гибким):
```sh
set(BUILD_SHARED_LIBS YES)
```

### Lingking Targets
При рассмотрение таргетов из которых состоит проект, разработчики привыкли мыслить в терминах библиотеки `A`, нуждающейся в библиотеке `B`, поэтому `A` привязана к `B`. Это традиционный взгляд на работу с библиотеками, где идея о том, что одна библиотека нуждается в другой, очень упрощена. В реальности, однако, существует несколько различных типов зависимостей, которые могут существовать между
библиотеки:
* PRIVATE
    Приватные зависимости указывают, что библиотека `A` использует библиотеку `B` в своей собственной внутренней реализации. Все остальное, что связано с библиотекой `А`, знать о `B` не нужно, так как это внутренняя реализация `А`.
* PUBLIC
    Публичные зависимости указывают, что библиотека `A` не только использует библиотеку `B` внутренне, но и использует `B` в своем интерфейсе. Это означает, что `A` не можем использоваться без `B`, поэтому все что использует `A` будет иметь прямую зависимость от B. Примером этого может служить функция, определенная в библиотеке A, которая имеет по крайней мере один параметр типа, определенный и реализованный в библиотеке B, поэтому код не может вызвать функцию из A без предоставления параметра, тип которого исходит из B.
* INTERFACE
    Зависимости интерфейса указывают, что для использования библиотеки A должны использоваться части библиотеки B. Это отличается от публичной зависимости тем, что библиотека А не требует B внутри, она использует только B в своем интерфейсе. Примером, где это полезно, является работа с библиотечными таргетами, определенными с помощью INTERFACE формы add_library(), например, при использовании таргетов для представления зависимостей только заголовка библиотеки.

CMake захватывает этот более богатый набор зависимостей с помощью своей команды target_link_libraries(), а не просто упрощенную идею необходимости связывания.
```sh
target_link_libraries(targetName
    <PRIVATE|PUBLIC|INTERFACE> item1 [item2 ...]
    [<PRIVATE|PUBLIC|INTERFACE> item3 [item4 ...]]
    ...
)
```
Это позволяет проектам точно определить, как одна библиотека зависит от других. CMake затем позаботится управления зависимостями по всей цепочке библиотек, связанных таким образом. Например, рассмотрим следующее:
```sh
add_library(collector src1.cpp)
add_library(algo src2.cpp)
add_library(engine src3.cpp)
add_library(ui src4.cpp)
add_executable(myApp main.cpp)
target_link_libraries(collector
    PUBLIC ui
    PRIVATE algo engine
)
target_link_libraries(myApp PRIVATE collector)
```
В этом примере библиотека `ui` связана с библиотекой `collector` как публичная,  так что даже если myApp будет напрямую связан с коллектором, myApp также будет связан с ui из-за этой связи как PUBLIC. Библиотеки алгоритмов и движков, с другой стороны, связаны с коллектором как PRIVATE, так что myApp не будет напрямую связан с ними.

### Linking Non-targets
Кроме таргетов CMake, команде `target_link_libraries()` в качестве элементов могут быть указаны следующие вещи:
* Full path to a library file
    `Cmake` добавит библиотечный файл в команду компоновщика. Если библиотечный файл изменится, `CMake` обнаружит это и повторно свяжет целевой объект. Начиная с версии cmake 3.3 команда компоновщика всегда использует полный указанный путь, но до версии 3.3 были некоторые ситуации, когда CMake мог попросить компоновщика вместо этого выполнить поиск библиотеки (например, заменить /usr/lib/libfoo.so на-lfoo).
* Plain library name
    Если задано только имя библиотеки без пути, команда компоновщика будет искать эту библиотеку(например, foo становится-lfoo или foo.lib, в зависимости от платформы). Это было бы общим для библиотек, предоставляемых системой.
* Link flag
    В частном случае, элементы начинающиеся с дефиса, отлично от -| или -framework, будут рассматриваться как флаги, добавляемые в команду компановщика. Документация `CMake` предупреждает, что они должны использоваться только для приватных элементов, тк они будут перенесены на другие таргеты, если они определены как общежоступные или интерфейсные, и это не всегда может быть безопасно.

В дополнение к вышесказанному, по историческим причинам, любому пункту может предшествовать одно из ключевых слов `debug`, `optimized` или `general`. Эффект этих ключевых слов заключается в дальнейшем уточнении того, когда следующий за ним элемент должен быть включен в зависимости от того, настроена ли сборка как отладочная сборка (см. Главу 13, тип сборки). Если элементу предшествует ключевое слово debug, то он будет добавлен только в том случае, если сборка является отладочной сборкой. Если элементу предшествует ключевое слово optimized, он будет добавлен только в том случае, если сборка не является отладочной сборкой. Ключевое слово general указывает, что элемент должен быть добавлен для всех конфигураций сборки, что в любом случае является поведением по умолчанию, если ключевое слово не используется. Для новых проектов следует избегать ключевых слов debug, optimized и general, поскольку существуют более четкие, гибкие и надежные способы достижения того же самого с помощью современных функций CMake.

### Old-style CMake
Команда `target_link_libraries()` также имеет несколько других форм. Эти формы обсуждаются здесь в интересах понимания старых проектов CMake, но их использование обычно не рекомендуется для новых проектов. Следует предпочесть полную форму, показанную ранее с разделами PRIVATE, PUBLIC и INTERFACE, так как она с большей точностью выражает природу зависимостей.

```shell
target_link_libraries(targetName item [item...])
```

Приведенная выше форма обычно эквивалентна элементам, определяемым как публичные, но в некоторых ситуациях они могут рассматриваться как частные. В частности, если проект определяет цепочку библиотечных зависимостей со смесью как старых, так и новых форм команды, то форма старого стиля обычно будет рассматриваться как частная.

Еще одна поддерживаемая, но устаревшая форма - это следующая:

```shell
target_link_libraries(targetName
    LINK_INTERFACE_LIBRARIES item [item...]
)
```
Это предварительный курсор к ключевому слову интерфейса новой формы, описанной выше, но его использование не рекомендуется документацией CMake. Его поведение может влиять на различные целевые свойства, причем параметры политики управляют этим поведением. Это потенциальный источник путаницы для разработчиков, которой можно избежать, используя вместо этого более новую форму интерфейса.

```shell
target_link_libraries(targetName
     <LINK_PRIVATE|LINK_PUBLIC> lib [lib...]
    [<LINK_PRIVATE|LINK_PUBLIC> lib [lib...]]
)
```
Подобно предыдущей форме старого стиля, эта форма является предварительным курсором для частных и публичных версий ключевых слов новой формы. Опять же, форма старого стиля имеет ту же путаницу в отношении того, на какие целевые свойства она влияет, и форма частного/публичного ключевого слова должна быть предпочтительной для новых проектов.

### Recommended Practices
Имена целевых объектов не обязательно должны быть связаны с именем проекта. Обычно в учебниках и примерах используется переменная для имени проекта и повторно используется эта переменная для имени исполняемого объекта, например:

```shell
# Poor practice, but very common
set(projectName MyExample)
project(${projectName})
add_executable(${projectName} ...)
```

Это работает только для самых простых проектов и поощряет ряд вредных привычек. Рассматривайте имя проекта и имя исполняемого файла как отдельные, даже если изначально они начинаются одинаково. Задайте имя проекта напрямую, а не через переменную, выберите целевое имя в соответствии с тем, что делает цель, а не с проектом, частью которого она является, и предположите, что проект в конечном итоге должен будет определить более одной цели. Это укрепляет лучшие привычки, которые будут важны при работе над более сложными многоцелевыми проектами.

Называя целевые объекты для библиотек, не поддавайтесь искушению начинать или заканчивать имя с lib. На многих платформах (то есть почти на всех, кроме Windows) ведущая библиотека lib будет автоматически иметь префикс при построении фактического имени библиотеки, чтобы оно соответствовало обычному соглашению платформы. Если целевое имя уже начинается с lib, то результирующие имена файлов библиотеки заканчиваются формой liblibsomething...., что люди часто считают ошибкой.

Если для этого нет веских причин, старайтесь избегать указания статического или общего ключевого слова для библиотеки, пока не станет известно, что оно необходимо. Это позволяет более гибко выбирать между статическими и динамическими библиотеками в качестве общей стратегии проекта. Переменная `BUILD_SHARED_LIBS` может быть использована для изменения значения по умолчанию в одном месте вместо того, чтобы изменять каждый вызов функции `add_library()`.

Стремитесь всегда указывать `PRIVATE, PUBLIC, INTERFACE` ключевые слова при вызове команды `target_link_libraries()`, а не следовать старому синтаксису CMake, который предполагал, что все было общедоступным. По мере роста сложности проекта эти три ключевых слова оказывают более сильное влияние на то, как обрабатываются межцелевые зависимости. Использование их с самого начала проекта также заставляет разработчиков задуматься о зависимостях между целями, что может помочь выявить структурные проблемы в рамках проекта гораздо раньше.

## Chapter 5. Variables
### Variable basics
Как и любой вычислительный язык, переменные являются краеугольным камнем выполнения задач в CMake. Самый простой способ определения переменной-это команда set (). Нормальная переменная может быть определена в CMakeLists.txt файл выглядит следующим образом:

```shell
set(varName value... [PARENT_SCOPE])
```

Имя переменной `varName` может содержать буквы, цифры и символы подчеркивания, буквы чувствительны к регистру. Имя может также содержать символы `./-+`, но они редко встречаются на практике.

В CMake переменная имеет определенную область действия, подобно тому, как переменные в других языках имеют область действия, ограниченную определенной функцией, файлом и т. д. Переменная не может быть прочитана или изменена вне ее области видимости. По сравнению с другими языками, область действия переменной в CMake немного более гибкая, но пока в простых примерах в этой главе рассмотрим область действия переменной как глобальную.

CMake обрабатывает все переменные как строки. В различных контекстах переменные могут интерпретироваться как разные типы, но в конечном счете они являются просто строками. При установке значения переменной CMake не требует, чтобы эти значения были заключены в кавычки, если только значение не содержит пробелов. Если задано несколько значений, то они будут объединены точкой с запятой, разделяющей каждое значение - результирующая строка представляет собой то, как CMake представляет списки. Следующее должно помочь продемонстрировать поведение.

```shell
set(myVar a b c) # myVar = "a;b;c"
set(myVar a;b;c) # myVar = "a;b;c"
set(myVar "a b c") # myVar = "a b c"
set(myVar a b;c) # myVar = "a;b;c"
set(myVar a "b c") # myVar = "a;b c"
```

Значение переменной получается с помощью `${myVar}`, который можно использовать везде, где ожидается строка или переменная. CMake особенно гибок в том, что также можно использовать эту форму рекурсивно или указать имя другой переменной для установки. Кроме того, CMake не требует определения переменных перед их использованием. Использование неопределенной переменной просто приводит к замене пустой строки без ошибок или предупреждений, подобно сценариям оболочки Unix.

```shell
set(foo ab)               # foo = "ab"
set(bar ${foo}cd)         # bar = "abcd"
set(baz ${foo} cd)        # baz = "ab;cd"
set(myVar ba)             # myVar = "ba"
set(big "${${myVar}r}ef") # big = "${bar}ef" = "abcdef"
set(${foo} xyz)           # ab = "xyz"
set(bar ${notSetVar})     # bar = ""
```

Строки не ограничиваются одной строкой, они могут содержать встроенные символы новой строки. Они также могут содержать кавычки, которые требуют экранирования с помощью обратной косой черты.

```shell
set(myVar "goes here")
set(multiLine "First line ${myVar}
Second line with a \"quoted\" word")
```