# Множества Python
-   все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение;
-   множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке;
-   элементы множества должны относиться к неизменяемым типам данных;
-   хранящиеся в множестве элементы могут иметь разные типы данных.

```python
numbers = {2, 4, 6, 8, 10}
languages = {'Python', 'C#', 'C++', 'Java'}
info = {'Timur', 1992, 61.5}
print(numbers) # {2, 4, 6, 8, 10}
print(languages) # {'C#', 'Python', 'Java', 'C++'} множества не упорядочены, поэтому элементы отличаются порядком
myset = set()   # пустое множество
myset = {} # создается не множества а словарь
```

## set()
```python
myset1 = set(range(10))          # множество из элементов последовательности
myset2 = set([1, 2, 3, 4, 5])    # множество из элементов списка
myset3 = set('abcd')             # множество из элементов строки
myset4 = set((10, 20, 30, 40, 10))   # множество из элементов кортежа myset4 = {10,20,30,40}

emptyset1 = set([])         # пустое множество из пустого списка
emptyset2 = set('')         # пустое множество из пустой строки
emptyset3 = set(())         # пустое множество из пустого кортежа
```

## frozenset()
Создает неизменяемое множество, т.е. после создания его никак нельзя будет изменить, как [[tuple Кортеж Python]]

```python
myset1 = frozenset({1, 2, 3})                         # на основе множества
myset2 = frozenset([1, 1, 2, 3, 4, 4, 4, 5, 6, 6])    # на основе списка
myset3 = frozenset('aabcccddee')                      # на основе строки
```

Такие множества могут быть элементами других множеств, т.к. являются неизменяемыми.

## Перебор
```python
numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7}
for num in numbers:
    print(num)
0
1
2
3
5
6
7
# Порядок может отличаться

numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7}
print(*numbers, sep='\n')
0
1
2
3
5
6
7
# Порядок может отличаться

numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7}
sorted_numbers = sorted(numbers)
print(*sorted_numbers, sep='\n') # выведет гарантированно элементы по возрастанию
```

## add()
```python
numbers = {1, 1, 2, 3, 5, 8, 3}  # создаем множество
numbers.add(21)  # добавляем число 21 в множество
numbers.add(34)  # добавляем число 34 в множество
```

## remove()
Удаляет элемент из множества с генерацией исключения (ошибки) в случае, если такого элемента нет.
```python
numbers = {1, 2, 3, 4, 5}
numbers.remove(3) # {1, 2, 4, 5}
numbers.remove(10) # KeyError
```

## discard()
Удаляет элемент из множества без генерации исключения.

```python
numbers = {1, 2, 3, 4, 5}
numbers.discard(10) # ok
```

## pop()
Удаляет и возвращает случайный элемент из множества с генерацией исключения (ошибки) при попытке удаления из пустого множества.

```python
numbers = {1, 2, 3, 4, 5}
num = numbers.pop() # удаляет случайный элемент множества, возвращая его

```

## issubset()
Для определения, является ли одно из множеств подмножеством другого

```python
set1 = {2, 3}
set2 = {1, 2, 3, 4, 5, 6}
print(set1.issubset(set2)) # True
print(set1 <= set2) # True
```

## issuperset
Для определения, является ли одно из множеств надмножеством другого

```python
set1 = {'a', 'b', 'c', 'd', 'e'}
set2 = {'c', 'e'}
print(set1.issuperset(set2)) #  True
```

## isdisjoint()
Для определения отсутствия общих элементов в множествах

```python
set1 = {1, 2, 3, 4, 5}
set2 = {5, 6, 7}
set3 = {7, 8, 9}
print(set1.isdisjoint(set2)) # False
print(set1.isdisjoint(set3)) # True
print(set2.isdisjoint(set3)) # False
```

# Создание множества 
## Из строк
```python
myset = set('aaa bbbb cc')         # {' ', 'c', 'a', 'b'}
myset = set(['aaa', 'bbbb', 'cc']) # {'bbbb', 'aaa', 'cc'}
```

## Из цифр числа
```python
digits = set(int(input())) # TypeError: 'int' object is not iterable
digits = set(input()) # '12345' {'1', '2', '3', '4', '5'}
digits = {int(c) for c in input()} # '12345' {1, 2, 3, 4, 5}
digits = {int(d) for d in 'abcd12ef78ghj90' if d.isdigit()}
```

## Из символов строки
```python
chars = {c for c in 'abcdefg'}
```

# Методы возвращают новые множества
Все эти методы можно также использовать с итерируемыми объектами

## union()
**Возвращает новое множество** в которое входят все элементы множеств.

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.union(myset2) # {1, 2, 3, 4, 5, 6, 7, 8}
myset3 = myset1 | myset2 # вместо метода можно использовать оператор |
```

## intersection()
**Пересечение** множеств это множество, состоящее из элементов, принадлежащих одновременно каждому из пересекающихся множеств.

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.intersection(myset2) # {3, 4}
myset3 = myset1 & myset2
```

## difference()
**Разность** множеств это множество, в которое входят все элементы первого множества, не входящие во второе множество.

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.difference(myset2) # {1, 2, 5}
myset3 = myset1 - myset2
```

## symmetric_difference()
**Симметрическая разность** множеств это множество, включающее все элементы исходных множеств, не принадлежащие одновременно обоим исходным множествам.

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.symmetric_difference(myset2) # {1, 2, 5, 6, 7, 8}
myset3 = myset1 ^ myset2
```

# Методы изменяют исходное множество
Все эти методы можно также использовать с итерируемыми объектами

## update()
Изменяет исходное множество **по объединению**.

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1.update(myset2) # {1, 2, 3, 4, 5, 6, 7, 8}
myset1 |= myset2
```

## intersection_update()
Изменяет исходное множество **по пересечению**.

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1.intersection_update(myset2) # {3, 4}
myset1 &= myset2
```

## difference_update()
Изменяет исходное множество **по разности**.

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1.difference_update(myset2) # {1, 2, 5}
myset1 -= myset2
```

## symmetric_difference_update()
Изменяет исходное множество **по симметрической разности**.

```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1.symmetric_difference_update(myset2) # {1, 2, 5, 6, 7, 8}
myset1 ^= myset2
```