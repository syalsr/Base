# Выделение и освобождение динамической памяти
## Операторы new && delete
Для того, чтобы выделить память в куче нужно использовать оператор `new` и указатель `T*`, указатель должен быть чем-то проинициализирован либо быть `nullptr`.

```cpp
int* pInt = new int;//pInt указатель на значение типа int
//pInt как адрес, будет храниться на стеке и указаывать на область памяти в куче.

int** handle { nullptr };
handle = new int*;//handle - адресс находящийся на стеке, который указывает на переменную
*handle = new int;//*handle находящуюся в куче которая указывает на переменную int тоже находящуюся в куче
```

Оператор `new` возвращает указатель на объект который он создал(если тип double, то new вернет указатель типа double*), если их несколько, как в примере выше, то на первый объект.

Мы не можем присваивать указатели разных типов друг другу, т.к. они имеют разные типы $=>$  они занимают разный объем памяти.

Указатель – это адрес в памяти. Память в С++ представляется как линейный массив байтов. Указатель – это индекс в этом массиве.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
cout << ∗s << ' ' << s−>size () << endl; 
// Hello 5
```

Оператор `*`, примененный к указателю, возвращает ссылку на объект в куче.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
string& ref_to_s = ∗s; 
ref_to_s += ", world"; 
cout << ∗s << endl; 
// Hello, world
```


Если мы выделим память в куче, не удалим и указатель на эту область выйдет из области видимости, то произойдет утечка, мы никак не сможем удалить ее, т.к. доступа к ней нет, поэтому программа будет тратить лишнюю память. Если выделять память в куче в цикле `for` и не освобождать, то на какой-то итерации произойдет вылет из программы(в зависимости от объема вашей оперативной памяти).

```cpp
int* pInt = new int;
delete pInt;
pInt = nullptr; //рекомендуется занулять удаленный указать, чтобы случайно его не использовать, поскольку pInt еще указывает на область памяти в куче, обращение к ней UB, повторное удаление UB.

int** handle { new int* };
*handle = new int;
delete *handle;
delete handle;
handle = nullptr;
```

Перед delete не обязательно проверять объект на nullptr
## Операторы new[ ] && delete[ ]
Оператор new[] позволяет выделить блок памяти для хранения необходимого количества объектов.

```cpp
double *p;
p = new double[4];//выделяем память для 4 чисел типа double
int* myArrayPtr { new int[] { 1, 2, 3, 4, 5 } };

double** twoarr { new double*[4]};
for (size_t i { 0 }; i < 4; i++) { twoarr[i] = new double; } //allocate
for (size_t i { 0 }; i < 4; i++) {//deallocate
	delete twoarr[i];
	twoarr[i] = nullptr;
}
delete [] twoarr;
twoarr = nullptr;
```

![](cpp_basic16.png)

Доступ к элементам массива мы можем получить с помощью оператора индексирования.

```cpp
double *pd = new double[3];
double x = *pd; //присваиваем x первое значение массива
pd[2] = 2.2;
pd[4] = 4.4;
pd[-3] = -3.3;
delete pd;
pd = nullptr;
```
Т.к. указатель не знает на какой диапазон элементов он указывает, то мы можем выходить за его рамки и компилятор не посчитает это за ошибку. Мы просто изменить значения другого объекта, о котором мы ничего не знаем.

![](cpp_basic18.png)

pd - динамически выделяемый массив, не динамический массив, мы можем указать размер во время выполнения программы, но не можем расширять его

## new и delete для объектов классового типа
При выделении памяти в куче для объекта классового типа вызывается конструктор, при удалении с помощью `delete` вызывается [[деструктор]].

## Разница между new/delete и malloc/free
1. new в отличии от malloc, вызывает констурктор у объекта
```cpp
Foo* myFoo { (Foo*)malloc(sizeof(Foo)) };//выделилась память нужного размера
Foo* myOtherFoo { new Foo{} };//выделилась память и создался объект
```
1. При вызове `free()` у класса не вызовется деструктор в  отличии от `delete`
2. new - оператор который можно переопределить

## Исключения и new
new может выбросить исключение, если ей не удается выделить нужное количество памяти из-за нехватки ресурсов
```cpp
int* ptr { new(nothrow) int };//вместо исключения возратит nullptr, но рекомендуется использовать стандартный new
```

## Многомерные массивы
Многомерные массивы можно представить как матрицу и в памяти элементы располагаются так

![[../Files/Pasted image 20220422174530.png]]

```cpp
char board[12][12]{};
```

### jagged array
Помимо этого многомерный массив можно создать с помощью массива указателей

![[../Files/Pasted image 20220422175150.png]]

И вычисляет адреса по разному

```cpp
void foo(int (*pcont)[10]){ 
	pcont[1][2] = 1; //*(&cont[0][0] + 1 * 10 + 2) = 1
}
int cont[5][10]; 
foo(cont); 
cont[1][2] = 1;//*(&cont[0][0] + 1 * 10 + 2) = 1
//-----------------------------------------
void bar(int **pjag) { 
	pjag[1][2] = 1; //*(*(jagged + 1) + 2) = 3
}
int *jagged[10]; 
bar(jagged); 
jagged[1][2] = 1;//*(*(jagged + 1) + 2) = 3
```

Мы всегда можем опускать только самый вложенный индекс: и в инициализаторах и в параметрах функций

```cpp
float flt[2][3] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // ok 
float flt[][3] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // ok 
float flt[][] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // fail
float func(float flt[][3][6]); // ok, float *flt[3][6]
```

### Куча

```cpp
char** board { new char*[xPos] };
for (size_t i { 0 }; i < xPos; i++) {
	board[i] = new char[yPos]; // Allocate ith subarray
}
...
for (size_t i { 0 }; i < xPos; i++) {
	delete [] board[i]; // Delete its subarray
	board[i] = nullptr;
}
delete [] board; // Delete first dimension
board = nullptr;
```

Но это не совсем эффективно, лучше выделить сразу нужный блок памяти $=xPos * yPos * sizeof(char)$ и обращаться к элементам как $x * yPos + y$, поскольку программа будет работать быстрее если ее данные расположены последовательно.