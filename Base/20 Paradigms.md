# 20 Paradigms
# Объектно-ориентированная философия
Объектно-ориентированный подход основан на вопросе - Какой объект реального мира я моделирую? ООП основывается на том, что вы должны разделить вашу программу на физические модели, рассматривая их с точки зрения их классов, компонентов, свойств и поведения.

## Классы
Класс - это инкапсуляция того, что определяет классификацию объекта, допустим если это фрукт, то что это за фрукт, он растет на дереве или из почвы, какие оттенки цвета он принимает, какие у него питательные свойства и т.д.

Объект - это экземпляр класса с определенными свойствами, определенным оттенком цвета, определенного размера и т.д.

## Компоненты
Основная задача ООП состоит в разделении задачи на компоненты. Как сделать машину? Сложно и непонятно. Но если разделим эту задачу на компоненты, к примеру, двигатель, руль, сиденья, бампер и т.д., то становится уже проще. Компонент - это узкоспециализированный класс. Класс машина будет состоять из небольших компоненты двигателя, колеса и т.д., он не будет определять поведения этих компонентов, он будет определять поведение между компонентами. Таким образом, мы не раздуваем класс.

## Свойства
Свойства - это то что отделяет один объект от другого, к примеру, оттенок, вкус, размер.

## Поведение
Поведение отвечает на вопрос, что этот объект делает? Что я могу с ним сделать? К примеру, фрукт мы можем разрезать, съесть, кинуть. Поведение класса реализуется в методах.

## Применение ООП
Людей которые его применяют можно разделить на 2 категории
1. Инкапсулируют только то, скажем так, логично может быть классом
2. Инкапсулируют все, что можно, даже в тех случаях когда можно было обойтись лишь парой функций или переменных. К примеру, в программе крестики нолики, вы создаете класс для крестика и нолика, вместо использования `enum class` который описывал бы состояния клетки.

Что успешно применять ООП нужно найти золотую середину между этими подходами.

## Отношения между классами
### is-a
Используется при наследовании. Когда мы наследуем класс мы должны задать вопрос, является ли A наследником B, т.е. если мы наследуемся от фрукта, является ли апельсин фруктом, да является, логические мы верно наследуемся. А если мы наследуемся от машины мотоциклом, будет логически не верно, мотоцикл не является машиной

#### Техники наследования
1. Добавление функциональности - добавление специфичных функций
2. Замена функциональности - определение виртуальных методов
3. Добавление свойств - добавление специфичных свойств
4. Замена свойств - тоже самое, что и с виртуальными функциями
5. Полиморфизм - это понятие о том, что наследники и наследуемые объекты могут использоваться как взаимозаменяемые. Т.е. у нас есть класс Animal, от него наследуется тигр, лев, гепард и каждый переопределяет виртуальные функции для себя, мы хотим, заставить каждое животное говорить, можно создать набор этих животных у которых общим классом будет Animal, проитерироваться и у каждого вызвать метод Say(), который объявлен как вирутальный в классе Animal, из-за этого для каждого животного вызовется либо его собственный метод Say(), либо Say() из класса Animal.
	1. Статический полиморфизм - способность изменять состояние объекта на этапе компиляции
	2. Динамический полиморфизм - способность изменять состояние объекта во время выполнения программы

### Отношение has-a
При таком отношении нужно задаваться вопросом A содержит  B? Ранее использованный пример с машиной, отдельные его компоненты - двигатель, колеса и т.д. имеют отношения к машине has-a, т.к. машина состоит из них

Есть 1 типа has-a отношения:
1. Агрегация - агрегированный объект(компонент) продолжает жить, когда агрегатор умирает, когда машина ломается, ее рабочие компоненты можно взять и поставить в другую машину.
2. Композиция - если объект, составленный из других компонентов уничтожается, то и его компоненты тоже уничтожаются. Допустим у нас есть класс Window и button, кнопка является частью окна, когда окно закрывается, то и кнопка уничтожается.

### Отношение not-a
Порой классы между собой не будут иметь отношений в коде, даже если в реальном мире они есть. Чтобы избежать лишних отношений, нужно заранее спроектировать программу и понять если ли смысл в отношениях.