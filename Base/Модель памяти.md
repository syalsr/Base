# Порядок инициализации нелокальных переменных
Все глобальные переменные и данные класса инициализируются перед началом работы функции main()

```cpp
class Demo
{
public:
	static int x;
};
int Demo::x { 3 };
int y { 4 };
```

C++ не предоставляет гарантий порядка инициализации переменных находящихся в разных файлах, это может стать проблемой, если одна глобальная/статическая переменная зависит от другой.

Уничтожаются они в обратном порядке их создания, но раз порядок инициализации UB, то и уничтожение - UB.

# Жизненный цикл объекта
1. Создание - объект создается при объявлении(стек) или  когда вы явно выделяете память для них(куча)
2. Уничтожение - объект уничтожается, при выходе из области видимости(стек), явном вызове delete(куча), вызывается деструктор, освобождается память.

# Стек
Локальные переменные хранятся на стеке. Стек – это область оперативной памяти, поэтому у его элементов тоже есть адрес. Его можно получить с помощью оператора &:

```cpp
int main () { 
	int x = 5; 
	int∗ y = &x; //y хранит адресс переменной x
	*y = 7; // x = 7
}
```

![[../Files/Pasted image 20220216122858.png]]

```cpp
int main () { 
	int a = 43; 
	int b = 71; 
	int c = 89; 
	cout << ∗(&b − 1) << ' ' << ∗(&b + 1);// 43 89
}
```

Если во время выполнения программы, вызывается очередная функция, то на стеке резервируется блок памяти, достаточный для хранения локальных переменных. Помимо этого он хранит адрес возврата. Такая область памяти называется стековым фреймом функции.

```cpp
void second () { 
	int s_a = 3; 
	double s_d = 2.0; 
} 
void first () { 
	int f_a = 2; 
	char f_c = 'a'; 
	second (); 
} 
int main () { 
	int a = 1; 
	char c = 'r'; 
	first (); 
	second (); 
	a = 2; 
	c = 'q'; 
}
```

![[../Files/Pasted image 20220216105531.png]] 

Когда функция `main` запускает функцию `first`, то на стеке ниже функции `main` резервируется фрейм для функции `first`. То же самое происходит, когда функция `first` вызывает функцию `second`.

Когда функция `second` завершает свою работу, то вершина стека перемещается на фрейм предыдущей функции. При этом фрейм отработавшей функции просто остаётся на стеке.

Если запустим функцию `second` из `main`, то стековый фрейм перетирает данные, которые были в стеке от предыдущих вызовов. Если мы сами не инициализируем переменные, то ей присвоятся значения, которые были тут от другого фрейма, поэтому важно сразу инициализировать значения, чтобы избегать непредвиденных ситуаций.

![[../Files/Pasted image 20220216105913.png]]

 ```cpp
void fill(istream& is , vector& ints) { 
	int x; 
	while (is >> x) { 
		ints. push_back (x); 
	} 
} 
int main () { 
	vector ints1 , ints2; 
	istringstream is1("1 2 3 4"); 
	fill(is1 , ints1); 
	istringstream is2("5 7"); 
	fill(is2 , ints2); 
} 
```

После завершения работы функции `fill` в куче будет выделен блок памяти, достаточный для хранения четырех целых чисел. При этом вектор `ints1` будет ссылаться на эту область памяти в куче и будет иметь доступ к своим элементам.

![[../Files/Pasted image 20220216110537.png]]

Когда `fill` отработает во второй раз, то в куче будет выделен отдельный блок памяти, достаточный для хранения двух целых чисел(если бы мы использовали стек, то данные бы просто перезаписались).

# arrays в pure C
Массив - это набор значений одного типа, расположенных в памяти последовательно, нумерация которого начинается с нуля, массив должен иметь размер на этапе компиляции, поэтому во время выполнения мы не сможем добавлять в него элементы, а лишь изменять существующие.

```cpp
const int m = 100;    
int qai[m] ; // Глобальный ма ссив (из 100 чисел типа int) ; "живет вечно "  void f (int n)    
{    
    char lac[20];  // локальный массив; "живет" до выхода из области видимости    
	lac[1] = 'x';    
   *lac = 'c';    // lac[0] = 'c';    
	int num[5] {2, 5}; //{2, 5, 0, 0, 0};    
	int num1[10] {}; //{0, 0, 0, ..., 0};    
	int num2[] {2, 4, 6}; //num2.size = 3(необязательно писать размер, если мы инициализируем массив, компилятор сам считает размер)    
	char plif[] {'h', 'i', 112421031, '\0'}; //ошибка - сужение     
	char ticTacToeBoard[3][3];    
    ticTacToeBoard[1][1] = 'o';    
}
```

Если мы хотим, чтобы количество элементов массива было переменным, то должны разместить его в динамической памяти и обращаться к нему через указатель.

```cpp
void doubleInts(int* theArray, size_t size)
{
	for (size_t i { 0 }; i < size; i++) { theArray[i] *= 2; }
}
// т.к. мы работаем с указателем на массив, то мы изменяем его, а не копию
size_t arrSize { 4 };
int* freeStoreArray { new int[arrSize]{ 1, 5, 3, 4 } };
doubleInts(freeStoreArray, arrSize);
delete [] freeStoreArray;
freeStoreArray = nullptr;

int stackArray[] { 5, 7, 9, 11 };
arrSize = std::size(stackArray); // Since C++17, requires <array>
//arrSize = sizeof(stackArray) / sizeof(stackArray[0]); // Pre-C++17
doubleInts(stackArray, arrSize);//имя массива является указателем на его первый элемент
doubleInts(&stackArray[0], arrSize);
```

```cpp
void doubleInts(int theArray[], size_t size)
{
	for (size_t i { 0 }; i < size; i++) { theArray[i] *= 2; }
}
//хоть здесь уже не указатель, но изменять мы будем оригинал
//передавая массив, все равно передается указатель - это сделано для эффективности
```

Число у массива в квадратных скобках в функциях игнорируется, следующие объявления идентичны:

```cpp
void doubleInts(int* theArray, size_t size);
void doubleInts(int theArray[], size_t size);
void doubleInts(int theArray[2], size_t size);
```

Можно также передавать ссылку на массив, но работает только с массивом на стеке

```cpp
void doubleIntsStack(int (&theArray)[4]);
template<size_t N>
void doubleIntsStack(int (&theArray)[N])//компилятор сам выведет размер массива
{
	for (size_t i { 0 }; i < N; i++) { theArray[i] *= 2; }
}
```

## cdecl - как читать выражения
Общее правило - влево, вправо, вверх, повторить
```cpp
int main() {
  int ai[20] = {0};//массив int'ов
  int *api[20] = {nullptr};//массив указателей
  int (*pai)[20] = &ai;//т.к. скобки нас ограничиывают, то это указатель на массив
  int (&rai)[20] = ai;

  std::cout << api << " + 1 = " << api + 1 << std::endl;//api - это указатель на первый элемент, +1 - перепрыгиваем на второй элемент
  std::cout << pai << " + 1 = " << pai + 1 << std::endl;//pai - это указатель на массив, соответсвенно прибавляя 1 мы перепрыгиваем через весь массив
  rai[2] = 40;
  (*pai)[2] += 2;
  
  std::cout << ai[2] << std::endl;
}
/*
0x7ffcf3b49700 + 1 = 0x7ffcf3b49708
0x7ffcf3b497a0 + 1 = 0x7ffcf3b497f0
42
*/
```

# string в pure C
Строка является массив символов, последний символ `\0` null terminate, означает конец строки, если мы выделяем память для строки, нужно не забыть выделить 1 символ для нулевого термината.

![[../Files/Pasted image 20220317181106.png]]

`myString` указывает на строковый литерал который находиться в raw data, неизменяемая область памяти, если создадим еще один указатель и передадим такой же строковый литерал, то он будет указывать на туже область памяти, сделано это для экономии памяти.
```cpp
int main()  
{  
    const char* str1 = "Hello world\0";  
    const char* str2 = "Hello word\0";  
    const char* str3 = "Hello world\0";  
}
```
![[../Files/Pasted image 20220429154557.png]]

Допустим, у нас есть функция которая работает со строками в стиле C(`const char*`) и делает все буквы заглавными, мы можем передать туда указать на любой элемент вот так:

```cpp
const char* str = "Hello, world\0";
toUppercase(str);//HELLO, WORLD
toUppercase(str+7);//Hello, WORLD
```

**Преимущества:**
1. Просты в создании
2. Легковесны

**Недостатки:**
1. Трудно найти ошибку, если мы ее  допустили.
2. Не поддерживают ООП парадигму, т.е. есть конечно функции для работы с ними, но это функции, гораздо удобнее иметь методы, чтобы знать что конкретно это относится к строке, используя ООП, можно определить любой оператор  для строк, к примеру.
3. Утечки памяти.

# Классификация символов
1. isspace() - пробел
2. isblank() - пустой символ
3. iscntrl()
4. isupper()
5. islower()
6. isalpha()
7. isdigit()
8. ispunct()
9. isxdigit()
10. isalnum()
11. isprint()
12. isgraph()

# void*
Тип void* означает "указатель на ячейку памяти, тип которой компилятору неизвестен". Он используется тогда, когда необходимо передать адрес из одной части программы в другую. причем каждая из них ничего не знает о типе объекта, с которым работает другая часть. Примерами являются адреса, служащие аргументами функций обратного вызова, а также распределители памяти самого нижнего уровня (оператора new).

Указателю типа void* можно присвоить указатель на любой объект, например:

```cpp
void* pvl = new int ; //int* превращается в void*
void* pv2 new douЬle [10]; //double* превращается в void*
```

Поскольку компилятор не знает что такое void*, мы должен ему сказать

```cpp
void f (void* pv)
{
	void* pv2 = pv ;
	double* pd = pv ; // Ошибка: невозможно привести тип void* к double *
	*pv = 7 ; // Ошибка: невозможно разыменовать void * (тип объекта , на который указывает pv, неизвестен)
	pv[2] = 9 ; // Ошибка : void* нельзя индексировать
	int* pi = static_cast<int*>(pv) ; // ОК: явное преобразование
	//...
}
```

# Введение в арифметику указателей
С помощью арифметики указателей можно обращаться к различным ячейкам нашей памяти. Если мы к указателю `T*` прибавим `N`, то перейдем на $N*sizeof(T)$ байт или $N$ ячеек вперед.

![[../Files/Pasted image 20220216120737.png]]

![[../Files/Pasted image 20220216122555.png]]

```cpp
T& operator[] (size_t index) { 
	return ∗( data + index); //data + index * sizeof(T)
	// либо
	return data[index];
}

int main () { 
	SimpleVector sv(5); 
	for (int i = 0; i < 5; ++i) { 
		sv[i] = 5 − i; 
	} 
	for (int i = 0; i < 5; ++i) { 
		cout << sv[i] << ' '; 
	} 
} 
// 5 4 3 2 1
```

## out_of_range
Также можем попытаться обратиться к элементу за границей массива.

```cpp
SimpleVector sv (5); 
cout << sv [12] << endl; 
// 7827296
```

Язык С++ не контролирует доступ к данным, которые мы осуществляем через указатель.

# Как обнаруживать утечки памяти в visual studio
```cpp
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>

#ifdef _DEBUG
#ifndef DBG_NEW
#define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
#define new DBG_NEW
#endif
#endif // _DEBUG

int main()
{
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	...
}
```

# Константный указатель и указатель на константу
указатель
![[../Files/Pasted image 20220216132440.png]]
указатель на константу
![[../Files/Pasted image 20220216132452.png]]
константный указатель
![[../Files/Pasted image 20220216132503.png]]
константный указатель на константу
![[../Files/Pasted image 20220216132512.png]]

Т.е. с помощью указателя на константу мы можем заново выделить память, но не изменить значения, а с помощью константного указателя мы можем мы можем изменить значение, но не пере выделить память, т.е. изменить адрес нельзя.

# Что такое динамическая память и откуда она берется в системе

# Чем динамическая память отличается от других типов памяти в модели С++

# Выделение и освобождение динамической памяти
## Операторы new && delete
Для того, чтобы выделить память в куче нужно использовать оператор `new` и указатель `T*`, указатель должен быть чем-то проинициализирован либо быть `nullptr`.

```cpp
int* pInt = new int;//pInt указатель на значение типа int
//pInt как адрес, будет храниться на стеке и указаывать на область памяти в куче.

int** handle { nullptr };
handle = new int*;//handle - адресс находящийся на стеке, который указывает на переменную
*handle = new int;//*handle находящуюся в куче которая указывает на переменную int тоже находящуюся в куче
```

Оператор `new` возвращает указатель на объект который он создал(если тип double, то new вернет указатель типа double*), если их несколько, как в примере выше, то на первый объект.

Мы не можем присваивать указатели разных типов друг другу, т.к. они имеют разные типы $=>$  они занимают разный объем памяти.

Указатель – это адрес в памяти. Память в С++ представляется как линейный массив байтов. Указатель – это индекс в этом массиве.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
cout << ∗s << ' ' << s−>size () << endl; 
// Hello 5
```

Оператор `*`, примененный к указателю, возвращает ссылку на объект в куче.

```cpp
string∗ s = new string; 
∗s = "Hello"; 
string& ref_to_s = ∗s; 
ref_to_s += ", world"; 
cout << ∗s << endl; 
// Hello, world
```


Если мы выделим память в куче, не удалим и указатель на эту область выйдет из области видимости, то произойдет утечка, мы никак не сможем удалить ее, т.к. доступа к ней нет, поэтому программа будет тратить лишнюю память. Если выделять память в куче в цикле `for` и не освобождать, то на какой-то итерации произойдет вылет из программы(в зависимости от объема вашей оперативной памяти).

```cpp
int* pInt = new int;
delete pInt;
pInt = nullptr; //рекомендуется занулять удаленный указать, чтобы случайно его не использовать, поскольку pInt еще указывает на область памяти в куче, обращение к ней UB, повторное удаление UB.

int** handle { new int* };
*handle = new int;
delete *handle;
delete handle;
handle = nullptr;
```

Перед delete не обязательно проверять объект на nullptr
## Операторы new[ ] && delete[ ]
Оператор new[] позволяет выделить блок памяти для хранения необходимого количества объектов.

```cpp
double *p;
p = new double[4];//выделяем память для 4 чисел типа double
int* myArrayPtr { new int[] { 1, 2, 3, 4, 5 } };

double** twoarr { new double*[4]};
for (size_t i { 0 }; i < 4; i++) { twoarr[i] = new double; } //allocate
for (size_t i { 0 }; i < 4; i++) {//deallocate
	delete twoarr[i];
	twoarr[i] = nullptr;
}
delete [] twoarr;
twoarr = nullptr;
```

![](cpp_basic16.png)

Доступ к элементам массива мы можем получить с помощью оператора индексирования.

```cpp
double *pd = new double[3];
double x = *pd; //присваиваем x первое значение массива
pd[2] = 2.2;
pd[4] = 4.4;
pd[-3] = -3.3;
delete pd;
pd = nullptr;
```
Т.к. указатель не знает на какой диапазон элементов он указывает, то мы можем выходить за его рамки и компилятор не посчитает это за ошибку. Мы просто изменить значения другого объекта, о котором мы ничего не знаем.

![](cpp_basic18.png)

pd - динамически выделяемый массив, не динамический массив, мы можем указать размер во время выполнения программы, но не можем расширять его

## new и delete для объектов классового типа
При выделении памяти в куче для объекта классового типа вызывается конструктор, при удалении с помощью `delete` вызывается деструктор.

## Разница между new/delete и malloc/free
1. new в отличии от malloc, вызывает констурктор у объекта
```cpp
Foo* myFoo { (Foo*)malloc(sizeof(Foo)) };//выделилась память нужного размера
Foo* myOtherFoo { new Foo{} };//выделилась память и создался объект
```
1. При вызове `free()` у класса не вызовется деструктор в  отличии от `delete`
2. new - оператор который можно переопределить

## Исключения и new
new может выбросить исключение, если ей не удается выделить нужное количество памяти из-за нехватки ресурсов
```cpp
int* ptr { new(nothrow) int };//вместо исключения возратит nullptr, но рекомендуется использовать стандартный new
```

## Многомерные массивы
Многомерные массивы можно представить как матрицу и в памяти элементы располагаются так

![[../Files/Pasted image 20220422174530.png]]

```cpp
char board[12][12]{};
```

### jagged array
Помимо этого многомерный массив можно создать с помощью массива указателей

![[../Files/Pasted image 20220422175150.png]]

И вычисляет адреса по разному

```cpp
void foo(int (*pcont)[10]){ 
	pcont[1][2] = 1; //*(&cont[0][0] + 1 * 10 + 2) = 1
}
int cont[5][10]; 
foo(cont); 
cont[1][2] = 1;//*(&cont[0][0] + 1 * 10 + 2) = 1
//-----------------------------------------
void bar(int **pjag) { 
	pjag[1][2] = 1; //*(*(jagged + 1) + 2) = 3
}
int *jagged[10]; 
bar(jagged); 
jagged[1][2] = 1;//*(*(jagged + 1) + 2) = 3
```

Мы всегда можем опускать только самый вложенный индекс: и в инициализаторах и в параметрах функций

```cpp
float flt[2][3] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // ok 
float flt[][3] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // ok 
float flt[][] = {{1.0, 2.0, 3.0}, {4.0, 5.0}}; // fail
float func(float flt[][3][6]); // ok, float *flt[3][6]
```

### Куча

```cpp
char** board { new char*[xPos] };
for (size_t i { 0 }; i < xPos; i++) {
	board[i] = new char[yPos]; // Allocate ith subarray
}
...
for (size_t i { 0 }; i < xPos; i++) {
	delete [] board[i]; // Delete its subarray
	board[i] = nullptr;
}
delete [] board; // Delete first dimension
board = nullptr;
```

Но это не совсем эффективно, лучше выделить сразу нужный блок памяти $=xPos * yPos * sizeof(char)$ и обращаться к элементам как $x * yPos + y$, поскольку программа будет работать быстрее если ее данные расположены последовательно.

# Allocator
## Linear allocator
Самый простой вид аллокаторов, идея состоит в том, чтобы сохранить указатель на начало блока памяти, а также смещение. В этом аллокаторе фрагментация сведена к минимуму, так как блоки выделяются последовательно.

Пример:
1. Доступно 14 байт, сначала выделяем 4 байта
2. Потом 8 байт
3. Остается 2 байта
4. Если нужно выделить 1 байт без выравнивания, то выделяем
5. Либо же выделяем 1 байт и еще 1 байт забираем для выравнивания - это обеспечивается минимальную фрагментацию
![[../Excalidraw/linearalloc.gif]]

Ну и во вторых, для избегания фрагментации, аллокатор не поддерживает выборочное освобождение блоков. Имея указатель на начало, мы не сможем освободить 4 байта, но можем освободить всю выделенную память целиком.

![[../Excalidraw/lineardealloc.gif]]

## Pool allocator
Идея блочного аллокатора заключается в том, что он разделяет большой участок памяти на более мелкие одинакового размера. Когда поступает запрос на выделение, но возвращает он из блоков, когда блок освобождается, он возвращается в pool свободных блоков. Таким образом, распределение работает очень быстро, а фрагментация все еще очень мала.

Пример:
1. Выделяем 2 байта
2. Выделяем 4 байта
3. Освобождаем 2 байта
4. Может возникнуть ситуации, чтобы мы попытаемся освободить не наш кусок памяти, тогда в пуле будет чужой адрес, а это UB, для этого нужно хранить позиции `start, end`
5. Либо может возникнуть ситуация, когда мы освобождаем блок, но адрес не равен началу блока. В таком случае нужно хранить адреса каждого блока
![[../Excalidraw/poolalloc.gif]]

## Stack allocator
Модернизированная версия линейного аллокатора которая позволяет управлять памятью, как стеком. Сохраняем указатель на начало блока и смещение, а также можем освободить последний выделенный кусок. Помимо этого, во время выделения сохраняем заголовок - количество  выделенной памяти, пользователю будет отдан указатель на адрес идущий после заголовка. Для удаления куска памяти, сначала отступаем от начала, чтобы узнать размер памяти, после освобождаем размер+header

![[../Excalidraw/stackalloc.gif]]

#do/important_start 
4. реализация malloc https://danluu.com/malloc-tutorial/

# Фрагментация памяти, требования к выравниванию, минимальный кусок выделяемой памяти
#do/start найти инфу

# Переопределение new/ delete и placement new
## Перегрузка new && delete
Что делает new?
1. Выделяет память
2. Вызывает конструктор объекта
3. Возвращает указатель
```cpp
void* operator new(size_t size);
void* operator new[](size_t size);
void* operator new(size_t size, const std::nothrow_t&) noexcept;
void* operator new[](size_t size, const std::nothrow_t&) noexcept;
```

Что делает delete?
1. Вызывает деструктор для объекта
2. Очищает память
```cpp
void operator delete(void* ptr) noexcept;
void operator delete[](void* ptr) noexcept;
void operator delete(void* ptr, const std::nothrow_t&) noexcept;
void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
void operator delete(void* ptr, void*) noexcept;
void operator delete[](void* ptr, void*) noexcept;
```

Перегрузки nothrow и placement delete используется в том случае, если конструктор выбрасывает исключение. В таком случае выбираем тот delete который соответствует new. Если мы удаляем объект как обычно `delete delete[]`, то вызовется обычная перегрузка(не nothrow и placement).

Стоит переопределять new и delete только для специфичных классов, при создании объекта этого класса будут вызываться переопределенные операторы. Если мы переопределяем new, то должны переопределить соответствующую форму оператора delete, иначе вызовется встроенный delete, который может неправильно очистить память.

Пример переопределения:

```cpp
class MemoryDemo
{
public:
	virtual ~MemoryDemo() = default;
	void* operator new(size_t size);
	void operator delete(void* ptr) noexcept;
	void* operator new[](size_t size);
	void operator delete[](void* ptr) noexcept;
	void* operator new(size_t size, const std::nothrow_t&) noexcept;
	void operator delete(void* ptr, const std::nothrow_t&) noexcept;
	void* operator new[](size_t size, const std::nothrow_t&) noexcept;
	void operator delete[](void* ptr, const std::nothrow_t&) noexcept;
};

void* MemoryDemo::operator new(size_t size)
{
	cout << "operator new" << endl;
	return ::operator new(size);
}
void MemoryDemo::operator delete(void* ptr) noexcept
{
	cout << "operator delete" << endl;
	::operator delete(ptr);
}
void* MemoryDemo::operator new[](size_t size)
{
	cout << "operator new[]" << endl;
	return ::operator new[](size);
}
void MemoryDemo::operator delete[](void* ptr) noexcept
{
	cout << "operator delete[]" << endl;
	::operator delete[](ptr);
}
void* MemoryDemo::operator new(size_t size, const nothrow_t&) noexcept
{
	cout << "operator new nothrow" << endl;
	return ::operator new(size, nothrow);
}
void MemoryDemo::operator delete(void* ptr, const nothrow_t&) noexcept
{
	cout << "operator delete nothrow" << endl;
	::operator delete(ptr, nothrow);
}
void* MemoryDemo::operator new[](size_t size, const nothrow_t&) noexcept
{
	cout << "operator new[] nothrow" << endl;
	return ::operator new[](size, nothrow);
}
void MemoryDemo::operator delete[](void* ptr, const nothrow_t&) noexcept
{
	cout << "operator delete[] nothrow" << endl;
	::operator delete[](ptr, nothrow);
}

int main()
{
	MemoryDemo* mem{ new MemoryDemo{} };
	delete mem;
	mem = new MemoryDemo[10];
	delete[] mem;
	mem = new (nothrow) MemoryDemo{};
	delete mem;
	mem = new (nothrow) MemoryDemo[10];
	delete[] mem;
}
/*
	operator new
	operator delete
	operator new[]
	operator delete[]
	operator new nothrow
	operator delete
	operator new[] nothrow
	operator delete[]
*/
```

Мы можем явно сделать delete/default операторы new и delete

```cpp
class MyClass
{
public:
	void* operator new(size_t size) = delete;
	void* operator new[](size_t size) = delete;
};

int main()
{
	MyClass* p1 { new MyClass };//error
	MyClass* p2 { new MyClass[2] };//error
	//явно удалили операторы, теперь мы не сможем динамически создавать этот класс
}
```

Мы можем переопределить глобальный оператор

```cpp
void *operator new(std::size_t n) {  
    void *p = malloc(n);  
    if (!p)  
        throw std::bad_alloc{};  
    printf("Alloc: %p, size is %zu\n", p, n);  
    return p;  
}  
  
void operator delete(void *mem) noexcept {  
    printf("Free: %p\n", mem);  
    free(mem);  
}  
  
struct Widget {  
    static void *operator new(std::size_t n);  
    static void operator delete(void *mem) noexcept;  
    int n[4];  
};  
  
void *Widget::operator new(std::size_t n) {  
    void *p = malloc(n);  
    if (!p)  
        throw std::bad_alloc{};  
    printf("Custom alloc: %p, size is %zu\n", p, n);  
    return p;  
}  
  
void Widget::operator delete(void *mem) noexcept {  
    printf("Custom free: %p\n", mem);  
    free(mem);  
}  
  
int main() {  
    std::list<int> l;  
    l.push_back(42);  
    Widget *w = new Widget;  
    delete w;  
    //Alloc: 0x55b1f9183eb0, size is 24  
    //Custom alloc: 0x55b1f91842e0, size is 16    
    //Custom free: 0x55b1f91842e0    
    //Free: 0x55b1f9183eb0
}
```

При использовании new[] стандарт гарантирует, если вызовется исключение на n объекте, то все ранее созданные удалятся.

## Перегрузка операторов new и delete с extra параметрами
Мы можем определить оператор new/delete для класса и они могут иметь сколько угодно аргументов, т.е. в классе может быть сколько угодно перегрузок.

```cpp
class MemoryDemo
{
public:
	void* operator new(size_t size, int extra)
	{
		cout << "operator new with extra int: " << extra << endl;
		return ::operator new(size);
	}
	void operator delete(void* ptr, int extra) noexcept
	{
		cout << "operator delete with extra int: " << extra << endl;
		return ::operator delete(ptr);
	}
};

int main()
{
	MemoryDemo* memp { new(5) MemoryDemo{} };
	delete memp;//вызовется обычный delete
}
/*
	operator new with extra int: 5
	operator delete
*/
```

Если в вашем классе объявлены две версии delete - одна с параметром size, другая нет, то всегда будет вызываться версия без параметра. Чтобы этого избежать нужно объявить только версию с параметром
```cpp
void MemoryDemo::operator delete(void* ptr, size_t size) noexcept
{
	cout << "operator delete with size " << size << endl;
	::operator delete(ptr);//не существует глоабльного delete который принимал бы размер
}
```

## operator placement new
Это функции которая на уже выделенной памяти вызывает конструктор объекта, чтобы занять ее, C++ запрещает перегружать их

```cpp
void* operator new(std::size_t size, void* ptr) noexcept; 
void* operator new[](std::size_t size, void* ptr) noexcept;

void *raw = ::operator new(sizeof(Widget), std::nothrow); 
if (!raw) { обработка } 
Widget *w = new (raw) Widget;//раз вызываем рука конструктор, то
//...
w->~Widget();//должны сами вызвать деструктор
::operator delete(raw);

int* n = new int(5);//выделяеям память и конструируем объект
n = (int *) ::operator new(sizeof(int));//используем глобальный оператор, происходит только выделение, отличается от malloc тем что может бросить исключение
```

# Многопоточность и аллокация памяти
#do/important_start 

# Работа с указателями
Мы можем изменить адрес указателя так:

```cpp
char* scaryPointer { (char*)7 };
// указатель имеет адрес 0x0000000000000007, т.е. мы можем вот так вот указывать на чужие данные, что не есть хорошо это UB
```

## C style Касты указателей
```cpp
Document* documentPtr { getDocument() };
char* myCharPtr { (char*)documentPtr };
```

Указатели слабо типизированы, используя c style касты мы можем легко привести их к любому типу, в C++ есть [[casting#static_cast|static_cast]] которые являются более безопасными

# type punning
https://stackoverflow.com/questions/44137442/what-is-type-punning-and-what-is-the-purpose-of-it

#do/start найти еще где-то инфу по этому вопросу