# Массивы
```go
var a [3]int //длина массива и тип его элементов определяют его тип, то есть var a [5]int имеет другой тип в отличии от var a [3]int
fmt.Println(a) // [0 0 0]

var a [3]int = [3]int{1, 2, 3} 
b := [3]int{1, 2, 3} 
c := [...]int{3, 2, 3} //[...] длина массива определяется в зависимости от количества элементов, но такой вариант не рекомендуется для использования
d := [3]int{1: 12} 

fmt.Println(a) // [1 2 3] 
fmt.Println(b) // [1 2 3] 
fmt.Println(c) // [1 2 3] 
fmt.Println(d) // [0 12 0]

fmt.Println(a == b) // true 
fmt.Println(a == c) // false
//Можем сравнивать массивы одинакового типа, т.е. одинаковый тип элементов и размер

var numbers [5]int = [5]int{1, 2, 3, 4, 5}  
  
fmt.Println(numbers[0]) // 1  
fmt.Println(numbers[4]) // 5  
numbers[0] = 87  
fmt.Println(numbers[0]) // 87

a := [5]int{1, 2, 3, 4, 5}  
fmt.Println(a) // [1 2 3 4 5]  
  
for i := 0; i < len(a); i++ {  
   fmt.Println(a[i])  
   // 1  
   // 2   
   // 3   
   // 4   
   // 5
}

for idx, elem := range a {  //elem является копией, если хотим изменить, нужно обращаться по иденксу
   fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)  
   // Элемент с индексом 0: 1  
   // Элемент с индексом 1: 2   
   // Элемент с индексом 2: 3   
   // Элемент с индексом 3: 4   
   // Элемент с индексом 4: 5
}

for idx, _ := range a {  
   // В этом случае следует использовать приведенный выше вариант,  
   // хотя технически эти варианты работают одинаково   
   fmt.Println(a[idx])  
}  
  
for _, elem := range a {  
   fmt.Println(elem)  
}

```

## Передача массива в функцию
```go
func test(i *[3]int) {  //передаем указатель для того, чтобы изменяли оригинал
   i[0] = 2  
   fmt.Println(i)  
}  
  
func main() {  
   ma := [3]int{1, 2, 3}  
   fmt.Println(ma)  
   test(&ma)  
   fmt.Println(ma)  
   [1 2 3]  
   &[2 2 3]  
   [2 2 3]  
}
```

# Срезы (слайсы, slices)
Срез — это последовательность элементов одного типа переменной длины, по другому - динамический массив. Срез состоит из трех компонентов: указателя, длины и емкости:
-   указатель указывает на первый элемент массива, доступный через срез (который не обязательно совпадает с первым элементом массива);
-   длина (length) — это количество элементов среза;
-   емкость (capacity) - количество элементов между началом среза и концом базового массива.

```go
var a []int  
var b []int = []int{1, 2, 3}  
c := []int{1, 2, 3}  
d := []int{1: 12}  
  
fmt.Println(a) // []  
fmt.Println(b) // [1 2 3]  
fmt.Println(c) // [1 2 3]  
fmt.Println(d) // [0 12]

a := make([]int, 10, 10) // [0 0 0 0 0 0 0 0 0 0] 
fmt.Println(a)
a := make([]int, 10) // [0 0 0 0 0 0 0 0 0 0] 
a := make([]int, 0, 10) // []

```

Многоточия могут использоваться для разворачивания (раскрытие) среза путем указания _справа_ от среза знака многоточия.

```go
func ExampleExpandSlice1() {
	s := []interface{}{1, 2, 3, 4, 5}

	fmt.Println(s)
	fmt.Println(s...)

	// Output:
	// [1 2 3 4 5]
	// 1 2 3 4 5
}
```

### append()
Функция append позволяет добавить в срез новый элемент, возвращая обновленный слайс

```go
func append(slice []Type, elems ...Type) []Type
a := []int{1, 2, 3} 
a = append(a, 4, 5) 
fmt.Println(a) // [1 2 3 4 5]
```


```go
func main() {  
   s1 := []int{1, 2, 3, 4, 5}  
   s2 := []int{6, 7, 8, 9, 10}  
   // append(slice []Type, elems ...Type) []Type  
   // s1 = append(s1, s2) не сработает, т.к. второй и   // последующие аргументы в нашем случае должны быть int   s3 := append(s1, s2...)  
   fmt.Println(s1)[1 2 3 4 5]  
   fmt.Println(s2)[6 7 8 9 10]  
   fmt.Println(s3)[1 2 3 4 5 6 7 8 9 10]  
}
```

С помощью этой функции можем также удалить элементы среза:

```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...) //... - означает, что элементы среза передаются как отдельные аргументы
fmt.Println(a) // [1 2 4 5 6 7]
```

### copy()
```go
func copy(dst, src []Type) int
```

Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:
```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)//если бы указали ([]int, 1, 3) то скопировался бы один элемент
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```

## Передача слайса в функцию
```go
func test(i *[]int) {  
   (*i)[0] = 2  
   fmt.Println(i)  
}  
func test(i []int) {  
   i[0] = 2  
   fmt.Println(i)  
}  
  
func main() {  
   ma := []int{1, 2, 3}  
   fmt.Println(ma)  
   test(&ma)  
   fmt.Println(ma)  
  
}
```

Передавая указатель на слайс, либо явно слайс(который видимо принимает все равно указатель) значение меняется