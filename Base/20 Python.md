# 20 Python

# Интерполяция
Иной способ конкатенация строк
```python
first_name = 'Joffrey'
greeting = 'Hello'
print(greeting + ", " + first_name + "!")
# => Hello, Joffrey!

print(f'{greeting}, {first_name}!')
# => Hello, Joffrey!

school = 'Hexlet'

what_is_it = f'{school} - online courses'
print(what_is_it)  # => Hexlet - online courses
```

Буква `f` указывает на то, что мы создаём f-строку. f-строка - это шаблон, в который с помощью фигурных скобок подставляются значения переменных.

# Multi-line strings
```python
text = 'Пример текста,\nсостоящего из\nнескольких строк'
text = '''Пример текста,
состоящего из
нескольких строк'''
```

```python
a = 'A'
b = 'B'

# Слева добавился f
text = f'''{a} и {b}
сидели на трубе
'''
```

# Индексация строк
```python
first_name = 'Alexander'

print(first_name[-1])  # => r
```

Отрицательные индексы начинаются с конца

```python
value = '12-08-2034'

year = value[6:10]
print(year)  # => 2034

value = 'Hexlet'
value[3:]  # 'let'
value[:3]  # 'Hex'

value = 'Hexlet'
# Правая граница отрицательная. Считаем -1 от конца строки
value[3:-1]  # 'le'
# Левая граница отрицательная. Считаем -5 от конца строки
value[-5:3]  # 'ex'

value = 'Hexlet'
value[1:5:2]  # el 2 - шаг
# 1:5 это 'exle'
# шаг 2 это каждый второй, то есть 'e' и 'l'

value = 'Hexlet'
value[:5:2]  # 'Hxe'
value[1::2]  # 'elt'

Можно также использовать отрицательный шаг для переворота строки
value = 'Hexlet'  
# Пропускаем обе границы  
print(value[::-1])  # 'telxeH'

value = 'Hexlet'  
# Символ с индексом 1 не будет включён в подстроку  
value[4:1:-1]  # 'elx'

value = 'Hexlet'
start = 1
end = 5
value[start:end]  # 'exle'
```
При помощи индексов мы не можем менять отдельные символы, нужны менять всю строку

# Функции
```python
# Определение функции
# Определение не вызывает и не выполняет функцию
# Мы лишь говорим, что теперь такая функция существует
def show_greeting():
  # Внутри тела отступ 4 пробела
  text = 'Hello, Hexlet!'
  return text

# Вызов функции
print(show_greeting())  # => 'Hello, Hexlet!'
```

```
pow(x, y[, z])
```
x,y - обязательные параметры, z - необязательный

```
max(arg1, arg2, *args[, key])
```
Функция max принимает 2 параметра и больше

# Аргументы
Существует два типа **аргументов** — то есть данных, которые передаются в вызов функции.

Первый тип — **позиционные аргументы**. Они передаются в том же порядке, в котором определены параметры функции:
```python
# (text, length)
truncate('My Text', 3)
```
Второй тип — **именованные аргументы**. Они передаются не просто как значения, а как пара «имя=значение». Именно поэтому их можно передавать в любом порядке:

```python
# Аргументы переданы в другом порядке
truncate(length=3, text='My Text')
```

Именованные аргументы полезны, если у нас много аргументов по умолчанию, но нужно передать один.

# Логические выражения
Оператор **ИЛИ** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в `True`, если такого аргумента нет, возвращается последний (правый).

Пример:

```python
print(0 and 1) # 0
```

Оператор **И** работает так, что его выполнение (слева направо) прерывается и возвращается результат первого аргумента, который можно преобразовать в `False`, если такого аргумента нет, возвращается последний (правый).

```python
value = name or ''
# Примеры
234 or '' # 234
'hexlet' or '' # 'hexlet'
None or '' # ''
```

# Кортеж

**Кортеж** — это несколько значений, записанных через запятую. Вот несколько примеров:

```
rgb_colour = (255, 127, 64)
name_and_age = ('Bob', 42)
three_booleans = (True, False, True)
two_pairs_of_numbers = ((1, 2), (3, 4))
```

При этом кортеж может состоять из всего одного элемента:

```
tuple = (42,)  # Ставим запятую, чтобы указать на кортеж
```

Обратите внимание на запятую — ее нужно ставить даже после единственного элемента кортежа.

А теперь посмотрим на пример без запятой. В этом случае Python подумает, что мы хотим посчитать арифметическое выражение со скобками:

```
not_a_tuple = (42)  # Запятой нет, поэтому Python не считает это кортежем
```

## Как изменить кортеж

Одна из особенностей кортежей в том, что это **неизменяемый тип данных** — то есть изменить кортеж после создания уже нельзя. Чтобы добавить новое значение, нужно создать новый кортеж.

При попытке изменить кортеж мы получим такую ошибку:

```
name_and_age = ('Bob', 42)
name_and_age[0] = 'Alice'
# Traceback (most recent call last)
# TypeError: 'tuple' object does not support item assignment
name_and_age # ('Bob', 42)
```

## Как работать с кортежами

Кортежи полезны, когда нужно вернуть сразу несколько значений. Возьмем для примера функцию, которая возвращает два значения одновременно: результат деления нацело и остаток от деления.

В коде это выглядит так:

```
def div_mod(a, b):
    quotient = a // b
    modulo = a % b
    return (quotient, modulo)

div_mod(13, 4)  # (3, 1)
```

### Как извлекать значения из кортежа

Выше мы научились создавать кортежи, а теперь попробуем извлекать значения из них. Для этого достаточно обратиться к элементу кортежа по индексу:

```
name_and_age = ('Bob', 42)

name_and_age[0]  # 'Bob'
name_and_age[1]  # 42
```

Также у кортежа есть длина, которую можно получить с помощью функции `len()`:

```
tuple = (42,)  # (42,)
len(tuple)     # 1
pair = (1, 2)  # (1, 2)
len(pair)      # 2
```

### Как разделить значения из кортежа

Часто кортежи содержат значения разных типов. Сложно запомнить, каким индексом обозначается каждое значение.

Чтобы упростить работу, можно разобрать кортеж:

```
name_and_age = ('Bob', 42)

(name, age) = name_and_age
name  # 'Bob'
age   # 42
```

Также этот процесс может называться деструктуризацией или распаковкой.

Таким же способом можно получать и сразу разбирать значения, которые возвращает функция:

```
(quotient, modulo) = div_mod(13, 4)
```

Соответственно, кортеж из одного элемента разбирается так:

```
(a,) = (42,)
a  # 42
```

Если после имени переменной не поставить запятую, то синтаксической ошибки не будет, но в переменную `a` кортеж запишется целиком — ничего не распакуется. Это логическая ошибка — мы получим не тот результат, который ожидали.

## Кортежи и множественное присваивание

Кортежи легко собирать и разбирать, поэтому в Python удобно делать множественное присваивание. Смотрите:

```
(a, b, c) = (1, 2, 3)
a  # 1
b  # 2
c  # 3
```

Используя множественное присваивание, можно обменять значения между двумя переменными. Так это выглядит:

```
a = 100
b = 'foo'

(a, b) = (b, a)
a  # 'foo'
b  # 100
```




# Полезное
* Что внутри у питона: как работает интерпретатор. https://youtu.be/at30AmjPsy4
* Что внутри у питона: откуда быть пошел async. https://youtu.be/GX7AUAwpQ4I
* Что внутри у питона: как устроена память. https://youtu.be/lSgoYx06L_s
* Канал по питону - https://www.youtube.com/user/zaemiel/videos
* Introduction to scripting in python - https://www.coursera.org/specializations/introduction-scripting-in-python
* Junior Python Developer: полный разбор собеседования и ответы на наиболее частые вопросы интервью - https://www.youtube.com/watch?v=fgXCN7A8yzg
* Чат на питоне https://medium.com/swlh/lets-write-a-chat-app-in-python-f6783a9ac170