# Реализация функций
```cpp
douЬle expression ( Token_stream& ts)
{
	double left = term (ts);
	Token t = ts.get();
	// ...
}
double term(Token_stream& ts)
{
	double left = primary(ts);
	Token t = ts.get();
	// . . .
		case '/':
		{
			double d = primary(ts);
		// . . .
		}
	// . . .
}
double primary(Token_stream& ts)
{
	Token t = ts.get();
	switch (t.kind) {
	case '(':
		{ 
			double d = expression(ts);
			// . . .
		}
		// . . .
	}
}
```

При вызове этих функций реализация языка программирования создает структуру данных содержащую копии всех ее параметров и локальных переменных.

![Вызов функции expression()](cpp_basic3.png)

Такую структуру данных называют зап11сью активац11и Финкции(functton acttvation record) или просто записью активации. Каждая функция имеет собственную запись активации .

Теперь функция `expression()` вызывает функцию `term()`, так что компилятор создает запись активации для вызова функции `term()`.

![Вызов функции expression() и term()](cpp_basic4.png)

Функция `term()` имеет дополнительную переменную `d`, которую необходимо хранить в памяти. поэтому при вызове мы резервируем для нее место, даже если в коде она нигде не используется. Для разумных функций затраты на создание записей активации не зависят от их размера. Локальная переменная d будет инициализирована только в том случае , если будет выполнен раздел `case '/'`. Теперь функция `term()` вызывает функцию `primary()`

![](cpp_basic5.png)

Теперь функция `primary()` вызывает функцию `expression()`.

![](cpp_basic6.png)

Этот вызов функции `expression()` также имеет собственную запись активации, отличающуюся от записи активации первого вызова функции `expression()`. Хорошо это или плохо, но теперь мы попадаем в очень запутанную ситуацию, поскольку переменные left и t при двух разных вызовах будут разными. Функция, которая прямо или (как в данном случае) косвенно вызывает себя, называется рекурс11вной (recursive). Как можно видеть, рекурсивные функции являются естественным следствием метода реализации, который мы используем для вызовов функций и возврата из них (и наоборот) .

Итак, каждый раз, когда мы вызываем функцию, стек зшшсей активации(stack of actlvatlon records), который часто называют просто стеком(stack), увеличивается на одну запись. И наоборот, когда функция возвращает управление, ее запись активации больше не используется. Например, когда при последнем вызове функции `expression()` управление возвращается функции `primary()`, стек возвращается в предыдущее состояние.

![](cpp_basic7.png)

Когда функция `primary()` возвращает управление функции `term()`, стек возвращается в состояние, показанное ниже.

![](cpp_basic8.png)

И так далее. Этот стек. который часто называют стеком вызовов(call stack), - структура данных, которая увеличивается и уменьшается с одного конца в соответствии с правилом "последним вошел - первым вышел".