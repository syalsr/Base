Итераторы - это способ задать позицию в контейнере, у контейнеров есть начало `begin` указывающий на 1 элемент, есть конец `end` указывающий на элемент за последним элементом, т.е. на память которая нам уже не принадлежит, если мы попытаемся как-то обратиться к ней, то получим ошибку, так же если и обратимся к элементу за первым.

```cpp
vecotr<int> num = {1,2,3,4,1,2,3,5};
auto result = find_if(begin(num), end(num), [](const int n)
					  {
							return n = 3;
					  });
cout << *result; //3, result - итератор указывающий на 3 элемент
int& refres = *result;
refres = 5;
cout << *result; //5
++result;
cout << *result; //4
```

Если бы функция `find_if`` не нашла элемент удовлетворяющий лямбде, то result указывал бы на `end`. По контейнеру можно итерироваться с помощью итератора

```cpp
vector<int> v = {1,2,3,45,3,12,3};
for(auto it = v.begin(); it != end(); ++it)
	cout << *it;
map<string, int> langs =
						{{"Python", 26}, 
						{"C++", 34}, 
						{"C", 45}, 
						{"Java", 22}, 
						{"C#", 17}};
for(auto it = langs.begin(); it != langs.end(); ++it)
	cout << it->first << "/" << it->second << " ";
```

```cpp
template<typename It>
void PrintRange(It range_begin, It range_end)
{
	for(auto it = range_begin; it != range_end; ++it)
		cout << *it;
}

vecotr<int> v = {1,2,4,5,3,1,2,3};
auto result = find_if(v.begin(), v.end(), [](const int n){
						return n = 5;
						});
PrintRange(v.begin, result);//124
```

В общем, с помощью итераторов можно не только выводить элементы, но и вставлять элементы, диапазон итераторов, находить, удалять.

Отличие итераторов от ссылок:
1. Итераторы могут указывать «в никуда»
2. Итераторы можно перемещать на другие элементы