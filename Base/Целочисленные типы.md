## Целочисленные типы
Допустим нам нужно посчитать среднее арифметическое значение, у нас есть такой код

```cpp
vector<int> v = {2, 3, -5, -10};
... здесь код который суммирует элементы
int avg = sum / v.size();
```

Результат будет неожиданным из-за того, что `v.size()` имеет тип `size_t`, который не умеет хранить отрицательные числа, из-за этого переменная sum типа `int` переводится к типу `size_t`, а поскольку sum сейчас хранит отрицательное число, получается такой ответ.

**Виды целочисленных типов**

| Тип          | Размер     | Минимум     | Максимум                          | Стоит ли выбрать его?   | 
| ------------ | ---------- | ----------- | --------------------------------- | ----------------------- |
| int          | 4 (обычно) | $$−2^{31}$$ | $$2^{31} − 1$$                    | по умолчанию            |
| unsigned int | 4 (обычно) | $$0$$       | $$2^{31} − 1$$                    | только положительные    |
| size_t       | 4 или 8    | $$0$$       | $$2^{31} − 1$$ или $$2^{64} − 1$$ | размер контейнеров      |
| int8_t       | 1          | $$−2^{7}$$  | $$2^{7} − 1$$                     | сильно экономить память |
| int16_t      | 2          | $$−2^{15}$$ | $$2^{15} − 1$$                    | экономить память        |
| int32_t      | 4          | $$−2^{31}$$ | $$2^{31} − 1$$                    | нужно ровно 32 бита     |
| int64_t      | 8          | $$−2^{63}$$ | $$2^{63} − 1$$                    | недостаточно int        |

**Как узнать размеры и ограничения типов**
```cpp
//Размеры:
cout << sizeof(int16_t) << " "; // размер типа в байтах. Вызывается от переменной 
cout << sizeof(int) << endl; 
// 2 4

//Ограничения:
cout << sizeof(int16_t) << " "; 
cout << numeric_limits<int>::min() <<" "<<numeric_limits<int>max() << endl;
// 4 -2147483648 2147483647
```

### Преобразования целочисленных типов
```cpp
int main () { 
	int x = 2'000'000'000'; // для читаемости разбиваем на разряды кавычками 
	cout << x << " "; // выводим само число 
	x = x ∗ 2; cout << x << " "; // выводим число, умноженное на 2 
	return 0; 
} 
// 2000000000 -294967296
```

Либо такой случай, здесь произошло переполнение, т.к. максимальное значение `int`  $= 2^{32}-1 < 4'0000'000'000$

По простому, представим значения типа int в виде числового отрезка от $-2^{32} - 2^{32}-1$. Когда наша переменная равна максимальному значению и мы прибавляем $1$, то раз мы достигли максимума, мы возвращаемся в начало отрезка, к самому минимальному значению. Почему так? Потому что компьютер работает только с положительными. У него внутри это представлено как отрезок положительных чисел 0 до $-2^{32}$ и отрезок отрицательных чисел(для него положительных) $2^{32}+1$ до $4^{32}$. Соответственно прибавляя к максимальному положительному число единицу, у нас получается наибольшее отрицательное число.

Если рассматривать числа в двоичном формате, то первый его бит отвечает за положительность числа. Если наш диапазон чисел от -128 - 127:

```
11111111 = -1
01111111 = 127
```

```cpp
int x = 2'000'000000; 
int y = 1'000'000000; 
cout << (x + y) / 2 << endl; // -647483648
```

Поскольку сначала мы складываем числа, а потом делим, случилось переполнение.

```cpp
int x = 2'000'000000; unsigned int y = x; // сохраняем в переменную беззнакового типа 2000000000 
unsigned int z = −z; 
cout << x << " " << y << " " << −x << " " << z << endl; // 2000000000 2000000000 -2000000000 2294967296
```

**Правила приведения к общему типу**

1. Перед сравнениями и арифметическими операциями числа приводятся к общему типу 
2. Все типы размера меньше `int` приводятся к `int`
3. Из двух типов выбирается больший по размеру
4. Если размер одинаковый, выбирается беззнаковый.

| Слева   | Операция | Справа   | Общий тип     | Комментарий                  |
| ------- | -------- | -------- | ------------- | ---------------------------- |
| int     | $$/$$    | size_t   | size_t        | больший размер               |
| int32_t | $$+$$    | int8_t   | int32_t (int) | тоже больший размер          |
| int8_t  | $$∗$$    | uint8_t  | int           | все меньшие приводятся к int |
| int32_t | $$ <$$   | uint32_t | uint32_t      | знаковый к беззнаковому      |

Попробуем сравнить знаковое и беззнаковое число

```cpp
int main () 
{ 
	int x = −1; 
	unsigned y = 1; 
	cout << (x < y) << " "; 
	cout << (−1 < 1u) << endl; // суффикс u делает 1 типом unsigned по умолчанию
	return 0; 
} 
// 0 0
```

Раз 1 - беззнаковое число, то -1 приводится к беззнаковому число и получается очень большим, поэтому в обоих случаях false.