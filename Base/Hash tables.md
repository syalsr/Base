# Hash tables
# unordered_map и unordered_set
Этот контейнер отличается от map, тем что здесь ключи не сортируются, соответственно если нам не важен порядок, то можем выбрать в этот контейнер для большей производительности.

unordered контейнеры используют хеш-функции для составления хеш-таблицы на основе которых хранятся данные. Допустим нам нужно хранить автомобильные номера, в таком случае хеш-функцией может выступать номер региона, если все номера будут одного региона, то будет крайне не производительно, а если мы будем умножать простое число на каждый элемент номера, то получится уникальное число.

Хеш-таблица состоит из нескольких корзин по которым раскладываются объекты на основе хеш-функции. Если корзина занята другим объектом, то происходит коллизия. Для разрешения данной проблем используется метод цепочек, корзина состоит из списка объектов, сначала проверяется, что объекта нет в корзине, потом он добавляется по цепочке. Чем длиннее цепочка, тем менее производительнее таблица.

Для того, чтобы цепочки в корзине были короткими при добавлении нового объекта может случиться рехеширование в результате чего итератор инвалидируются. Удалять итераторы можно не опасаясь за итераторы на другие элементы.

Если в ассоциативном контейнере мы используем пользовательский тип данных, то хеш-функцию должны написать сами. Для встроенных типов данных уже есть хеш-функции(`std::hash<double> dhash`)

```cpp
struct Plate { 
	char C1; 
	int Number; 
	char C2; 
	char C3;
	int Region; 
};
bool operator==(const Plate& l, const Plate& r) { 
	return (l.C1 == r.C1) && (l.Number == r.Number) && (l.C2 == r.C2) && (l.C3 == r.C3) && (l.Region == r.Region); 
}
struct PlateHasher {
	size_t x = 9973;
	size_t operator() (const Plate& p) const { 
		size_t result = x * x * ihash(p.Number) + x * ihash(p.Region) + x * chash(p.C1) + x * chash(p.C2) + x * chash(p.C3);
		return result;
	}
	hash<int> ihash;
	hash<char> chash;
};
int main() {
	unordered_set<Plate, PlateHasher> h_plates; 
}
```