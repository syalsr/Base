# string в pure C
Строка является массив символов, последний символ `\0` null terminate, означает конец строки, если мы выделяем память для строки, нужно не забыть выделить 1 символ для нулевого термината.

![[../Files/Pasted image 20220317181106.png]]

`myString` указывает на строковый литерал который находиться в raw data, неизменяемая область памяти, если создадим еще один указатель и передадим такой же строковый литерал, то он будет указывать на туже область памяти, сделано это для экономии памяти.
```cpp
int main()  
{  
    const char* str1 = "Hello world\0";  
    const char* str2 = "Hello word\0";  
    const char* str3 = "Hello world\0";  
}
```
![[../Files/Pasted image 20220429154557.png]]

Допустим, у нас есть функция которая работает со строками в стиле C(`const char*`) и делает все буквы заглавными, мы можем передать туда указать на любой элемент вот так:

```cpp
const char* str = "Hello, world\0";
toUppercase(str);//HELLO, WORLD
toUppercase(str+7);//Hello, WORLD
```

**Преимущества:**
1. Просты в создании
2. Легковесны

**Недостатки:**
1. Трудно найти ошибку, если мы ее  допустили.
2. Не поддерживают ООП парадигму, т.е. есть конечно функции для работы с ними, но это функции, гораздо удобнее иметь методы, чтобы знать что конкретно это относится к строке, используя ООП, можно определить любой оператор  для строк, к примеру.
3. Утечки памяти.

# Классификация символов
1. isspace() - пробел
2. isblank() - пустой символ
3. iscntrl()
4. isupper()
5. islower()
6. isalpha()
7. isdigit()
8. ispunct()
9. isxdigit()
10. isalnum()
11. isprint()
12. isgraph()