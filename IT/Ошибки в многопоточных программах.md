# Ошибки в многопоточных программах
# Race condition
Случается, когда 2 [[Процессы]] или [[Потоки]] входят в критическую секцию - это секция, где происходит гонка данных и изменяют одни и те же данные. Для предотвращения подобных ошибок нужно использовать [[mutex и lock_guard]] или [[semaphore]] 

![[race_cond.excalidraw]]


# Data race
Возникает когда 2 потока хотят изменить одну ячейку памяти в одно и тоже время, т.е. когда у нас больше 1 ядра. Это влечет за собой UB.
```cpp
int x{};
void tr1()
{
	x = 1;
}
void tr2()
{
	x = 2;
}
thread tr1{tr1};
thread tr2{tr2};
```

Решение, сделать переменную [[atomic]]

# Dead lock
Оба потока должны захватить два мьютекса, но каждый поток захватил только один мьютекс и ждет другого. Ни один поток не может продолжить, так как каждый ждет, пока другой освободит нужный ему мьютекс.

```cpp
mutex m1;  
mutex m2;  
void deadlock1()  
{  
    lock_guard<mutex> mm1{m1};  
    this_thread::sleep_for(chrono::milliseconds(10));  
    lock_guard<mutex> mm2{m2};  
    cout << 1;  
}  
  
void deadlock2()  
{  
    lock_guard<mutex> mm2{m2};  
    this_thread::sleep_for(chrono::milliseconds(10));  
    lock_guard<mutex> mm1{m1};  
    cout << 2;  
}  
  
int main()  
{  
    thread t1{deadlock1};  
    thread t2{deadlock2};  
    t1.join();  
    t2.join();  
}
```

Для избегания данной ситуации нужно регламентировать порядок захвата мьютексов или захватывать сразу же два мьютекса использовав функцию `std::lock`

```cpp
void deadlock1()  
{  
    lock(m1, m2);  
    lock_guard<mutex> mm1{m1, adopt_lock};  
    this_thread::sleep_for(chrono::milliseconds(10));  
    lock_guard<mutex> mm2{m2, adopt_lock};  
    cout << 1;  
}  
  
void deadlock2()  
{  
    lock(m1, m2);  
    lock_guard<mutex> mm2{m2,adopt_lock};  
    this_thread::sleep_for(chrono::milliseconds(10));  
    lock_guard<mutex> mm1{m1,adopt_lock};  
    cout << 2;  
}
```
При помощи `adopt_lock` говорим `lock_guard`, что мьютексы уже захвачены, нужно лишь забрать владение. Попытка захвата любого мьютекса с помощью `lock` может привести к исключению. Если функция захватила первый мьютекс, а в результате захвата второго возникло исключение, то первый освобождается.

Deadlock также может происходить при присоединение потоков. Если каждый поток вызвал функцию `join()` объекта `thread` , связанного с другим потоком. В этом случае ни один поток не сможет продолжить выполнение, потому что будет ждать завершения другого потока. Решение - не ждать поток, если есть вероятность, что он будет ждать вас.

# Live lock
Как и с deal lock, потоки друг другу мешают, но в данном случае планировщик может все разрулить и какой-то начнет выполнения, но когда - неизвестно. 

# Starvation
Не смотря на отсутствие ошибок, потоки не могут получить доступ к разделяемому ресурсу, поскольку есть поток, который очень часто получает доступ к эксклюзивному ресурсу и долго выполняет свои операции используя эксклюзивный ресурс. Другие потоки, несмотря на отсутствие lock’ов не могут получить доступ к эксклюзивному ресурсу и выполнить свою работу.