# Конструктор копирования и оператор присваивания в производном классе
Если вашему производному классу не нужно иметь собственный конструктор копирования/оператор присваивания, то не нужно его писать, не зависимо определены ли они в базовом. Если в производном их не будет, то будут применяться дефолтные, также и с базовым, будет использоваться дефолтный либо свой

Если вы указываете конструктор копирования в производном классе, вам необходимо явно вызвать конструктору копирования в списке инициализации. Если этого не сделать, то будет использоваться конструктор по умолчанию базового класса.

Если мы определяем оператор присваивания, то мы также должны явно вызваться конструктор копирования базового класса.

```cpp
class Base
{
public:
    virtual ~Base() = default;
    Base() = default;
    Base(const Base& src) { }
};
class Derived : public Base
{
public:
    Derived() = default;
    Derived(const Derived& src) : Base{ src } { }
    Derived& operator=(const Derived& rhs)
    {
        if (&rhs == this) {
            return *this;
        }
        Base::operator=(rhs); // Calls parent's operator=.
        // Do necessary assignments for derived class.
        return *this;
    }
};


int main()
{
    Derived dd;
    Derived d{ dd };
}
```

Это все нужно для того, чтобы выполнилось полное копирование/присваивание объекта.