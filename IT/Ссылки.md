# Ссылки
Ссылки - псевдонимы(alias) на другую переменную. Т.е. ссылка становится этой переменной, все что происходит с ссылкой, то и происходит с переменной, но т.о. мы не тратим доп. память на создание такой же переменной. Ссылка, можно сказать, это константный указатель, мы можем изменять значение ссылки, но не то на что оно ссылается.

```cpp
int x { 3 };
int& xRef { x };
xRef = 10;//x=10
int& emptyRef;//error, ссылки всегда должны на что-то указывать
```

Константная ссылка - это константный указатель на константу. Мы не можем изменить не объект на который ссылка ссылается, не саму ссылку.

```cpp
int z;
const int& zRef { z };
zRef = 4; // DOES NOT COMPILE
```

non-const ref должна быть инициализирована [[rvalue lvalue reference|lvalue]]

Константная ссылка продлевает время жизни объекта, т.е. мы можем присвоить ей временное значение, допустим целочисленный литерал, возвращаемое значение функции, и эта ссылка сохранит его в памяти, иначе со следующей строки, временный объект уничтожился бы.

```cpp
int& unnamedRef1 { 5 }; // DOES NOT COMPILE
const int& unnamedRef2 { 5 }; // Works as expected

string getString() { return "Hello world!"; }
string& string1 { getString() }; // DOES NOT COMPILE
const string& string2 { getString() }; // Works as expected
```

Ссылка живет до конца своего выражения:

```cpp
struct S{
	int x;
	const int& y;
}

S x{1,2};//ok x=1, y=2, продлили время жизни объекта, он умрет когда x выйдет из скоупа
S* p = new S{1,2};//bad, у нас выражение new S{1,2}, после того как оно завершится, т.е. выделится память и вызовется конструктор, временный объект уничтожится и мы получим висячую ссылку
```

# Ссылка на указатель и указатель на ссылку
```cpp
int* intP { nullptr };
int*& ptrRef { intP };
ptrRef = new int;
*ptrRef = 5; //intP = 5
```

Мы не можем определить ссылку на ссылку и ссылку на указатель.

# Ссылка как возвращаемое значение функции
Можем вернуть ссылку на переменную из функции, но только если она продолжает жить после завершения работы функции, иначе получается мы возвращаем локальную ссылку которая уничтожается во время завершения функции, а это UB.

Зачем возвращать ссылки? Если мы хотим использовать их как lvalue, полезно для конвейерного вызова методов, либо если мы реализуем какой-то контейнер(возврат элемента для его изменения).

```cpp
class Build
public:
	Build() {}
	Build& BuildFactory() { return *this;}
	Build& BuildHouse()  { return *this;}
};
int main()
{
	Build b;
	b.BuildFactory().BuildHouse();
}
```

# Свертка ссылок
```cpp
int main() {  
    int x;  
    int &y = x;  
    auto &&d = move(y); // → int&&  
    auto &&c = y; // → int & && c = y;  
    auto &&f = move(y); // → int && && d = move(y);  
}
```

Ссылка на ссылку и rvalue ссылка на rvalue ссылка довольно странно, поэтому существуют правила для их свертки:

| Iner | Outer | Result |
| ---- | ----- | ------ |
| T&   | T&    | T&     |
| T&   | T&&   | T&     |
| T&&  | T&    | T&     |
| T&&  | T&&   | T&&    |

```cpp
auto &&c = y;       // → int & && c = y; 
				    // → int &c = y; 
auto &&d = move(y); // → int && && d = move(y); 
					// → int &&d = move(y);
```

Для шаблон немного по другому, если мы сворачиваем правой ссылкой тип lvalue выводится по правилам decltype

```cpp
template <typename T> int foo(T&&);  
int x;  
const int y = 5;  
foo(x); // → int foo<int&>(int&)//добавили ссылку  
foo(y); // → int foo<const int&>(const int&)  
foo(5); // → int foo<int>(int&&)
```

# Forwarding reference - универсальные ссылки
```cpp
int x; 
auto &&y = x; // → int &y = x;
decltype(x) && z = x; // int &z = x;
template void foo(T&& t); 
foo(x); // foo(int& t) как вы думаете, чему равен T?
```

Это те ссылки которые имеют контекст сворачивания - T&, T&&, auto&, auto&&

# Неуниверсальные ссылки
```cpp
template<typename T> struct Buffer {  
    void emplace(T&& param); // здесь T подставляется, метод не шаблонный, вывод происходит в конструкторе, свертки не будет, всегда будет rvalue ref
    template<typename T> struct Buffer {  
        template<typename U>  
        void emplace(U&& param); // здесь U выводится, шаблонный метод, здесь же есть контекст свертки
```

Т.е. чтобы происходила свертка должно выполняться 2 условия:
1. Тип должен выводиться
2. Неуточненный ничем кроме ссылки тип, т.е. если в примере выше добавим const в шаблонный метод, то все перестанет работать

```cpp
template<typename T> struct S {
  void foo(T&& param);//T&& всегда правая ссылка, здесь нет вывода, тип подставляется
  template<typename U> void bar(U&& param);//это может быть как правая так и левая ссылка, происходит вывод типовт
};

template<typename T> void buz(const T&& param);

int main() {
  S<int> t; int y;
#if 1
  const auto &&x = y;//error: cannot bind rvalue reference of type  
  buz(y);//const int&& to
  t.foo(y);//lvalue of type 'int'
#endif  
  t.bar(y);//void S<int>::bar<int&>(int&)
}
```

Исходя из этого в цикле for(auto&& x: v) стоит писать auto&&, т.к. благодаря свертки, она понимает, что если вернется lvalue, то она свернется в lvalue&, если rvalue, в rvalue&&.

# Различия между ссылка и указателями
1. Все что мы можем сделать с помощью ссылок, можно сделать с помощью указателей
2. Ссылки делают код чище и понятнее
3. В большинстве случае используют ссылки, но есть случаи когда нужны указатели.
	1. Использование динамической памяти
	2. Использование полиморфных объектов в контейнерах
	3. Когда нужно опционально его использовать, т.е. либо он на что-то указывает, либо на nullptr.


