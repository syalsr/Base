# Unique_ptr
Создает умный указатель с уникальным владением объекта путем удалена конструктора копирования и копирующего присваивания.
```cpp
void run(A* ptr);

auto ptr = unique_ptr(new A);
run(ptr.get());//получаем из умного указателя обычный, чтобы передать в функцию

auto ptr2 = ptr; //ошибка,у unique_ptr нет конструктора копирования, поскольку он создает уникальные объект. На один и тот же динамический объект может указывать только один unique_ptr. Можем его переместить
auto ptr2 = move(ptr); //ptr стал пустым и указывает в nullptr
//чтобы сэкономить место, для создания можно использовать пораждающую функцию

auto ptr3 = make_unique<A>();

ptr3.reset();//освобождает память и устанавливает nullptr
ptr3.reset(new A);//освобождает память и снова выделяет ее

A* a { ptr3.release() };//умный указатель отдает владение ресурсами сырому указателю, сам устанавливается в nullptr, мы ответственны за освобождение ресурсов

auto myVariableSizedArray { make_unique<int[]>(10) };//но лучше использовать контейнеры
myVariableSizedArray[1] = 123;
```

Безопаснее всего создавать умный указатель с помощью порождающей функции `make_unqiue`, т.к. до C++ 17 можно было получить утечку памяти, если вызовется исключения из конструктора:

```cpp
foo(unique_ptr<Simple> { new Simple{} }, unique_ptr<Bar> { new Bar { data() } });
```

По умолчанию unique_ptr используется стандартный `new` и `delete`, но мы можем это изменить.

```cpp
int* my_alloc(int value) { return new int { value }; }
void my_free(int* p) { delete p; }
int main()
{
	unique_ptr<int, decltype(&my_free)> myIntSmartPtr { my_alloc(42), my_free };
}
```

Полезно, если мы хотим не только очистить ресурсы, но и к примеру, закрыть файл, когда выйдем из области видимости.
