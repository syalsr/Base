# Наследование и полиморфизм
Подход заключается в том, чтобы определять одноранговые классы от одного базового класса, зачем:
1. производные классы имеют одинаковые интерфейс определенный в базовом классе
2. указатель/ссылка базового класса может вызывать переопределенные методы

```cpp
Base* base = new Derived();//Создаем объект типа Derived на который указывает указатель Base
base->not_virt();
base->virt();

Derived derived;
Base& base{ derived };
base.not_virt();
base.virt();
```

1. Если производный класс переопределяет метод базового класса, то будет вызван метод из производного классе, иначе из базового
2. С помощью указателя или ссылки мы не сможем получить доступ к данным или методам которых нет в базовом классе

```cpp
Derived derived;
Base base {derived};
derived.non_base_method();//error, этого метода нет в базовом классе
```

```plantuml
class Car

Car <|-- PassengerCar
Car <|-- Truck
```


```cpp
class Car
{
public:
	virtual ~Car() = default;
	virtual void Drive() = 0;
};
class Truck : public Car{
public:
	void Drive() override {}
};
class PassengerCar : public Car{
public:
	void Drive() override {}
};

vector<unique_ptr<Car>> car_park;
car_park.push_back(make_unique<Truck>());
car_park.push_back(make_unique<Truck>());
car_park.push_back(make_unique<Truck>());
car_park.push_back(make_unique<PassengerCar>());
car_park.push_back(make_unique<PassengerCar>());
for(auto& car : car_park)
{
	car->Drive();
}
```

При помощи полиморфизма мы смогли пройти по всему нашему парку состоящему из разных типов машин, но имеющих одинаковый базовый класс, и вызвать метод объявленный в базовом классе.